<!DOCTYPE html>





<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicon128.ico?v=7.4.1">
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicon32.ico?v=7.4.1">
  <link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicon16.ico?v=7.4.1">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.1" color="#222">
  <link rel="alternate" href="/atom.xml" title="nicolas" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css?v=7.4.1">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.4.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="[TOC]第二十章 泛型 普通的类和方法只能使用特定的类型：基本数据类型或类类型。如果编写的代码需要应用于多种类型，这种严苛的限制对代码的束缚就会很大。 多态是一种面向对象思想的泛化机制。你可以将方法的参数类型设为基类，这样的方法就可以接受任何派生类作为参数，包括暂时还不存在的类。这样的方法更通用，应用范围更广。在类内部也是如此，在任何使用特定类型的地方，基类意味着更大的灵活性。除了 final">
<meta name="keywords" content="学习笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="OnJava8-3">
<meta property="og:url" content="https://codeofli.github.io/2019/10/java-note/OnJava8/OnJava8-3/index.html">
<meta property="og:site_name" content="nicolas">
<meta property="og:description" content="[TOC]第二十章 泛型 普通的类和方法只能使用特定的类型：基本数据类型或类类型。如果编写的代码需要应用于多种类型，这种严苛的限制对代码的束缚就会很大。 多态是一种面向对象思想的泛化机制。你可以将方法的参数类型设为基类，这样的方法就可以接受任何派生类作为参数，包括暂时还不存在的类。这样的方法更通用，应用范围更广。在类内部也是如此，在任何使用特定类型的地方，基类意味着更大的灵活性。除了 final">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2021-10-23T02:19:02.849Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="OnJava8-3">
<meta name="twitter:description" content="[TOC]第二十章 泛型 普通的类和方法只能使用特定的类型：基本数据类型或类类型。如果编写的代码需要应用于多种类型，这种严苛的限制对代码的束缚就会很大。 多态是一种面向对象思想的泛化机制。你可以将方法的参数类型设为基类，这样的方法就可以接受任何派生类作为参数，包括暂时还不存在的类。这样的方法更通用，应用范围更广。在类内部也是如此，在任何使用特定类型的地方，基类意味着更大的灵活性。除了 final">
  <link rel="canonical" href="https://codeofli.github.io/2019/10/java-note/OnJava8/OnJava8-3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>OnJava8-3 | nicolas</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">nicolas</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Yesterday you said tomorow.</p>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    
      
      
        
      
        
      
        
      
    

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    
      
      
        
      
        
      
        
      
    

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    
      
      
        
      
        
      
        
          
        
      
    

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">32</span></a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    
      
      
        
      
        
          
        
      
        
      
    

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">10</span></a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    
      
      
        
          
        
      
        
      
        
      
    

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">48</span></a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/codeOflI/codeOflI.github.io/tree/dev" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://codeofli.github.io/2019/10/java-note/OnJava8/OnJava8-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="nicolas lee">
      <meta itemprop="description" content="Yesterday you said tomorow.">
      <meta itemprop="image" content="/assets/img/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nicolas">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">OnJava8-3

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-10-13 22:19:09" itemprop="dateCreated datePublished" datetime="2019-10-13T22:19:09+08:00">2019-10-13</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-23 10:19:02" itemprop="dateModified" datetime="2021-10-23T10:19:02+08:00">2021-10-23</time>
              </span>
            
          

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span></span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>[TOC]</p><h1 id="第二十章-泛型"><a href="#第二十章-泛型" class="headerlink" title="第二十章 泛型"></a>第二十章 泛型</h1><blockquote>
<p>普通的类和方法只能使用特定的类型：基本数据类型或类类型。如果编写的代码需要应用于多种类型，这种严苛的限制对代码的束缚就会很大。</p>
</blockquote><p>多态是一种面向对象思想的泛化机制。你可以将方法的参数类型设为基类，这样的方法就可以接受任何派生类作为参数，包括暂时还不存在的类。这样的方法更通用，应用范围更广。在类内部也是如此，在任何使用特定类型的地方，基类意味着更大的灵活性。除了 <code>final</code> 类（或只提供私有构造函数的类）任何类型都可被扩展，所以大部分时候这种灵活性是自带的。</p><a id="more"></a>
<!-- Generics -->



<p>拘泥于单一的继承体系太过局限，因为只有继承体系中的对象才能适用基类作为参数的方法中。如果方法以接口而不是类作为参数，限制就宽松多了，只要实现了接口就可以。这给予调用方一种选项，通过调整现有的类来实现接口，满足方法参数要求。接口可以突破继承体系的限制。</p>
<p>即便是接口也还是有诸多限制。一旦指定了接口，它就要求你的代码必须使用特定的接口。而我们希望编写更通用的代码，<strong>能够适用“非特定的类型”，而不是一个具体的接口或类。</strong></p>
<p>这就是泛型的概念，是 Java 5 的重大变化之一。<strong>泛型实现了<em>参数化类型</em>，这样你编写的组件（通常是集合）可以适用于多种类型。</strong>“泛型”这个术语的含义是“适用于很多类型”。编程语言中<strong>泛型出现的初衷是通过解耦类或方法与所使用的类型之间的约束</strong>，使得类或方法具备最宽泛的表达力。随后你会发现 Java 中泛型的实现并没有那么“泛”，你可能会质疑“泛型”这个词是否合适用来描述这一功能。</p>
<p>如果你从未接触过参数化类型机制，你会发现泛型对 Java 语言确实是个很有益的补充。在你实例化一个类型参数时，编译器会负责转型并确保类型的正确性。这是一大进步。</p>
<p>然而，如果你了解其他语言（例如 C++ ）的参数化机制，你会发现，Java 泛型并不能满足所有的预期。使用别人创建好的泛型相对容易，但是创建自己的泛型时，就会遇到很多意料之外的麻烦。</p>
<p>这并不是说 Java 泛型毫无用处。在很多情况下，它可以使代码更直接更优雅。不过，如果你见识过那种实现了更纯粹的泛型的编程语言，那么，Java 可能会令你失望.</p>
<h3 id="与-C-的比较"><a href="#与-C-的比较" class="headerlink" title="与 C++ 的比较"></a>与 C++ 的比较</h3><p>Java 的设计者曾说过，这门语言的灵感主要来自 C++ 。尽管如此，学习 Java 时基本不用参考 C++ 。</p>
<p>但是，Java 中的泛型需要与 C++ 进行对比，理由有两个：首先，理解 C++ <em>模板</em>（泛型的主要灵感来源，包括基本语法）的某些特性，有助于理解泛型的基础理念。同时，非常重要的一点是，你可以了解 Java 泛型的局限是什么，以及为什么会有这些局限<strong>。最终的目标是明确 Java 泛型的边界，让你成为一个程序高手。只有知道了某个技术不能做什么，你才能更好地做到所能做的</strong>（部分原因是，不必浪费时间在死胡同里）。</p>
<p>第二个原因是，在 Java 社区中，大家普遍对 C++ 模板有一种误解，而这种误解可能会令你在理解泛型的意图时产生偏差。</p>
<!-- Simple Generics -->

<h2 id="简单泛型"><a href="#简单泛型" class="headerlink" title="简单泛型"></a>简单泛型</h2><p>促成泛型出现的最主要的动机之一是为了创建<em>集合类</em>，参见 <a href="book/12-Collections.md">集合</a> 章节。集合用于存放要使用到的对象。数组也是如此，不过集合比数组更加灵活，功能更丰富。几乎所有程序在运行过程中都会涉及到一组对象，因此集合是可复用性最高的类库之一。</p>
<p>在 Java 5 之前，我们可以让这个类直接持有 <code>Object</code> 类型的对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ObjectHolder.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectHolder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObjectHolder</span><span class="params">(Object a)</span> </span>&#123; <span class="keyword">this</span>.a = a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object a)</span> </span>&#123; <span class="keyword">this</span>.a = a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> a; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ObjectHolder h2 = <span class="keyword">new</span> ObjectHolder(<span class="keyword">new</span> Automobile());</span><br><span class="line">        Automobile a = (Automobile)h2.get();</span><br><span class="line">        h2.set(<span class="string">"Not an Automobile"</span>);</span><br><span class="line">        String s = (String)h2.get();</span><br><span class="line">        h2.set(<span class="number">1</span>); <span class="comment">// 自动装箱为 Integer</span></span><br><span class="line">        Integer x = (Integer)h2.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，<code>ObjectHolder</code> 可以持有任何类型的对象，在上面的示例中，一个 <code>ObjectHolder</code> 先后持有了三种不同类型的对象。</p>
<p>一个集合中存储多种不同类型的对象的情况很少见，通常而言，我们只会用集合存储同一种类型的对象。泛型的主要目的之一就是用来约定集合要存储什么类型的对象，并且通过编译器确保规约得以满足。</p>
<p>因此，与其使用 <code>Object</code> ，我们更希望先指定一个类型占位符，稍后再决定具体使用什么类型。要达到这个目的，需要使用<em>类型参数</em>，用尖括号括住，放在类名后面。然后在使用这个类时，再用实际的类型替换此类型参数。在下面的例子中，<code>T</code> 就是类型参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/GenericHolder.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericHolder</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericHolder</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T a)</span> </span>&#123; <span class="keyword">this</span>.a = a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> a; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericHolder&lt;Automobile&gt; h3 = <span class="keyword">new</span> GenericHolder&lt;Automobile&gt;();</span><br><span class="line">        h3.set(<span class="keyword">new</span> Automobile()); <span class="comment">// 此处有类型校验</span></span><br><span class="line">        Automobile a = h3.get();  <span class="comment">// 无需类型转换</span></span><br><span class="line">        <span class="comment">//- h3.set("Not an Automobile"); // 报错</span></span><br><span class="line">        <span class="comment">//- h3.set(1);  // 报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建 <code>GenericHolder</code> 对象时，必须指明要持有的对象的类型，将其置于尖括号内，就像 <code>main()</code> 中那样使用。然后，你就只能在 <code>GenericHolder</code> 中存储该类型（或其子类，因为多态与泛型不冲突）的对象了。当你调用 <code>get()</code> 取值时，直接就是正确的类型。</p>
<p>这就是 Java 泛型的核心概念：<strong>你只需告诉编译器要使用什么类型，剩下的细节交给它来处理。</strong></p>
<p>你可能注意到 <code>h3</code> 的定义非常繁复。在 <code>=</code> 左边有 <code>GenericHolder&lt;Automobile&gt;</code>, 右边又重复了一次。在 Java 5 中，这种写法被解释成“必要的”，<strong>但在 Java 7 中设计者修正了这个问题（新的简写语法随后成为备受欢迎的特性）。</strong>以下是简写的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GenericHolder&lt;Bob&gt; h3 = <span class="keyword">new</span> GenericHolder&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>注意，<strong>在 <code>h3</code> 的定义处，<code>=</code> 右边的尖括号是空的（称为“钻石语法”），而不是重复左边的类型信息。</strong>在本书剩余部分都会使用这种语法。</p>
<p>一般来说，你可以认为<strong>泛型和其他类型差不多，只不过它们碰巧有类型参数罢了</strong>。在使用泛型时，你<strong>只需要指定它们的名称和类型参数列表即可。</strong></p>
<h3 id="一个元组类库"><a href="#一个元组类库" class="headerlink" title="一个元组类库"></a>一个元组类库</h3><p>有时一个方法需要能返回多个对象。而 <strong>return</strong> 语句只能返回单个对象，解决方法就是创建一个对象，用它打包想要返回的多个对象。当然，可以在每次需要的时候，专门创建一个类来完成这样的工作。但是有了泛型，我们就可以一劳永逸。同时，还获得了编译时的类型安全。</p>
<p>这个概念称为<strong><em>元组</em>，它是将一组对象直接打包存储于单一对象中。</strong>可以从该对象读取其中的元素，但不允许向其中存储新对象（这个概念也称为 <em>数据传输对象</em> 或 <em>信使</em> ）。</p>
<p>通常，元组可以具有任意长度，元组中的对象可以是不同类型的。不过，我们希望能够为每个对象指明类型，并且从元组中读取出来时，能够得到正确的类型。要处理不同长度的问题，我们需要创建多个不同的元组。下面是一个可以存储两个对象的元组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/Tuple2.java</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tuple2</span>&lt;<span class="title">A</span>, <span class="title">B</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> A a1;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> B a2;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tuple2</span><span class="params">(A a, B b)</span> </span>&#123; a1 = a; a2 = b; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">rep</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> a1 + <span class="string">", "</span> + a2; &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"("</span> + rep() + <span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造函数传入要存储的对象。这个元组隐式地保持了其中元素的次序。</p>
<p>初次阅读上面的代码时，你可能认为这违反了 Java 编程的封装原则。<code>a1</code> 和 <code>a2</code> 应该声明为 <strong>private</strong>，然后提供 <code>getFirst()</code> 和 <code>getSecond()</code> 取值方法才对呀？考虑下这样做能提供的“安全性”是什么：<strong>元组的使用程序可以读取 <code>a1</code> 和 <code>a2</code> 然后对它们执行任何操作，但无法对 <code>a1</code> 和 <code>a2</code> 重新赋值。</strong>例子中的 <code>final</code> 可以实现同样的效果，并且更为简洁明了。</p>
<p>另一种设计思路是允许元组的用户给 <code>a1</code> 和 <code>a2</code> 重新赋值。然而，采用上例中的形式无疑更加安全，如果用户想存储不同的元素，就会强制他们创建新的 <code>Tuple2</code> 对象。</p>
<p>我们可以利用继承机制实现长度更长的元组。添加更多的类型参数就行了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/Tuple3.java</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tuple3</span>&lt;<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>&gt; <span class="keyword">extends</span> <span class="title">Tuple2</span>&lt;<span class="title">A</span>, <span class="title">B</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> C a3;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tuple3</span><span class="params">(A a, B b, C c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(a, b);</span><br><span class="line">        a3 = c;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">rep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.rep() + <span class="string">", "</span> + a3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// onjava/Tuple4.java</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tuple4</span>&lt;<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>, <span class="title">D</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">Tuple3</span>&lt;<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> D a4;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tuple4</span><span class="params">(A a, B b, C c, D d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(a, b, c);</span><br><span class="line">        a4 = d;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">rep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.rep() + <span class="string">", "</span> + a4;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// onjava/Tuple5.java</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tuple5</span>&lt;<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>, <span class="title">D</span>, <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">Tuple4</span>&lt;<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>, <span class="title">D</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> E a5;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tuple5</span><span class="params">(A a, B b, C c, D d, E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(a, b, c, d);</span><br><span class="line">        a5 = e;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">rep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.rep() + <span class="string">", "</span> + a5;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>演示需要，再定义两个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Amphibian.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Amphibian</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// generics/Vehicle.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>使用元组时，你只需要定义一个长度适合的元组，将其作为返回值即可。注意下面例子中方法的返回类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/TupleTest.java</span></span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TupleTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Tuple2&lt;String, Integer&gt; <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 47 自动装箱为 Integer</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tuple2&lt;&gt;(<span class="string">"hi"</span>, <span class="number">47</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">static</span> Tuple3&lt;Amphibian, String, Integer&gt; <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tuple3&lt;&gt;(<span class="keyword">new</span> Amphibian(), <span class="string">"hi"</span>, <span class="number">47</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">static</span> Tuple4&lt;Vehicle, Amphibian, String, Integer&gt; <span class="title">h</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tuple4&lt;&gt;(<span class="keyword">new</span> Vehicle(), <span class="keyword">new</span> Amphibian(), <span class="string">"hi"</span>, <span class="number">47</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">static</span> Tuple5&lt;Vehicle, Amphibian, String, Integer, Double&gt; <span class="title">k</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tuple5&lt;&gt;(<span class="keyword">new</span> Vehicle(), <span class="keyword">new</span> Amphibian(), <span class="string">"hi"</span>, <span class="number">47</span>, <span class="number">11.1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Tuple2&lt;String, Integer&gt; ttsi = f();</span><br><span class="line">        System.out.println(ttsi);</span><br><span class="line">        <span class="comment">// ttsi.a1 = "there"; // 编译错误，因为 final 不能重新赋值</span></span><br><span class="line">        System.out.println(g());</span><br><span class="line">        System.out.println(h());</span><br><span class="line">        System.out.println(k());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出：</span></span><br><span class="line"><span class="comment"> (hi, 47)</span></span><br><span class="line"><span class="comment"> (Amphibian@1540e19d, hi, 47)</span></span><br><span class="line"><span class="comment"> (Vehicle@7f31245a, Amphibian@6d6f6e28, hi, 47)</span></span><br><span class="line"><span class="comment"> (Vehicle@330bedb4, Amphibian@2503dbd3, hi, 47, 11.1)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>有了泛型，你可以很容易地创建元组，令其返回一组任意类型的对象。</p>
<p>通过 <code>ttsi.a1 = &quot;there&quot;</code> 语句的报错，我们可以看出，<strong>final</strong> 声明确实可以确保 <strong>public</strong> 字段在对象被构造出来之后就不能重新赋值了。</p>
<p>在上面的程序中，<code>new</code> 表达式有些啰嗦。本章稍后会介绍，如何利用 <em>泛型方法</em> 简化它们。</p>
<h3 id="一个堆栈类"><a href="#一个堆栈类" class="headerlink" title="一个堆栈类"></a>一个堆栈类</h3><p>接下来我们看一个稍微复杂一点的例子：堆栈。在 <a href="book/12-Collections.md">集合</a> 一章中，我们用 <code>LinkedList</code> 实现了 <code>onjava.Stack</code> 类。在那个例子中，<code>LinkedList</code> 本身已经具备了创建堆栈所需的方法。<code>Stack</code> 是通过两个泛型类 <code>Stack&lt;T&gt;</code> 和 <code>LinkedList&lt;T&gt;</code> 的组合来创建。我们可以看出，泛型只不过是一种类型罢了（稍后我们会看到一些例外的情况）。</p>
<p>这次我们不用 <code>LinkedList</code> 来实现自己的内部链式存储机制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/LinkedStack.java</span></span><br><span class="line"><span class="comment">// 用链式结构实现的堆栈</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedStack</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">U</span>&gt; </span>&#123;</span><br><span class="line">        U item;</span><br><span class="line">        Node&lt;U&gt; next;</span><br><span class="line">    </span><br><span class="line">        Node() &#123; item = <span class="keyword">null</span>; next = <span class="keyword">null</span>; &#125;</span><br><span class="line">        </span><br><span class="line">        Node(U item, Node&lt;U&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> item == <span class="keyword">null</span> &amp;&amp; next == <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; top = <span class="keyword">new</span> Node&lt;&gt;();  <span class="comment">// 栈顶</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T item)</span> </span>&#123;</span><br><span class="line">        top = <span class="keyword">new</span> Node&lt;&gt;(item, top);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T result = top.item;</span><br><span class="line">        <span class="keyword">if</span> (!top.end()) &#123;</span><br><span class="line">            top = top.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedStack&lt;String&gt; lss = <span class="keyword">new</span> LinkedStack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : <span class="string">"Phasers on stun!"</span>.split(<span class="string">" "</span>)) &#123;</span><br><span class="line">            lss.push(s);</span><br><span class="line">        &#125;</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">while</span> ((s = lss.pop()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stun!</span><br><span class="line">on</span><br><span class="line">Phasers</span><br></pre></td></tr></table></figure>

<p>内部类 <code>Node</code> 也是一个泛型，它拥有自己的类型参数。</p>
<p>这个例子使用了一个 <em>末端标识</em> (end sentinel) 来判断栈何时为空。这个末端标识是在构造 <code>LinkedStack</code> 时创建的。然后，每次调用 <code>push()</code> 就会创建一个 <code>Node&lt;T&gt;</code> 对象，并将其链接到前一个 <code>Node&lt;T&gt;</code> 对象。当你调用 <code>pop()</code> 方法时，总是返回 <code>top.item</code>，然后丢弃当前 <code>top</code> 所指向的 <code>Node&lt;T&gt;</code>，并将 <code>top</code> 指向下一个 <code>Node&lt;T&gt;</code>，除非到达末端标识，这时就不能再移动 <code>top</code> 了。如果已经到达末端，程序还继续调用 <code>pop()</code> 方法，它只能得到 <code>null</code>，说明栈已经空了。</p>
<h3 id="RandomList"><a href="#RandomList" class="headerlink" title="RandomList"></a>RandomList</h3><p>作为容器的另一个例子，假设我们需要一个持有特定类型对象的列表，每次调用它的 <code>select()</code> 方法时都随机返回一个元素。如果希望这种列表可以适用于各种类型，就需要使用泛型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/RandomList.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(rand.nextInt(size()));</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RandomList&lt;String&gt; rs = <span class="keyword">new</span> RandomList&lt;&gt;();</span><br><span class="line">        Array.stream(<span class="string">"The quick brown fox jumped over the lazy brown dog"</span>.split(<span class="string">" "</span>)).forEach(rs::add);</span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">11</span>).forEach(i -&gt; </span><br><span class="line">            System.out.print(rs.select() + <span class="string">" "</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brown over fox quick quick dog brown The brown lazy brown</span><br></pre></td></tr></table></figure>

<p><code>RandomList</code> 继承了 <code>ArrayList</code> 的所有方法。本例中只添加了 <code>select()</code> 这个方法。</p>
<!-- Generic Interfaces -->

<h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p><strong>泛型也可以应用于接口。</strong>例如 <em>生成器*，这是一种专门负责创建对象的类。实际上，这是 *工厂方法</em> 设计模式的一种应用。不过，当使用生成器创建新的对象时，它不需要任何参数，而工厂方法一般需要参数。生成器无需额外的信息就知道如何创建新对象。</p>
<p>一般而言，一个生成器只定义一个方法，用于创建对象。例如 <code>java.util.function</code> 类库中的 <code>Supplier</code> 就是一个生成器，调用其 <code>get()</code> 获取对象。<code>get()</code> 是泛型方法，返回值为类型参数 <code>T</code>。</p>
<!-- Generic Methods -->

<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>到目前为止，我们已经研究了参数化整个类。其实还可以参数化类中的方法。类本身可能是泛型的，也可能不是，不过这与它的方法是否是泛型的并没有什么关系。</p>
<p><strong>泛型方法独立于类而改变方法。</strong>作为准则，<strong>请“尽可能”使用泛型方法。</strong>通常将<strong>单个方法泛型化要比将整个类泛型化更清晰易懂。</strong></p>
<p>如果方法是 <strong>static</strong> 的，则<strong>无法访问该类的泛型类型参数</strong>，因此，如果使用了泛型类型参数，则它必须是泛型方法。</p>
<p>泛型方法支持static</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;A, B&gt; <span class="function">Tuple2&lt;A, B&gt; <span class="title">tuple</span><span class="params">(A a, B b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Tuple2&lt;&gt;(a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; T <span class="title">executeQuery</span><span class="params">(String sql, Function&lt;ResultSet, T&gt; parseResultSet, Object... args)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>要定义泛型方法，请将泛型参数列表放置在返回值之前。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/GenericMethods.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericMethods</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">        System.out.println(x.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericMethods gm = <span class="keyword">new</span> GenericMethods();</span><br><span class="line">        gm.f(<span class="string">""</span>);</span><br><span class="line">        gm.f(<span class="number">1</span>);</span><br><span class="line">        gm.f(<span class="number">1.0</span>);</span><br><span class="line">        gm.f(<span class="number">1.0F</span>);</span><br><span class="line">        gm.f(<span class="string">'c'</span>);</span><br><span class="line">        gm.f(gm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">java.lang.String</span></span><br><span class="line"><span class="comment">java.lang.Integer</span></span><br><span class="line"><span class="comment">java.lang.Double</span></span><br><span class="line"><span class="comment">java.lang.Float</span></span><br><span class="line"><span class="comment">java.lang.Character</span></span><br><span class="line"><span class="comment">GenericMethods</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>尽管可以同时对类及其方法进行参数化，但这里未将 <strong>GenericMethods</strong> 类参数化。只有方法 <code>f()</code> 具有类型参数，该参数由方法返回类型之前的参数列表指示。</p>
<p>对于泛型类，必须在实例化该类时指定类型参数。<strong>使用泛型方法时，通常不需要指定参数类型，因为编译器会找出这些类型。 这称为 <em>类型参数推断</em>。</strong>因此，对 <code>f()</code> 的调用看起来像普通的方法调用，并且 <code>f()</code> 看起来像被重载了无数次一样。它甚至会接受 <strong>GenericMethods</strong> 类型的参数。</p>
<p>如果使用基本类型调用 <code>f()</code> ，自动装箱就开始起作用，自动将基本类型包装在它们对应的包装类型中。</p>
<!-- Varargs and Generic Methods -->

<h3 id="变长参数和泛型方法"><a href="#变长参数和泛型方法" class="headerlink" title="变长参数和泛型方法"></a>变长参数和泛型方法</h3><p>泛型方法和变长参数列表可以很好地共存：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/GenericVarargs.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericVarargs</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SafeVarargs</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">makeList</span><span class="params">(T... args)</span> </span>&#123;</span><br><span class="line">        List&lt;T&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (T item : args)</span><br><span class="line">            result.add(item);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; ls = makeList(<span class="string">"A"</span>);</span><br><span class="line">        System.out.println(ls);</span><br><span class="line">        ls = makeList(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>);</span><br><span class="line">        System.out.println(ls);</span><br><span class="line">        ls = makeList(</span><br><span class="line">                <span class="string">"ABCDEFFHIJKLMNOPQRSTUVWXYZ"</span>.split(<span class="string">""</span>));</span><br><span class="line">        System.out.println(ls);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[A]</span></span><br><span class="line"><span class="comment">[A, B, C]</span></span><br><span class="line"><span class="comment">[A, B, C, D, E, F, F, H, I, J, K, L, M, N, O, P, Q, R,</span></span><br><span class="line"><span class="comment">S, T, U, V, W, X, Y, Z]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>此处显示的 <code>makeList()</code> 方法产生的功能与标准库的 <code>java.util.Arrays.asList()</code> 方法相同。</p>
<p><code>@SafeVarargs</code> 注解保证我们不会对变长参数列表进行任何修改，这是正确的，因为我们只从中读取。如果没有此注解，编译器将无法知道这些并会发出警告。</p>
<!-- A General-Purpose Supplier -->

<h3 id="一个泛型的-Supplier"><a href="#一个泛型的-Supplier" class="headerlink" title="一个泛型的 Supplier"></a>一个泛型的 Supplier</h3><p>这是一个为任意具有无参构造方法的类生成 <strong>Supplier</strong> 的类。为了减少键入，它还包括一个用于生成 <strong>BasicSupplier</strong> 的泛型方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/BasicSupplier.java</span></span><br><span class="line"><span class="comment">// Supplier from a class with a no-arg constructor</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicSupplier</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; type;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BasicSupplier</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Assumes type is a public class:</span></span><br><span class="line">            <span class="keyword">return</span> type.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException |</span><br><span class="line">                IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Produce a default Supplier from a type token:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Supplier&lt;T&gt; <span class="title">create</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BasicSupplier&lt;&gt;(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此类提供了产生以下对象的基本实现：</p>
<ol>
<li>是 <strong>public</strong> 的。 因为 <strong>BasicSupplier</strong> 在单独的包中，所以相关的类必须具有 <strong>public</strong> 权限，而不仅仅是包级访问权限。</li>
<li>具有无参构造方法。要创建一个这样的 <strong>BasicSupplier</strong> 对象，请调用 <code>create()</code> 方法，并将要生成类型的类型令牌传递给它。通用的 <code>create()</code> 方法提供了 <code>BasicSupplier.create(MyType.class)</code> 这种较简洁的语法来代替较笨拙的 <code>new BasicSupplier &lt;MyType&gt;(MyType.class)</code>。</li>
</ol>
<p>例如，这是一个具有无参构造方法的简单类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/CountedObject.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountedObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id = counter++;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">id</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"CountedObject "</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>CountedObject</strong> 类可以跟踪自身创建了多少个实例，并通过 <code>toString()</code> 报告这些实例的数量。 <strong>BasicSupplier</strong> 可以轻松地为 <strong>CountedObject</strong> 创建 <strong>Supplier</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// generics/BasicSupplierDemo.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> onjava.BasicSupplier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicSupplierDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream.generate(</span><br><span class="line">                BasicSupplier.create(CountedObject.class))</span><br><span class="line">                .limit(<span class="number">5</span>)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">CountedObject 0</span></span><br><span class="line"><span class="comment">CountedObject 1</span></span><br><span class="line"><span class="comment">CountedObject 2</span></span><br><span class="line"><span class="comment">CountedObject 3</span></span><br><span class="line"><span class="comment">CountedObject 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>泛型方法减少了产生 Supplier 对象所需的代码量。</strong> Java 泛型强制传递 <strong>Class</strong> 对象，以便在 <code>create()</code> 方法中将其用于类型推断。</p>
<!-- Simplifying Tuple Use -->

<h3 id="简化元组的使用"><a href="#简化元组的使用" class="headerlink" title="简化元组的使用"></a>简化元组的使用</h3><p>使用类型参数推断和静态导入，我们将把早期的元组重写为更通用的库。在这里，<strong>我们使用重载的静态方法创建元组：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/Tuple.java</span></span><br><span class="line"><span class="comment">// Tuple library using type argument inference</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tuple</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;A, B&gt; <span class="function">Tuple2&lt;A, B&gt; <span class="title">tuple</span><span class="params">(A a, B b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tuple2&lt;&gt;(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;A, B, C&gt; Tuple3&lt;A, B, C&gt;</span><br><span class="line">    tuple(A a, B b, C c) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tuple3&lt;&gt;(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;A, B, C, D&gt; Tuple4&lt;A, B, C, D&gt;</span><br><span class="line">    tuple(A a, B b, C c, D d) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tuple4&lt;&gt;(a, b, c, d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;A, B, C, D, E&gt;</span><br><span class="line">    <span class="function">Tuple5&lt;A, B, C, D, E&gt; <span class="title">tuple</span><span class="params">(A a, B b, C c, D d, E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tuple5&lt;&gt;(a, b, c, d, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们修改 <strong>TupleTest.java</strong> 来测试 <strong>Tuple.java</strong> :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/TupleTest2.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> onjava.Tuple2;</span><br><span class="line"><span class="keyword">import</span> onjava.Tuple3;</span><br><span class="line"><span class="keyword">import</span> onjava.Tuple4;</span><br><span class="line"><span class="keyword">import</span> onjava.Tuple5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> onjava.Tuple.tuple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TupleTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Tuple2&lt;String, Integer&gt; <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tuple(<span class="string">"hi"</span>, <span class="number">47</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Tuple2 <span class="title">f2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tuple(<span class="string">"hi"</span>, <span class="number">47</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Tuple3&lt;Amphibian, String, Integer&gt; <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tuple(<span class="keyword">new</span> Amphibian(), <span class="string">"hi"</span>, <span class="number">47</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Tuple4&lt;Vehicle, Amphibian, String, Integer&gt; <span class="title">h</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tuple(</span><br><span class="line">                <span class="keyword">new</span> Vehicle(), <span class="keyword">new</span> Amphibian(), <span class="string">"hi"</span>, <span class="number">47</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Tuple5&lt;Vehicle, Amphibian,</span><br><span class="line">            String, Integer, Double&gt; k() &#123;</span><br><span class="line">        <span class="keyword">return</span> tuple(<span class="keyword">new</span> Vehicle(), <span class="keyword">new</span> Amphibian(),</span><br><span class="line">                <span class="string">"hi"</span>, <span class="number">47</span>, <span class="number">11.1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Tuple2&lt;String, Integer&gt; ttsi = f();</span><br><span class="line">        System.out.println(ttsi);</span><br><span class="line">        System.out.println(f2());</span><br><span class="line">        System.out.println(g());</span><br><span class="line">        System.out.println(h());</span><br><span class="line">        System.out.println(k());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">(hi, 47)</span></span><br><span class="line"><span class="comment">(hi, 47)</span></span><br><span class="line"><span class="comment">(Amphibian@14ae5a5, hi, 47)</span></span><br><span class="line"><span class="comment">(Vehicle@135fbaa4, Amphibian@45ee12a7, hi, 47)</span></span><br><span class="line"><span class="comment">(Vehicle@4b67cf4d, Amphibian@7ea987ac, hi, 47, 11.1)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>请注意，<code>f()</code> 返回一个参数化的 <strong>Tuple2</strong> 对象，而 <code>f2()</code> 返回一个未参数化的 <strong>Tuple2</strong> 对象。编译器不会在这里警告 <code>f2()</code> ，因为返回值未以参数化方式使用。从某种意义上说，它被“向上转型”为一个未参数化的 <strong>Tuple2</strong> 。 但是，如果尝试将 <code>f2()</code> 的结果放入到参数化的 <strong>Tuple2</strong> 中，则编译器将发出警告。</p>
<!-- A Set Utility -->

<h3 id="一个-Set-工具"><a href="#一个-Set-工具" class="headerlink" title="一个 Set 工具"></a>一个 Set 工具</h3><p>对于泛型方法的另一个示例，请考虑由 <strong>Set</strong> 表示的数学关系。这些被方便地定义为可用于所有不同类型的泛型方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/Sets.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sets</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Set&lt;T&gt; <span class="title">union</span><span class="params">(Set&lt;T&gt; a, Set&lt;T&gt; b)</span> </span>&#123;</span><br><span class="line">        Set&lt;T&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;(a);</span><br><span class="line">        result.addAll(b);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;</span><br><span class="line">    <span class="function">Set&lt;T&gt; <span class="title">intersection</span><span class="params">(Set&lt;T&gt; a, Set&lt;T&gt; b)</span> </span>&#123;</span><br><span class="line">        Set&lt;T&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;(a);</span><br><span class="line">        result.retainAll(b);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Subtract subset from superset:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Set&lt;T&gt;</span><br><span class="line">    difference(Set&lt;T&gt; superset, Set&lt;T&gt; subset) &#123;</span><br><span class="line">        Set&lt;T&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;(superset);</span><br><span class="line">        result.removeAll(subset);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reflexive--everything not in the intersection:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Set&lt;T&gt; <span class="title">complement</span><span class="params">(Set&lt;T&gt; a, Set&lt;T&gt; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> difference(union(a, b), intersection(a, b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前三个方法通过将第一个参数的引用复制到新的 <strong>HashSet</strong> 对象中来复制第一个参数，因此不会直接修改参数集合。因此，返回值是一个新的 <strong>Set</strong> 对象。</p>
<p>这四种方法代表数学集合操作： <code>union()</code> 返回一个包含两个参数并集的 <strong>Set</strong> ， <code>intersection()</code> 返回一个包含两个参数集合交集的 <strong>Set</strong> ， <code>difference()</code> 从 <strong>superset</strong> 中减去 <strong>subset</strong> 的元素 ，而 <code>complement()</code> 返回所有不在交集中的元素的 <strong>Set</strong>。</p>
<!-- Building Complex Models -->

<h2 id="构建复杂模型"><a href="#构建复杂模型" class="headerlink" title="构建复杂模型"></a>构建复杂模型</h2><p>泛型的一个重要好处是能够简单安全地创建复杂模型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/TupleList.java</span></span><br><span class="line"><span class="comment">// Combining generic types to make complex generic types</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> onjava.Tuple4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TupleList</span>&lt;<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>, <span class="title">D</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">Tuple4</span>&lt;<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>, <span class="title">D</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TupleList&lt;Vehicle, Amphibian, String, Integer&gt; tl =</span><br><span class="line">                <span class="keyword">new</span> TupleList&lt;&gt;();</span><br><span class="line">        tl.add(TupleTest2.h());</span><br><span class="line">        tl.add(TupleTest2.h());</span><br><span class="line">        tl.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">(Vehicle@7cca494b, Amphibian@7ba4f24f, hi, 47)</span></span><br><span class="line"><span class="comment">(Vehicle@3b9a45b3, Amphibian@7699a589, hi, 47)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<!-- The Mystery of Erasure -->

<h2 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h2><p>当你开始更深入地钻研泛型时，会发现有大量的东西初看起来是没有意义的。例如，尽管可以说  <code>ArrayList.class</code>，但不能说成 <code>ArrayList&lt;Integer&gt;.class</code>。</p>
<p>考虑下面的情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ErasedTypeEquivalence.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErasedTypeEquivalence</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class c1 = <span class="keyword">new</span> ArrayList&lt;String&gt;().getClass();</span><br><span class="line">        Class c2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;().getClass();</span><br><span class="line">        System.out.println(c1 == c2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><code>ArrayList&lt;String&gt;</code> 和 <code>ArrayList&lt;Integer&gt;</code> 应该是不同的类型。不同的类型会有不同的行为。例如，如果尝试向 <code>ArrayList&lt;String&gt;</code> 中放入一个 <code>Integer</code>，所得到的行为（失败）和向 <code>ArrayList&lt;Integer&gt;</code> 中放入一个 <code>Integer</code> 所得到的行为（成功）完全不同。然而上面的程序认为它们是相同的类型。</p>
<p>下面的例子是对该谜题的补充：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/LostInformation.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Frob</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fnorkle</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quark</span>&lt;<span class="title">Q</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Particle</span>&lt;<span class="title">POSITION</span>, <span class="title">MOMENTUM</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LostInformation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Frob&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Map&lt;Frob, Fnorkle&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Quark&lt;Fnorkle&gt; quark = <span class="keyword">new</span> Quark&lt;&gt;();</span><br><span class="line">        Particle&lt;Long, Double&gt; p = <span class="keyword">new</span> Particle&lt;&gt;();</span><br><span class="line">        System.out.println(Arrays.toString(list.getClass().getTypeParameters()));</span><br><span class="line">        System.out.println(Arrays.toString(map.getClass().getTypeParameters()));</span><br><span class="line">        System.out.println(Arrays.toString(quark.getClass().getTypeParameters()));</span><br><span class="line">        System.out.println(Arrays.toString(p.getClass().getTypeParameters()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[E]</span></span><br><span class="line"><span class="comment">[K,V]</span></span><br><span class="line"><span class="comment">[Q]</span></span><br><span class="line"><span class="comment">[POSITION,MOMENTUM]</span></span><br></pre></td></tr></table></figure>

<p>根据 JDK 文档，<strong>Class.getTypeParameters()</strong> “返回一个 <strong>TypeVariable</strong> 对象数组，表示泛型声明中声明的类型参数…” 这暗示你可以发现这些参数类型。但是正如上例中输出所示，你只能看到用作参数占位符的标识符，这并非有用的信息。</p>
<p>残酷的现实是：</p>
<p><strong>在泛型代码内部，无法获取任何有关泛型参数类型的信息。</strong></p>
<p>因此，你可以知道如类型参数标识符和泛型边界这些信息，但无法得知实际的类型参数从而用来创建特定的实例。如果你曾是 C++ 程序员，那么这个事实会让你很沮丧，在使用 Java 泛型工作时，它是必须处理的最基本的问题。</p>
<p><strong>Java 泛型是使用擦除实现的。</strong>这意味着<strong>当你在使用泛型时，任何具体的类型信息都被擦除了，你唯一知道的就是你在使用一个对象</strong>。因此<strong>，<code>List&lt;String&gt;</code> 和 <code>List&lt;Integer&gt;</code> 在运行时实际上是相同的类型。它们都被擦除成原生类型 <code>List</code>。</strong></p>
<p>理解擦除并知道如何处理它，是你在学习 Java 泛型时面临的最大障碍之一。</p>
<h3 id="C-的方式"><a href="#C-的方式" class="headerlink" title="C++ 的方式"></a>C++ 的方式</h3><p>下面是使用模版的 C++ 示例。你会看到类型参数的语法十分相似，因为 Java 是受 C++ 启发的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Templates.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Manipulator</span> &#123;</span></span><br><span class="line">    T obj;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Manipulator(T x) &#123; obj = x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">manipulate</span><span class="params">()</span> </span>&#123; obj.f(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasF</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"HasF::f()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HasF hf;</span><br><span class="line">    Manipulator&lt;HasF&gt; manipulator(hf);</span><br><span class="line">    manipulator.manipulate();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">HasF::f()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>Manipulator</strong> 类存储了一个 <strong>T</strong> 类型的对象。<code>manipulate()</code> 方法会调用 <strong>obj</strong> 上的 <code>f()</code> 方法。它是如何知道类型参数 <strong>T</strong> 中存在 <code>f()</code> 方法的呢？<strong>C++ 编译器会在你实例化模版时进行检查</strong>，所以在 <code>Manipulator&lt;HasF&gt;</code> 实例化的那一刻，它看到 <strong>HasF</strong> 中含有一个方法 <code>f()</code>。如果情况并非如此，你就会得到<strong>一个编译期错误，保持类型安全。</strong></p>
<p>用 C++ 编写这种代码很简单，因为当模版被实例化时，模版代码就知道模版参数的类型。Java 泛型就不同了。下面是 <strong>HasF</strong> 的 Java 版本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/HasF.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HasF</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HasF.f()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们将示例的其余代码用 Java 实现，就不会通过编译：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Manipulation.java</span></span><br><span class="line"><span class="comment">// &#123;WillNotCompile&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manipulator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T obj;</span><br><span class="line">    </span><br><span class="line">    Manipulator(T x) &#123;</span><br><span class="line">        obj = x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Error: cannot find symbol: method f():</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">manipulate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        obj.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manipulation</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HasF hf = <span class="keyword">new</span> HasF();</span><br><span class="line">        Manipulator&lt;HasF&gt; manipulator = <span class="keyword">new</span> Manipulator&lt;&gt;(hf);</span><br><span class="line">        manipulator.manipulate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>因为擦除，Java 编译器无法将 <code>manipulate()</code> 方法必须能调用 obj 的 <code>f()</code> 方法这一需求映射到 HasF 具有 <code>f()</code> 方法这个事实上。</strong>为了调用 <code>f()</code>，我们<strong>必须协助泛型类，给定泛型类一个边界，以此告诉编译器只能接受遵循这个边界的类型。</strong>这里重用了 <strong>extends</strong> 关键字。由于有了边界，下面的代码就能通过编译：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manipulator2</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">HasF</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T obj;</span><br><span class="line"></span><br><span class="line">    Manipulator2(T x) &#123;</span><br><span class="line">        obj = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">manipulate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        obj.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>边界 <code>&lt;T extends HasF&gt;</code> 声明 T 必须是 HasF 类型或其子类。</strong>如果情况确实如此，就可以安全地在 <strong>obj</strong> 上调用 <code>f()</code> 方法。</p>
<p>我们说泛型类型参数会擦除到它的第一个边界（可能有多个边界，稍后你将看到）。我们还提到了类型参数的擦除。编译器实际上会把类型参数替换为它的擦除，就像上面的示例，<strong>T</strong> 擦除到了 <strong>HasF</strong>，就像在类的声明中用 <strong>HasF</strong> 替换了 <strong>T</strong> 一样。</p>
<p>你可能正确地观察到了泛型在 <strong>Manipulator2.java</strong> 中没有贡献任何事。你可以<strong>很轻松地自己去执行擦除，生成没有泛型的类</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Manipulator3.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manipulator3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HasF obj;</span><br><span class="line">    </span><br><span class="line">    Manipulator3(HasF x) &#123;</span><br><span class="line">        ojb = x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">manipulate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        obj.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这提出了很重要的一点：<strong>泛型只有在类型参数比某个具体类型（以及其子类）更加“泛化”——代码能跨多个类工作时才有用。</strong>因此，类型参数和它们在有用的泛型代码中的应用，通常比简单的类替换更加复杂。但是，不能因此认为使用 <code>&lt;T extends HasF&gt;</code> 形式就是有缺陷的。例如，如果<strong>某个类有一个返回 T 的方法</strong>，那么泛型就有所帮助，因为它们之后将返回确切的类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ReturnGenericType.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReturnGenericType</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">HasF</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T obj;</span><br><span class="line">    </span><br><span class="line">    ReturnGenericType(T x) &#123;</span><br><span class="line">        obj = x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你必须查看所有的代码，从而确定代码是否复杂到必须使用泛型的程度。</p>
<h3 id="迁移兼容性"><a href="#迁移兼容性" class="headerlink" title="迁移兼容性"></a>迁移兼容性</h3><p>为了减少潜在的关于擦除的困惑，你必须清楚地认识到<strong>这不是一个语言特性。</strong>它是 Java 实现泛型的一种妥协，因为泛型不是 Java 语言出现时就有的，所以就有了这种妥协。它会使你痛苦，因此你需要尽早习惯它并了解为什么它会这样。</p>
<p>如果 Java 1.0 就含有泛型的话，那么这个特性就不会使用擦除来实现——它会使用具体化，保持参数类型为第一类实体，因此你就能在类型参数上执行基于类型的语言操作和反射操作。本章稍后你会看到，<strong>擦除减少了泛型的泛化性。泛型在 Java 中仍然是有用的，只是不如它们本来设想的那么有用，而原因就是擦除。</strong></p>
<p>在基于擦除的实现中，泛型类型被当作第二类类型处理，即不能在某些重要的上下文使用泛型类型。泛型类型只有在静态类型检测期间才出现，在此之后，<strong>程序中的所有泛型类型都将被擦除，替换为它们的非泛型上界</strong>。例如， <code>List&lt;T&gt;</code> 这样的类型注解会被擦除为 <strong>List</strong>，普通的类型变量在未指定边界的情况下会被擦除为 <strong>Object</strong>。</p>
<p>擦除的核心动机是你可以在泛化的客户端上使用非泛型的类库，反之亦然。这经常被称为“迁移兼容性”。在理想情况下，所有事物将在指定的某天被泛化。在现实中，即使程序员只编写泛型代码，他们也必须处理 Java 5 之前编写的非泛型类库。这些类库的作者可能从没想过要泛化他们的代码，或许他们可能刚刚开始接触泛型。</p>
<p>因此 Java 泛型不仅必须支持向后兼容性——现有的代码和类文件仍然合法，继续保持之前的含义——而且还必须支持迁移兼容性，使得类库能按照它们自己的步调变为泛型，当某个类库变为泛型时，不会破坏依赖于它的代码和应用。在确定了这个目标后，<strong>Java 设计者们和从事此问题相关工作的各个团队决策认为擦除是唯一可行的解决方案。</strong>擦除使得这种向泛型的迁移成为可能，允许非泛型的代码和泛型代码共存。</p>
<p>例如，假设一个应用使用了两个类库 <strong>X</strong> 和 <strong>Y</strong>，<strong>Y</strong> 使用了类库 <strong>Z</strong>。随着 Java 5 的出现，这个应用和这些类库的创建者最终可能希望迁移到泛型上。但是当进行迁移时，它们有着不同的动机和限制。为了实现迁移兼容性，每个类库与应用必须与其他所有的部分是否使用泛型无关。因此，它们不能探测其他类库是否使用了泛型。因此，某个特定的类库使用了泛型这样的证据必须被”擦除“。</p>
<p>如果没有某种类型的迁移途径，所有已经构建了很长时间的类库就需要与希望迁移到 Java 泛型上的开发者们说再见了。类库毫无争议是编程语言的一部分，对生产效率有着极大的影响，所以这种代码无法接受。擦除是否是最佳的活唯一的迁移途径，还待时间来证明。</p>
<h3 id="擦除的问题"><a href="#擦除的问题" class="headerlink" title="擦除的问题"></a>擦除的问题</h3><p>因此，擦除主要的正当理由是从非泛化代码到泛化代码的转变过程，以及在不破坏现有类库的情况下将泛型融入到语言中。擦除允许你继续使用现有的非泛型客户端代码，直至客户端准备好用泛型重写这些代码。这是一个崇高的动机，因为它不会骤然破坏所有现有的代码。</p>
<p>擦除的代码是显著的。泛型不能用于显式地引用运行时类型的操作中，例如转型、<strong>instanceof</strong> 操作和 <strong>new</strong> 表达式。因为所有关于参数的类型信息都丢失了，当你在编写泛型代码时，必须时刻提醒自己，<strong>你只是看起来拥有有关参数的类型信息而已。</strong></p>
<p>考虑如下的代码段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T <span class="keyword">var</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看上去当你创建一个 <strong>Foo</strong> 实例时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Foo&lt;Cat&gt; f = <span class="keyword">new</span> Foo&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p><strong>class</strong> <strong>Foo</strong> 中的代码应该知道现在工作于 <strong>Cat</strong> 之上。泛型语法也在强烈暗示整个类中所有 T 出现的地方都被替换，就像在 C++ 中一样。但是事实并非如此，当你在编写这个类的代码时，必须提醒自己：“不，这只是一个 <strong>Object</strong>“。</p>
<p>另外，擦除和迁移兼容性意味着，使用泛型并不是强制的，尽管你可能希望这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ErasureAndInheritance.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericBase</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T element;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T arg)</span> </span>&#123;</span><br><span class="line">        element = arg;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived1</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">GenericBase</span>&lt;<span class="title">T</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived2</span> <span class="keyword">extends</span> <span class="title">GenericBase</span> </span>&#123;&#125; <span class="comment">// No warning</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// class Derived3 extends GenericBase&lt;?&gt; &#123;&#125;</span></span><br><span class="line"><span class="comment">// Strange error:</span></span><br><span class="line"><span class="comment">// unexpected type</span></span><br><span class="line"><span class="comment">// required: class or interface without bounds</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErasureAndInteritance</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Derived2 d2 = <span class="keyword">new</span> Derived2();</span><br><span class="line">        Object obj = d2.get();</span><br><span class="line">        d2.set(obj); <span class="comment">// Warning here!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Derived2</strong> 继承自 <strong>GenericBase</strong>，但是没有任何类型参数，编译器没有发出任何警告。直到调用 <code>set()</code> 方法时才出现警告。</p>
<p>为了关闭警告，Java 提供了一个注解，我们可以在列表中看到它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br></pre></td></tr></table></figure>

<p><strong>这个注解放置在产生警告的方法上</strong>，而不是整个类上。当你要关闭警告时，<strong>最好尽可能地“聚焦”，这样就不会因为过于宽泛地关闭警告，</strong>而导致意外地遮蔽掉真正的问题。</p>
<p>可以推断，<strong>Derived3</strong> 产生的错误意味着编译器期望得到一个原生基类。</p>
<p>当你希望将类型参数不仅仅当作 Object 处理时，就需要付出额外努力来管理边界，并且与在 C++、Ada 和 Eiffel 这样的语言中获得参数化类型相比，你需要付出多得多的努力来获得少得多的回报。这并不是说，对于大多数的编程问题而言，这些语言通常都会比 Java 更得心应手，只是说它们的参数化类型机制相比 Java 更灵活、更强大。</p>
<h3 id="边界处的动作"><a href="#边界处的动作" class="headerlink" title="边界处的动作"></a>边界处的动作</h3><p>因为擦除，我发现了泛型最令人困惑的方面是可以表示没有任何意义的事物。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ArrayMaker.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayMaker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; kind;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayMaker</span><span class="params">(Class&lt;T&gt; kind)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.kind = kind;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    T[] create(<span class="keyword">int</span> size) &#123;</span><br><span class="line">        <span class="keyword">return</span> (T[]) Array.newInstance(kind, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayMaker&lt;String&gt; stringMaker = <span class="keyword">new</span> ArrayMaker&lt;&gt;(String.class);</span><br><span class="line">        String[] stringArray = stringMaker.create(<span class="number">9</span>);</span><br><span class="line">        System.out.println(Arrays.toString(stringArray));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output</span></span><br><span class="line"><span class="comment">[null,null,null,null,null,null,null,null,null]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>即使 <strong>kind</strong> 被存储为 <code>Class&lt;T&gt;</code>，擦除也意味着它实际被存储为没有任何参数的 <strong>Class</strong>。因此，当你在使用它时，例如创建数组，<code>Array.newInstance()</code> 实际上并未拥有 <strong>kind</strong> 所蕴含的类型信息。所以它不会产生具体的结果，因而必须转型，这会产生一条令你无法满意的警告。</p>
<p>注意，<strong>对于在泛型中创建数组，使用 <code>Array.newInstance()</code> 是推荐的方式。</strong></p>
<p>如果我们创建一个集合而不是数组，情况就不同了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ListMaker.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListMaker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ListMaker&lt;String&gt; stringMaker = <span class="keyword">new</span> ListMaker&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; stringList = stringMaker.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器不会给出任何警告，尽管我们知道（从擦除中）在 <code>create()</code> 内部的 <code>new ArrayList&lt;&gt;()</code> 中的 <code>&lt;T&gt;</code> 被移除了——在运行时，类内部没有任何 <code>&lt;T&gt;</code>，因此这看起来毫无意义。但是如果你遵从这种思路，并将这个表达式改为 <code>new ArrayList()</code>，编译器就会发出警告。</p>
<p>本例中这么做真的毫无意义吗？如果在创建 <strong>List</strong> 的同时向其中放入一些对象呢，像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/FilledList.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilledList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    FilledList&lt;Supplier&lt;T&gt; gen, <span class="keyword">int</span> size) &#123;</span><br><span class="line">        Suppliers.fill(<span class="keyword">this</span>, gen, size);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FilledList</span><span class="params">(T t, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> FilledList&lt;&gt;(<span class="string">"Hello"</span>, <span class="number">4</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">// Supplier version:</span></span><br><span class="line">        List&lt;Integer&gt; ilist = <span class="keyword">new</span> FilledList&lt;&gt;(() -&gt; <span class="number">47</span>, <span class="number">4</span>);</span><br><span class="line">        System.out.println(ilist);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[Hello,Hello,Hello,Hello]</span></span><br><span class="line"><span class="comment">[47,47,47,47]</span></span><br></pre></td></tr></table></figure>

<p>即使编译器无法得知 <code>add()</code> 中的 <strong>T</strong> 的任何信息，但它仍可以在编译期确保你放入 <strong>FilledList</strong> 中的对象是 <strong>T</strong> 类型。因此，<strong>即使擦除移除了方法或类中的实际类型的信息，编译器仍可以确保方法或类中使用的类型的内部一致性。</strong></p>
<p>因为擦除移除了方法体中的类型信息，所以在运行时的问题就是<em>边界</em>：即对象进入和离开方法的地点。这些正是编译器在编译期执行类型检查并插入转型代码的地点。</p>
<p>考虑如下这段非泛型示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/SimpleHolder.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleHolder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SimpleHolder holder = <span class="keyword">new</span> SimpleHolder();</span><br><span class="line">        holder.set(<span class="string">"Item"</span>);</span><br><span class="line">        String s = (String) holder.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果用 <strong>javap -c SimpleHolder</strong> 反编译这个类，会得到如下内容（经过编辑）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(java.lang.Object)</span></span>;</span><br><span class="line">   <span class="number">0</span>: aload_0</span><br><span class="line">   <span class="number">1</span>: aload_1</span><br><span class="line">   2: putfield #2; // Field obj:Object;</span><br><span class="line">   <span class="number">5</span>: <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> java.lang.<span class="function">Object <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="number">0</span>: aload_0</span><br><span class="line">   1: getfield #2; // Field obj:Object;</span><br><span class="line">   <span class="number">4</span>: areturn</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">   0: new #3; // class SimpleHolder</span><br><span class="line">   <span class="number">3</span>: dup</span><br><span class="line">   4: invokespecial #4; // Method "&lt;init&gt;":()V</span><br><span class="line">   <span class="number">7</span>: astore_1</span><br><span class="line">   <span class="number">8</span>: aload_1</span><br><span class="line">   9: ldc #5; // String Item</span><br><span class="line">   11: invokevirtual #6; // Method set:(Object;)V</span><br><span class="line">   <span class="number">14</span>: aload_1</span><br><span class="line">   15: invokevirtual #7; // Method get:()Object;</span><br><span class="line">   18: checkcast #8; // class java/lang/String</span><br><span class="line">   <span class="number">21</span>: astore_2</span><br><span class="line">   <span class="number">22</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p><code>set()</code> 和 <code>get()</code> 方法存储和产生值，转型在调用 <code>get()</code> 时接受检查。</p>
<p>现在将泛型融入上例代码中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/GenericHolder2.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericHolder2</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T obj;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericHolder2&lt;String&gt; holder =  <span class="keyword">new</span> GenericHolder2&lt;&gt;();</span><br><span class="line">        holder.set(<span class="string">"Item"</span>);</span><br><span class="line">        String s = holder.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 <code>get()</code> 返回后的转型消失了，但是我们还知道传递给 <code>set()</code> 的值在编译期会被检查。下面是相关的字节码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(java.lang.Object)</span></span>;</span><br><span class="line">   <span class="number">0</span>: aload_0</span><br><span class="line">   <span class="number">1</span>: aload_1</span><br><span class="line">   2: putfield #2; // Field obj:Object;</span><br><span class="line">   <span class="number">5</span>: <span class="keyword">return</span></span><br><span class="line">       </span><br><span class="line"><span class="keyword">public</span> java.lang.<span class="function">Object <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="number">0</span>: aload_0</span><br><span class="line">   1: getfield #2; // Field obj:Object;</span><br><span class="line">   <span class="number">4</span>: areturn</span><br><span class="line">       </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">   0: new #3; // class GenericHolder2</span><br><span class="line">   <span class="number">3</span>: dup</span><br><span class="line">   4: invokespecial #4; // Method "&lt;init&gt;":()V</span><br><span class="line">   <span class="number">7</span>: astore_1</span><br><span class="line">   <span class="number">8</span>: aload_1</span><br><span class="line">   9: ldc #5; // String Item</span><br><span class="line">   11: invokevirtual #6; // Method set:(Object;)V</span><br><span class="line">   <span class="number">14</span>: aload_1</span><br><span class="line">   15: invokevirtual #7; // Method get:()Object;</span><br><span class="line">   18: checkcast #8; // class java/lang/String</span><br><span class="line">   <span class="number">21</span>: astore_2</span><br><span class="line">   <span class="number">22</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>所产生的字节码是相同的。<strong>对进入 <code>set()</code> 的类型进行检查是不需要的，因为这将由编译器执行。而对 <code>get()</code> 返回的值进行转型仍然是需要的，只不过不需要你来操作，它由编译器自动插入，这样你就不用编写（阅读）杂乱的代码。</strong></p>
<p><code>get()</code> 和 <code>set()</code> 产生了相同的字节码，这就告诉我们<strong>泛型的所有动作都发生在边界处——对入参的编译器检查和对返回值的转型。</strong>这有助于澄清对擦除的困惑，记住：<strong>“边界就是动作发生的地方”。</strong></p>
<!-- Compensating for Erasure -->

<h2 id="补偿擦除"><a href="#补偿擦除" class="headerlink" title="补偿擦除"></a>补偿擦除</h2><p>因为擦除，我们将失去执行泛型代码中某些操作的能力。<strong>无法在运行时知道确切类型</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Erased.java</span></span><br><span class="line"><span class="comment">// &#123;WillNotCompile&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Erased</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Object arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// error: illegal generic type for instanceof</span></span><br><span class="line">        <span class="keyword">if</span> (arg <span class="keyword">instanceof</span> T) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// error: unexpected type</span></span><br><span class="line">        T <span class="keyword">var</span> = <span class="keyword">new</span> T();</span><br><span class="line">        <span class="comment">// error: generic array creation</span></span><br><span class="line">        T[] array = <span class="keyword">new</span> T[SIZE];</span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked cast</span></span><br><span class="line">        T[] array = (T[]) <span class="keyword">new</span> Object[SIZE];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有时，我们可以对这些问题进行编程，但是有时必须通过引入类型标签来补偿擦除。这意味着为所需的类型显式传递一个 <strong>Class</strong> 对象，以在类型表达式中使用它。</p>
<p>例如，由于擦除了类型信息，因此在上一个程序中尝试使用 <strong>instanceof</strong> 将会失败。类型标签可以使用动态 <code>isInstance()</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ClassTypeCapture.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">House</span> <span class="keyword">extends</span> <span class="title">Building</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassTypeCapture</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    Class&lt;T&gt; kind;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassTypeCapture</span><span class="params">(Class&lt;T&gt; kind)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.kind = kind;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">f</span><span class="params">(Object arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> kind.isInstance(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassTypeCapture&lt;Building&gt; ctt1 =</span><br><span class="line">                <span class="keyword">new</span> ClassTypeCapture&lt;&gt;(Building.class);</span><br><span class="line">        System.out.println(ctt1.f(<span class="keyword">new</span> Building()));</span><br><span class="line">        System.out.println(ctt1.f(<span class="keyword">new</span> House()));</span><br><span class="line">        ClassTypeCapture&lt;House&gt; ctt2 =</span><br><span class="line">                <span class="keyword">new</span> ClassTypeCapture&lt;&gt;(House.class);</span><br><span class="line">        System.out.println(ctt2.f(<span class="keyword">new</span> Building()));</span><br><span class="line">        System.out.println(ctt2.f(<span class="keyword">new</span> House()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">false</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>编译器来保证类型标签与泛型参数相匹配。</strong></p>
<!-- Creating Instances of Types -->

<h3 id="创建类型的实例"><a href="#创建类型的实例" class="headerlink" title="创建类型的实例"></a>创建类型的实例</h3><p>试图在 <strong>Erased.java</strong> 中 <code>new T()</code> 是行不通的，部分原因是由于擦除，部分原因是编译器无法验证 <strong>T</strong> 是否具有默认（无参）构造函数。但是在 C++ 中，此操作自然，直接且安全（在编译时检查）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/InstantiateGenericType.cpp</span></span><br><span class="line"><span class="comment">// C++, not Java!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">  T x; <span class="comment">// Create a field of type T</span></span><br><span class="line">  T* y; <span class="comment">// Pointer to T</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Initialize the pointer:</span></span><br><span class="line">  Foo() &#123; y = <span class="keyword">new</span> T(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Foo&lt;Bar&gt; fb;</span><br><span class="line">  Foo&lt;<span class="keyword">int</span>&gt; fi; <span class="comment">// ... and it works with primitives</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java 中的解决方案是传入一个工厂对象，并使用该对象创建新实例。方便的工厂对象只是 <strong>Class</strong> 对象，因此，如果使用类型标记，则可以使用 <code>newInstance()</code> 创建该类型的新对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/InstantiateGenericType.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassAsFactory</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    Class&lt;T&gt; kind;</span><br><span class="line"></span><br><span class="line">    ClassAsFactory(Class&lt;T&gt; kind) &#123;</span><br><span class="line">        <span class="keyword">this</span>.kind = kind;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> kind.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException |</span><br><span class="line">                IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Employee"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstantiateGenericType</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassAsFactory&lt;Employee&gt; fe =</span><br><span class="line">                <span class="keyword">new</span> ClassAsFactory&lt;&gt;(Employee.class);</span><br><span class="line">        System.out.println(fe.get());</span><br><span class="line">        ClassAsFactory&lt;Integer&gt; fi =</span><br><span class="line">                <span class="keyword">new</span> ClassAsFactory&lt;&gt;(Integer.class);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(fi.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Employee</span></span><br><span class="line"><span class="comment">java.lang.InstantiationException: java.lang.Integer</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>这样可以编译，但对于 <code>ClassAsFactory&lt;Integer&gt;</code> 会失败，这是因为 <strong>Integer</strong> 没有无参构造函数。由于错误不是在编译时捕获的，因此语言创建者不赞成这种方法。他们建议使用显式工厂（<strong>Supplier</strong>）并约束类型，以便只有实现该工厂的类可以这样创建对象。这是创建工厂的两种不同方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/FactoryConstraint.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> onjava.Suppliers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntegerFactory</span> <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ++i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    Widget(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        id = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Widget "</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">Widget</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Widget <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Widget(++i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fudge</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n = count++;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Fudge "</span> + n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo2</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; x = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    Foo2(Supplier&lt;T&gt; factory) &#123;</span><br><span class="line">        Suppliers.fill(x, factory, <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryConstraint</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(</span><br><span class="line">                <span class="keyword">new</span> Foo2&lt;&gt;(<span class="keyword">new</span> IntegerFactory()));</span><br><span class="line">        System.out.println(</span><br><span class="line">                <span class="keyword">new</span> Foo2&lt;&gt;(<span class="keyword">new</span> Widget.Factory()));</span><br><span class="line">        System.out.println(</span><br><span class="line">                <span class="keyword">new</span> Foo2&lt;&gt;(Fudge::<span class="keyword">new</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="comment">[Widget 1, Widget 2, Widget 3, Widget 4, Widget 5]</span></span><br><span class="line"><span class="comment">[Fudge 1, Fudge 2, Fudge 3, Fudge 4, Fudge 5]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>IntegerFactory</strong> 本身就是通过实现 <code>Supplier&lt;Integer&gt;</code> 的工厂。 <strong>Widget</strong> 包含一个内部类，它是一个工厂。还要注意，<strong>Fudge</strong> 并没有做任何类似于工厂的操作，并且传递 <code>Fudge::new</code> 仍然会产生工厂行为，因为编译器将对函数方法 <code>::new</code> 的调用转换为对 <code>get()</code> 的调用。</p>
<p>另一种方法是<strong>模板方法设计模式</strong>。在以下示例中，<code>create()</code> 是模板方法，在子类中被重写以生成该类型的对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/CreatorGeneric.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericWithCreate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> T element;</span><br><span class="line"></span><br><span class="line">    GenericWithCreate() &#123;</span><br><span class="line">        element = create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> T <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XCreator</span> <span class="keyword">extends</span> <span class="title">GenericWithCreate</span>&lt;<span class="title">X</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">X <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> X();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(</span><br><span class="line">                element.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreatorGeneric</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        XCreator xc = <span class="keyword">new</span> XCreator();</span><br><span class="line">        xc.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">X</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>GenericWithCreate</strong> 包含 <code>element</code> 字段，并通过无参构造函数强制其初始化，该构造函数又调用抽象的 <code>create()</code> 方法。这种创建方式可以在子类中定义，同时建立 <strong>T</strong> 的类型。</p>
<!-- Arrays of Generics -->

<h3 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h3><p>正如在 <strong>Erased.java</strong> 中所看到的，我们无法创建泛型数组。通用解决方案是在试图创建泛型数组的时候使用 <strong>ArrayList</strong> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ListOfGenerics.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListOfGenerics</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; array = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T item)</span> </span>&#123;</span><br><span class="line">        array.add(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样做可以获得数组的行为，并且还具有泛型提供的编译时类型安全性。</p>
<p>有时，仍然会创建泛型类型的数组（例如， <strong>ArrayList</strong> 在内部使用数组）。可以通过使编译器满意的方式定义对数组的通用引用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ArrayOfGenericReference.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayOfGenericReference</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Generic&lt;Integer&gt;[] gia;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器接受此操作而不产生警告。但是我们永远无法创建具有该确切类型（包括类型参数）的数组，因此有点令人困惑。由于所有数组，无论它们持有什么类型，都具有相同的结构（每个数组插槽的大小和数组布局），因此似乎可以创建一个 <strong>Object</strong> 数组并将其转换为所需的数组类型。实际上，这确实可以编译，但是会产生 <strong>ClassCastException</strong> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ArrayOfGeneric.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayOfGeneric</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">static</span> Generic&lt;Integer&gt;[] gia;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            gia = (Generic&lt;Integer&gt;[]) <span class="keyword">new</span> Object[SIZE];</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassCastException e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Runtime type is the raw (erased) type:</span></span><br><span class="line">        gia = (Generic&lt;Integer&gt;[]) <span class="keyword">new</span> Generic[SIZE];</span><br><span class="line">        System.out.println(gia.getClass().getSimpleName());</span><br><span class="line">        gia[<span class="number">0</span>] = <span class="keyword">new</span> Generic&lt;&gt;();</span><br><span class="line">        <span class="comment">//- gia[1] = new Object(); // Compile-time error</span></span><br><span class="line">        <span class="comment">// Discovers type mismatch at compile time:</span></span><br><span class="line">        <span class="comment">//- gia[2] = new Generic&lt;Double&gt;();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[Ljava.lang.Object; cannot be cast to [LGeneric;</span></span><br><span class="line"><span class="comment">Generic[]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>问题在于数组会跟踪其实际类型，而该类型是在创建数组时建立的。因此，即使 <code>gia</code> 被强制转换为 <code>Generic&lt;Integer&gt;[]</code> ，该信息也仅在编译时存在（并且没有 <strong>@SuppressWarnings</strong> 注解，将会收到有关该强制转换的警告）。在运行时，它仍然是一个 <strong>Object</strong> 数组，这会引起问题。成功创建泛型类型的数组的唯一方法是创建一个已擦除类型的新数组，并将其强制转换。</p>
<p>让我们看一个更复杂的示例。考虑一个包装数组的简单泛型包装器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/GenericArray.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericArray</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericArray</span><span class="params">(<span class="keyword">int</span> sz)</span> </span>&#123;</span><br><span class="line">        array = (T[]) <span class="keyword">new</span> Object[sz];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> index, T item)</span> </span>&#123;</span><br><span class="line">        array[index] = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Method that exposes the underlying representation:</span></span><br><span class="line">    <span class="keyword">public</span> T[] rep() &#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericArray&lt;Integer&gt; gai = <span class="keyword">new</span> GenericArray&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Integer[] ia = gai.rep();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassCastException e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// This is OK:</span></span><br><span class="line">        Object[] oa = gai.rep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[Ljava.lang.Object; cannot be cast to</span></span><br><span class="line"><span class="comment">[Ljava.lang.Integer;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>和以前一样，我们不能说 <code>T[] array = new T[sz]</code> ，所以我们创建了一个 <strong>Object</strong> 数组并将其强制转换。</p>
<p><code>rep()</code> 方法返回一个 <code>T[]</code> ，在主方法中它应该是 <code>gai</code> 的 <code>Integer[]</code>，但是如果调用它并尝试将结果转换为 <code>Integer[]</code> 引用，则会得到 <strong>ClassCastException</strong> ，这再次是因为实际的运行时类型为 <code>Object[]</code> 。</p>
<p>如果再注释掉 <strong>@SuppressWarnings</strong> 注解后编译 <strong>GenericArray.java</strong> ，则编译器会产生警告：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GenericArray.java uses unchecked or unsafe operations.</span><br><span class="line">Recompile with -Xlint:unchecked <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure>

<p>在这里，我们收到了一个警告，我们认为这是有关强制转换的。</p>
<p>但是要真正确定，请使用 <code>-Xlint：unchecked</code> 进行编译：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GenericArray.java:<span class="number">7</span>: warning: [unchecked] unchecked cast    array = (T[])<span class="keyword">new</span> Object[sz];                 ^  required: T[]  found:    Object[]  where T is a type-variable:    T extends Object declared in <span class="class"><span class="keyword">class</span> <span class="title">GenericArray</span> 1 <span class="title">warning</span></span></span><br></pre></td></tr></table></figure>

<p>确实是在抱怨那个强制转换。由于警告会变成噪音，因此，一旦我们确认预期会出现特定警告，我们可以做的最好的办法就是使用 <strong>@SuppressWarnings</strong> 将其关闭。这样，当警告确实出现时，我们将进行实际调查。</p>
<p><strong>由于擦除，数组的运行时类型只能是 <code>Object[]</code> 。</strong> 如果我们立即将其转换为 <code>T[]</code> ，则在编译时会丢失数组的实际类型，并且编译器可能会错过一些潜在的错误检查。因此，<strong>最好在集合中使用 <code>Object[]</code> ，并在使用数组元素时向 T 添加强制类型转换。</strong>让我们来看看在 <strong>GenericArray.java</strong> 示例中会是怎么样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/GenericArray2.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericArray2</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] array;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericArray2</span><span class="params">(<span class="keyword">int</span> sz)</span> </span>&#123;</span><br><span class="line">        array = <span class="keyword">new</span> Object[sz];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> index, T item)</span> </span>&#123;</span><br><span class="line">        array[index] = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) array[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> T[] rep() &#123;</span><br><span class="line">        <span class="keyword">return</span> (T[]) array; <span class="comment">// Unchecked cast</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericArray2&lt;Integer&gt; gai =</span><br><span class="line">                <span class="keyword">new</span> GenericArray2&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">            gai.put(i, i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">            System.out.print(gai.get(i) + <span class="string">" "</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Integer[] ia = gai.rep();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line"><span class="comment">java.lang.ClassCastException: [Ljava.lang.Object;</span></span><br><span class="line"><span class="comment">cannot be cast to [Ljava.lang.Integer;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>最初，看起来并没有太大不同，只是转换的位置移动了。没有 <strong>@SuppressWarnings</strong> 注解，仍然会收到“unchecked”警告。但是，内部表示现在是 <code>Object[]</code> 而不是 <code>T[]</code> 。 调用 <code>get()</code> 时，它将对象强制转换为 <strong>T</strong> ，实际上这是正确的类型，因此很安全。但是，如果调用 <code>rep()</code> ，它将<strong>再次尝试将 <code>Object[]</code> 强制转换为 <code>T[]</code> ，但仍然不正确，并在编译时生成警告，并在运行时生成异常。</strong>因此，无法破坏基础数组的类型，该基础数组只能是 <code>Object[]</code> 。<strong>在内部将数组视为 <code>Object[]</code> 而不是 <code>T[]</code> 的优点是，我们不太可能会忘记数组的运行时类型并意外地引入了bug</strong>，尽管大多数（也许是全部）此类错误会在运行时被迅速检测到。</p>
<p>对于新代码，请传入类型标记。在这种情况下，<strong>GenericArray</strong> 如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/GenericArrayWithTypeToken.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericArrayWithTypeToken</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericArrayWithTypeToken</span><span class="params">(Class&lt;T&gt; type, <span class="keyword">int</span> sz)</span> </span>&#123;</span><br><span class="line">        array = (T[]) Array.newInstance(type, sz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> index, T item)</span> </span>&#123;</span><br><span class="line">        array[index] = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Expose the underlying representation:</span></span><br><span class="line">    <span class="keyword">public</span> T[] rep() &#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericArrayWithTypeToken&lt;Integer&gt; gai =</span><br><span class="line">                <span class="keyword">new</span> GenericArrayWithTypeToken&lt;&gt;(</span><br><span class="line">                        Integer.class, <span class="number">10</span>);</span><br><span class="line">        <span class="comment">// This now works:</span></span><br><span class="line">        Integer[] ia = gai.rep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类型标记 <strong>Class&lt;T&gt;</strong> 被传递到构造函数中以从擦除中恢复，因此尽管必须使用 <strong>@SuppressWarnings</strong> 关闭来自强制类型转换的警告，但我们仍可以创建所需的实际数组类型。一旦获得了实际的类型，就可以返回它并产生所需的结果，如在主方法中看到的那样。<strong>数组的运行时类型是确切的类型 <code>T[]</code> 。</strong></p>
<p>不幸的是，如果查看 <strong>Java 标准库中的源代码，你会发现到处都有从 Object 数组到参数化类型的转换。</strong>例如，这是<strong>ArrayList</strong> 中，复制一个 <strong>Collection</strong> 的构造函数，这里为了简化，去除了源码中对此不重要的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection c)</span> </span>&#123;</span><br><span class="line">  size = c.size();</span><br><span class="line">  elementData = (E[])<span class="keyword">new</span> Object[size];</span><br><span class="line">  c.toArray(elementData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你浏览 <strong>ArrayList.java</strong> 的代码，将会发现很多此类强制转换。当我们编译它时会发生什么？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Note: ArrayList.java uses unchecked or unsafe operations</span><br><span class="line">Note: Recompile with -Xlint:unchecked <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure>

<p>果然，标准库会产生很多警告。如果你使用过 C 语言，尤其是使用 ANSI C 之前的语言，你会记住警告的特殊效果：发现警告后，可以忽略它们。因此，除非程序员必须对其进行处理，否则最好不要从编译器发出任何类型的消息。</p>
<p>Neal Gafter（Java 5 的主要开发人员之一）在他的博客中[^2]指出，他在重写 Java 库时是很随意、马虎的，我们不应该像他那样做。Neal 还指出，<strong>他在不破坏现有接口的情况下无法修复某些 Java 库代码。因此，即使在 Java 库源代码中出现了一些习惯用法，它们也不一定是正确的做法。当查看库代码时，我们不能认为这就是要在自己代码中必须遵循的示例。</strong></p>
<p>请注意，在 Java 文献中推荐使用类型标记技术，例如 Gilad Bracha 的论文《Generics in the Java Programming Language》[^3]，他指出：“例如，这种用法已广泛用于新的 API 中以处理注解。” 我发现此技术在人们对于舒适度的看法方面存在一些不一致之处；有些人强烈喜欢本章前面介绍的工厂方法。</p>
<!-- Bounds -->

<h2 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h2><p><em>边界</em>（bounds）在本章的前面进行了简要介绍。边界允许我们对泛型使用的参数类型施加约束。尽管这可以强制执行有关应用了泛型类型的规则，但潜在的更重要的效果是我们可以在绑定的类型中调用方法。</p>
<p>由于擦除会删除类型信息，因此唯一可用于无限制泛型参数的方法是那些 <strong>Object</strong> 可用的方法。但是，如果将该参数限制为某类型的子集，则可以调用该子集中的方法。为了<strong>应用约束，Java 泛型使用了 <code>extends</code> 关键字。</strong></p>
<p>重要的是要理解，当用于限定泛型类型时，<code>extends</code> 的含义与通常的意义截然不同。此示例展示边界的基础应用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/BasicBounds.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">HasColor</span> </span>&#123;</span><br><span class="line">    java.awt.<span class="function">Color <span class="title">getColor</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WithColor</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">HasColor</span>&gt; </span>&#123;</span><br><span class="line">    T item;</span><br><span class="line"></span><br><span class="line">    WithColor(T item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">getItem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The bound allows you to call a method:</span></span><br><span class="line">    java.awt.<span class="function">Color <span class="title">color</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.getColor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coord</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> x, y, z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This fails. Class must be first, then interfaces:</span></span><br><span class="line"><span class="comment">// class WithColorCoord&lt;T extends HasColor &amp; Coord&gt; &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Multiple bounds:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WithColorCoord</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Coord</span> &amp; <span class="title">HasColor</span>&gt; </span>&#123;</span><br><span class="line">    T item;</span><br><span class="line"></span><br><span class="line">    WithColorCoord(T item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">getItem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    java.awt.<span class="function">Color <span class="title">color</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.getColor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getZ</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Weight</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">weight</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// As with inheritance, you can have only one</span></span><br><span class="line"><span class="comment">// concrete class but multiple interfaces:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solid</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Coord</span> &amp; <span class="title">HasColor</span> &amp; <span class="title">Weight</span>&gt; </span>&#123;</span><br><span class="line">    T item;</span><br><span class="line"></span><br><span class="line">    Solid(T item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">getItem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    java.awt.<span class="function">Color <span class="title">color</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.getColor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getZ</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">weight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.weight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bounded</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">Coord</span> <span class="keyword">implements</span> <span class="title">HasColor</span>, <span class="title">Weight</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> java.awt.<span class="function">Color <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">weight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicBounds</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solid&lt;Bounded&gt; solid =</span><br><span class="line">                <span class="keyword">new</span> Solid&lt;&gt;(<span class="keyword">new</span> Bounded());</span><br><span class="line">        solid.color();</span><br><span class="line">        solid.getY();</span><br><span class="line">        solid.weight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可能会观察到 <strong>BasicBounds.java</strong> 中似乎包含一些冗余，它们可以通过继承来消除。在这里，每个继承级别还添加了边界约束：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/InheritBounds.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HoldItem</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T item;</span><br><span class="line"></span><br><span class="line">    HoldItem(T item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">getItem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WithColor2</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">HasColor</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">HoldItem</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    WithColor2(T item) &#123;</span><br><span class="line">        <span class="keyword">super</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    java.awt.<span class="function">Color <span class="title">color</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.getColor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WithColorCoord2</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Coord</span> &amp; <span class="title">HasColor</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">WithColor2</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    WithColorCoord2(T item) &#123;</span><br><span class="line">        <span class="keyword">super</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getZ</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solid2</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Coord</span> &amp; <span class="title">HasColor</span> &amp; <span class="title">Weight</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">WithColorCoord2</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    Solid2(T item) &#123;</span><br><span class="line">        <span class="keyword">super</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">weight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.weight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritBounds</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solid2&lt;Bounded&gt; solid2 =</span><br><span class="line">                <span class="keyword">new</span> Solid2&lt;&gt;(<span class="keyword">new</span> Bounded());</span><br><span class="line">        solid2.color();</span><br><span class="line">        solid2.getY();</span><br><span class="line">        solid2.weight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>HoldItem</strong> 拥有一个对象，因此此行为将继承到 <strong>WithColor2</strong> 中，这也需要其参数符合 <strong>HasColor</strong>。 <strong>WithColorCoord2</strong> 和 <strong>Solid2</strong> 进一步扩展了层次结构，并在每个级别添加了边界。现在，这些方法已被继承，并且在每个类中不再重复。</p>
<p>这是一个具有更多层次的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/EpicBattle.java</span></span><br><span class="line"><span class="comment">// Bounds in Java generics</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SuperPower</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">XRayVision</span> <span class="keyword">extends</span> <span class="title">SuperPower</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">seeThroughWalls</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SuperHearing</span> <span class="keyword">extends</span> <span class="title">SuperPower</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hearSubtleNoises</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SuperSmell</span> <span class="keyword">extends</span> <span class="title">SuperPower</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">trackBySmell</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperHero</span>&lt;<span class="title">POWER</span> <span class="keyword">extends</span> <span class="title">SuperPower</span>&gt; </span>&#123;</span><br><span class="line">    POWER power;</span><br><span class="line"></span><br><span class="line">    SuperHero(POWER power) &#123;</span><br><span class="line">        <span class="keyword">this</span>.power = power;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">POWER <span class="title">getPower</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> power;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperSleuth</span>&lt;<span class="title">POWER</span> <span class="keyword">extends</span> <span class="title">XRayVision</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">SuperHero</span>&lt;<span class="title">POWER</span>&gt; </span>&#123;</span><br><span class="line">    SuperSleuth(POWER power) &#123;</span><br><span class="line">        <span class="keyword">super</span>(power);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">see</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        power.seeThroughWalls();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span></span></span><br><span class="line"><span class="class"><span class="title">CanineHero</span>&lt;<span class="title">POWER</span> <span class="keyword">extends</span> <span class="title">SuperHearing</span> &amp; <span class="title">SuperSmell</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">SuperHero</span>&lt;<span class="title">POWER</span>&gt; </span>&#123;</span><br><span class="line">    CanineHero(POWER power) &#123;</span><br><span class="line">        <span class="keyword">super</span>(power);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        power.hearSubtleNoises();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">smell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        power.trackBySmell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperHearSmell</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">SuperHearing</span>, <span class="title">SuperSmell</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hearSubtleNoises</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trackBySmell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DogPerson</span> <span class="keyword">extends</span> <span class="title">CanineHero</span>&lt;<span class="title">SuperHearSmell</span>&gt; </span>&#123;</span><br><span class="line">    DogPerson() &#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">new</span> SuperHearSmell());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EpicBattle</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Bounds in generic methods:</span></span><br><span class="line">    <span class="keyword">static</span> &lt;POWER extends SuperHearing&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">useSuperHearing</span><span class="params">(SuperHero&lt;POWER&gt; hero)</span> </span>&#123;</span><br><span class="line">        hero.getPower().hearSubtleNoises();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;POWER extends SuperHearing &amp; SuperSmell&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">superFind</span><span class="params">(SuperHero&lt;POWER&gt; hero)</span> </span>&#123;</span><br><span class="line">        hero.getPower().hearSubtleNoises();</span><br><span class="line">        hero.getPower().trackBySmell();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DogPerson dogPerson = <span class="keyword">new</span> DogPerson();</span><br><span class="line">        useSuperHearing(dogPerson);</span><br><span class="line">        superFind(dogPerson);</span><br><span class="line">        <span class="comment">// You can do this:</span></span><br><span class="line">        List&lt;? extends SuperHearing&gt; audioPeople;</span><br><span class="line">        <span class="comment">// But you can't do this:</span></span><br><span class="line">        <span class="comment">// List&lt;? extends SuperHearing &amp; SuperSmell&gt; dogPs;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来将要研究的通配符将会把范围限制在单个类型。</p>
<h2 id="extends-T-and-super-T"><a href="#extends-T-and-super-T" class="headerlink" title="? extends T and ? super T"></a>? extends T and ? super T</h2><p>List&lt;? extends T&gt;如果去添加元素的时候，因为list中存放的其实是T的一种子类，如果我们去添加元素，其实不知道到底应该添加T的哪个子类，这个时候桥接方法在进行强转的时候会出错。但是如果是从集合中将元素取出来，我们可以知道取出来的元素肯定是T类型。所以<strong>? extends T这种方式可以取元素而不能添加，这个叫get原则。</strong></p>
<p>List&lt;? super T&gt;因为存的都是类型T的父类，所以如果去添加T类或者T类子类的元素，肯定是可以的。但是如果将元素取出来，则不知道到底是什么类型，所以? super T可以添加元素但是没法取出来，这个叫put原则。</p>
<!-- Wildcards -->

<h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><p>你已经在 <a href="book/12-Collections.md">集合</a> 章节中看到了一些简单示例使用了通配符——在泛型参数表达式中的问号，在 <a href="book/19-Type-Information.md">类型信息</a> 一章中这种示例更多。本节将更深入地探讨这个特性。</p>
<p>我们的起始示例要展示数组的一种特殊行为：你可以将派生类的数组赋值给基类的引用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/CovariantArrays.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Jonathan</span> <span class="keyword">extends</span> <span class="title">Apple</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CovariantArrays</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Fruit[] fruit = <span class="keyword">new</span> Apple[<span class="number">10</span>];</span><br><span class="line">        fruit[<span class="number">0</span>] = <span class="keyword">new</span> Apple(); <span class="comment">// OK</span></span><br><span class="line">        fruit[<span class="number">1</span>] = <span class="keyword">new</span> Jonathan(); <span class="comment">// OK</span></span><br><span class="line">        <span class="comment">// Runtime type is Apple[], not Fruit[] or Orange[]:</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Compiler allows you to add Fruit:</span></span><br><span class="line">            fruit[<span class="number">0</span>] = <span class="keyword">new</span> Fruit(); <span class="comment">// ArrayStoreException</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Compiler allows you to add Oranges:</span></span><br><span class="line">            fruit[<span class="number">0</span>] = <span class="keyword">new</span> Orange(); <span class="comment">// ArrayStoreException</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">java.lang.ArrayStoreException: Fruit</span></span><br><span class="line"><span class="comment">java.lang.ArrayStoreException: Orange</span></span><br></pre></td></tr></table></figure>

<p><code>main()</code> 中的第一行创建了 <strong>Apple</strong> 数组，并赋值给一个 <strong>Fruit</strong> 数组引用。这是有意义的，因为 <strong>Apple</strong> 也是一种 <strong>Fruit</strong>，因此 <strong>Apple</strong> 数组应该也是一个 <strong>Fruit</strong> 数组。</p>
<p>但是，如果实际的数组类型是 <strong>Apple[]</strong>，你可以在其中放置 <strong>Apple</strong> 或 <strong>Apple</strong> 的子类型，这在编译期和运行时都可以工作。但是你也可以在数组中放置 <strong>Fruit</strong> 对象。这对编译器来说是有意义的，因为它有一个 <strong>Fruit[]</strong> 引用——它有什么理由不允许将 <strong>Fruit</strong> 对象或任何从 <strong>Fruit</strong> 继承出来的对象（比如 <strong>Orange</strong>），放置到这个数组中呢？因此在编译期，这是允许的。然而，运行时的数组机制知道它处理的是 <strong>Apple[]</strong>，因此会在向数组中放置异构类型时抛出异常。</p>
<p>向上转型用在这里不合适。你真正在做的是将一个数组赋值给另一个数组。数组的行为是持有其他对象，这里只是因为我们能够向上转型而已，所以很明显，数组对象可以保留有关它们包含的对象类型的规则。看起来就像数组对它们持有的对象是有意识的，因此在编译期检查和运行时检查之间，你不能滥用它们。</p>
<p>数组的这种赋值并不是那么可怕，因为在运行时你可以发现插入了错误的类型。但是<strong>泛型的主要目标之一是将这种错误检测移到编译期。</strong>所以当我们试图使用泛型集合代替数组时，会发生什么呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/NonCovariantGenerics.java</span></span><br><span class="line"><span class="comment">// &#123;WillNotCompile&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NonCovariantGenerics</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Compile Error: incompatible types:</span></span><br><span class="line">    List&lt;Fruit&gt; flist = <span class="keyword">new</span> ArrayList&lt;Apple&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尽管你在首次阅读这段代码时会认为“不能将一个 <strong>Apple</strong> 集合赋值给一个 <strong>Fruit</strong> 集合”。记住，泛型不仅仅是关于集合，它真正要表达的是“不能把一个涉及 <strong>Apple</strong> 的泛型赋值给一个涉及 <strong>Fruit</strong> 的泛型”。如果像在数组中的情况一样，编译器对代码的了解足够多，可以确定所涉及到的集合，那么它可能会留下一些余地。但是它不知道任何有关这方面的信息，因此它拒绝向上转型。然而实际上这也不是向上转型—— <strong>Apple</strong> 的 <strong>List</strong> 不是 <strong>Fruit</strong> 的 <strong>List</strong>。<strong>Apple</strong> 的 <strong>List</strong> 将持有 <strong>Apple</strong> 和 <strong>Apple</strong> 的子类型，<strong>Fruit</strong> 的 <strong>List</strong> 将持有任何类型的 <strong>Fruit</strong>。是的，这包括 <strong>Apple</strong>，但是它不是一个 <strong>Apple</strong> 的 <strong>List</strong>，它仍然是 <strong>Fruit</strong> 的 <strong>List</strong>。<strong>Apple</strong> 的 <strong>List</strong> 在类型上不等价于 <strong>Fruit</strong> 的 <strong>List</strong>，即使 <strong>Apple</strong> 是一种 <strong>Fruit</strong> 类型。</p>
<p>真正的问题<strong>是我们在讨论的集合类型，而不是集合持有对象的类型。</strong>与<strong>数组不同，泛型没有内建的协变类型。</strong>这是<strong>因为数组是完全在语言中定义的，因此可以具有编译期和运行时的内建检查</strong>，但是在使用泛型时，编译器和运行时系统不知道你想用类型做什么，以及应该采用什么规则。</p>
<p>但是，有时你想在两个类型间建立某种向上转型关系。通配符可以产生这种关系。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/GenericsAndCovariance.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsAndCovariance</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Wildcards allow covariance:</span></span><br><span class="line">        List&lt;? extends Fruit&gt; flist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// Compile Error: can't add any type of object:</span></span><br><span class="line">        <span class="comment">// flist.add(new Apple());</span></span><br><span class="line">        <span class="comment">// flist.add(new Fruit());</span></span><br><span class="line">        <span class="comment">// flist.add(new Object());</span></span><br><span class="line">        flist.add(<span class="keyword">null</span>); <span class="comment">// Legal but uninteresting</span></span><br><span class="line">        <span class="comment">// We know it returns at least Fruit:</span></span><br><span class="line">        Fruit f = flist.get(<span class="number">0</span>);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>flist</strong> 的类型现在是 <code>List&lt;? extends Fruit&gt;</code>，你可以读作“一个具有任何从 <strong>Fruit</strong> 继承的类型的列表”。然而，这实际上并不意味着这个 <strong>List</strong> 将持有任何类型的 <strong>Fruit</strong>。通配符引用的是明确的类型，因此它意味着“某种 <strong>flist</strong> 引用没有指定的具体类型”。因此这个被赋值的 <strong>List</strong> 必须持有诸如 <strong>Fruit</strong> 或 <strong>Apple</strong> 这样的指定类型，但是为了向上转型为 <strong>Fruit</strong>，这个类型是什么没人在意。</p>
<p><strong>List</strong> 必须持有一种具体的 <strong>Fruit</strong> 或 <strong>Fruit</strong> 的子类型，但是如果你不关心具体的类型是什么，那么你能对这样的 <strong>List</strong> 做什么呢？如果不知道 <strong>List</strong> 中持有的对象是什么类型，你怎能保证安全地向其中添加对象呢？就像在 <strong>CovariantArrays.java</strong> 中向上转型一样，你不能，除非编译器而不是运行时系统可以阻止这种操作的发生。你很快就会发现这个问题。</p>
<p>你可能认为事情开始变得有点走极端了，因为现在你<strong>甚至不能向刚刚声明过将持有 Apple 对象的 List 中放入一个 Apple 对象。</strong>是的，但编译器并不知道这一点。<code>List&lt;? extends Fruit&gt;</code> 可能合法地指向一个 <code>List&lt;Orange&gt;</code>。一旦执行这种类型的向上转型，你就丢失了向其中传递任何对象的能力，甚至传递 <strong>Object</strong> 也不行。</p>
<p>另一方面，如果你调用了一个返回 <strong>Fruit</strong> 的方法，则是安全的，因为你知道这个 <strong>List</strong> 中的任何对象至少具有 <strong>Fruit</strong> 类型，因此编译器允许这么做。</p>
<h3 id="编译器有多聪明"><a href="#编译器有多聪明" class="headerlink" title="编译器有多聪明"></a>编译器有多聪明</h3><p>现在你可能会猜想自己不能去调用任何接受参数的方法，但是考虑下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/CompilerIntelligence.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompilerIntelligence</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;? extends Fruit&gt; flist = Arrays.asList(<span class="keyword">new</span> Apple());</span><br><span class="line">        Apple a = (Apple) flist.get(<span class="number">0</span>); <span class="comment">// No warning</span></span><br><span class="line">        flist.contains(<span class="keyword">new</span> Apple()); <span class="comment">// Argument is 'Object'</span></span><br><span class="line">        flist.indexOf(<span class="keyword">new</span> Apple()); <span class="comment">// Argument is 'Object'</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里对 <code>contains()</code> 和 <code>indexOf()</code> 的调用接受 <strong>Apple</strong> 对象作为参数，执行没问题。这是否意味着编译器实际上会检查代码，以查看是否有某个特定的方法修改了它的对象？</p>
<p>通过查看 <strong>ArrayList</strong> 的文档，我们发现编译器没有那么聪明。尽管 <code>add()</code> 接受一个泛型参数类型的参数，但 <code>contains()</code> 和 <code>indexOf()</code> 接受的参数类型是 <strong>Object</strong>。因此当你指定一个 <code>ArrayList&lt;? extends Fruit&gt;</code> 时，<code>add()</code> 的参数就变成了”<strong>? extends Fruit</strong>“。从这个描述中，编译器无法得知这里需要 <strong>Fruit</strong> 的哪个具体子类型，因此它不会接受任何类型的 <strong>Fruit</strong>。如果你先把 <strong>Apple</strong> 向上转型为 <strong>Fruit</strong>，也没有关系——编译器仅仅会拒绝调用像 <code>add()</code> 这样参数列表中涉及通配符的方法。</p>
<p><code>contains()</code> 和 <code>indexOf()</code> 的参数类型是 <strong>Object</strong>，不涉及通配符，所以编译器允许调用它们。这意味着将由泛型类的设计者来决定哪些调用是“安全的”，并使用 <strong>Object</strong> 类作为它们的参数类型。为了禁止对类型中使用了通配符的方法调用，需要在参数列表中使用类型参数。</p>
<p>下面展示一个简单的 <strong>Holder</strong> 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder</span><span class="params">(T val)</span> </span>&#123;</span><br><span class="line">        value = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T val)</span> </span>&#123;</span><br><span class="line">        value = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o <span class="keyword">instanceof</span> Holder &amp;&amp; Objects.equals(value, ((Holder) o).value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Holder&lt;Apple&gt; apple = <span class="keyword">new</span> Holder&lt;&gt;(<span class="keyword">new</span> Apple());</span><br><span class="line">        Apple d = apple.get();</span><br><span class="line">        apple.set(d);</span><br><span class="line"><span class="comment">//        Holder&lt;Fruit&gt; fruit = apple; // Cannot upcast</span></span><br><span class="line">        Holder&lt;? extends Fruit&gt; fruit = apple; <span class="comment">// OK</span></span><br><span class="line">        Fruit p = fruit.get();</span><br><span class="line">        d = (Apple) fruit.get();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Orange c = (Orange) fruit.get(); <span class="comment">// No warning</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        fruit.set(new Apple()); // Cannot call set()</span></span><br><span class="line"><span class="comment">//        fruit.set(new Fruit()); // Cannot call set()</span></span><br><span class="line">        System.out.println(fruit.equals(d)); <span class="comment">// OK</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output</span></span><br><span class="line"><span class="comment">java.lang.ClassCastException: Apple cannot be cast to Orange</span></span><br><span class="line"><span class="comment">false</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>Holder</strong> 有一个接受 <strong>T</strong> 类型对象的 <code>set()</code> 方法，一个返回 T 对象的 <code>get()</code> 方法和一个接受 Object 对象的 <code>equals()</code> 方法。正如你所见，<strong>如果创建了一个 <code>Holder&lt;Apple&gt;</code>，就不能将其向上转型为 <code>Holder&lt;Fruit&gt;</code>，但是可以向上转型为 <code>Holder&lt;? extends Fruit&gt;</code>。</strong>如果调用 <code>get()</code>，只能返回一个 <strong>Fruit</strong>——这就是在给定“任何；额扩展自 <strong>Fruit</strong> 的对象”这一边界后，它所能知道的一切了。如果你知道更多的信息，就可以将其转型到某种具体的 <strong>Fruit</strong> 而不会导致任何警告，但是存在得到 <strong>ClassCastException</strong> 的风险。<code>set()</code> 方法不能工作在 <strong>Apple</strong> 和 <strong>Fruit</strong> 上，因为 <strong><code>set()</code> 的参数也是”? extends Fruit”，意味着它可以是任何事物，编译器无法验证“任何事物”的类型安全性。</strong></p>
<p>但是，<code>equals()</code> 方法可以正常工作，因为它接受的参数是 <strong>Object</strong> 而不是 <strong>T</strong> 类型。因此，编译器只关注传递进来和要返回的对象类型。它不会分析代码，以查看是否执行了任何实际的写入和读取操作。</p>
<p>Java 7 引入了 <strong>java.util.Objects</strong> 库，使创建 <code>equals()</code> 和 <code>hashCode()</code> 方法变得更加容易，当然还有很多其他功能。<code>equals()</code> 方法的标准形式参考 <a href="book/Appendix-Understanding-equals-and-hashCode">附录：理解 equals 和 hashCode 方法</a> 一章。</p>
<h3 id="逆变"><a href="#逆变" class="headerlink" title="逆变"></a>逆变</h3><p>还可以走另外一条路，即使用超类型通配符。这里，可以<strong>声明通配符是由某个特定类的任何基类来界定的，方法是指定 <code>&lt;？super MyClass&gt;</code></strong> ，或者甚至使用类型参数： <code>&lt;？super T&gt;</code>（尽管你不能对泛型参数给出一个超类型边界；即不能声明 <code>&lt;T super MyClass&gt;</code> ）。<strong>这使得你可以安全地传递一个类型对象到泛型类型中</strong>。因此，有了<strong>超类型通配符</strong>，就可以向 <strong>Collection</strong> 写入了：</p>
<p><strong>==确定了泛型下界==</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/SuperTypeWildcards.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperTypeWildcards</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeTo</span><span class="params">(List&lt;? <span class="keyword">super</span> Apple&gt; apples)</span> </span>&#123;</span><br><span class="line">        apples.add(<span class="keyword">new</span> Apple());</span><br><span class="line">        apples.add(<span class="keyword">new</span> Jonathan());</span><br><span class="line">        <span class="comment">// apples.add(new Fruit()); // Error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数 <strong>apples</strong> 是 <strong>Apple</strong> 的某种基类型的 <strong>List</strong>，这样你就知道向其中添加 <strong>Apple</strong> 或 <strong>Apple</strong> 的子类型是安全的。但是<strong>因为 Apple 是下界</strong>，所以你知道向这样的 <strong>List</strong> 中添加 <strong>Fruit</strong> 是不安全的，因为这将使这个 <strong>List</strong> 敞开口子，从而可以向其中添加非 <strong>Apple</strong> 类型的对象，而这是违反静态类型安全的。<br>下面的示例复习了一下逆变和通配符的的使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/GenericReading.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericReading</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> List&lt;Apple&gt; apples = Arrays.asList(<span class="keyword">new</span> Apple());</span><br><span class="line">    <span class="keyword">static</span> List&lt;Fruit&gt; fruit = Arrays.asList(<span class="keyword">new</span> Fruit());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">readExact</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// A static method adapts to each call:</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Apple a = readExact(apples);</span><br><span class="line">        Fruit f = readExact(fruit);</span><br><span class="line">        f = readExact(apples);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// A class type is established</span></span><br><span class="line">    <span class="comment">// when the class is instantiated:</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Reader</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function">T <span class="title">readExact</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123; </span><br><span class="line">            <span class="keyword">return</span> list.get(<span class="number">0</span>); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Reader&lt;Fruit&gt; fruitReader = <span class="keyword">new</span> Reader&lt;&gt;();</span><br><span class="line">        Fruit f = fruitReader.readExact(fruit);</span><br><span class="line">        <span class="comment">//- Fruit a = fruitReader.readExact(apples);</span></span><br><span class="line">        <span class="comment">// error: incompatible types: List&lt;Apple&gt;</span></span><br><span class="line">        <span class="comment">// cannot be converted to List&lt;Fruit&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CovariantReader</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function">T <span class="title">readCovariant</span><span class="params">(List&lt;? extends T&gt; list)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CovariantReader&lt;Fruit&gt; fruitReader = <span class="keyword">new</span> CovariantReader&lt;&gt;();</span><br><span class="line">        Fruit f = fruitReader.readCovariant(fruit);</span><br><span class="line">        Fruit a = fruitReader.readCovariant(apples);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        f1(); </span><br><span class="line">        f2(); </span><br><span class="line">        f3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>readExact()</code> 方法使用了精确的类型。如果使用这个没有任何通配符的精确类型，就可以向 <strong>List</strong> 中写入和读取这个精确类型。另外，对于返回值，静态的泛型方法 <code>readExact()</code> 可以有效地“适应”每个方法调用，并能够从 <code>List&lt;Apple&gt;</code> 中返回一个 <strong>Apple</strong> ，从 <code>List&lt;Fruit&gt;</code> 中返回一个 <strong>Fruit</strong> ，就像在 <code>f1()</code> 中看到的那样。因此，如果可以摆脱静态泛型方法，那么在读取时就不需要协变类型了。<br>然而对于泛型类来说，当你创建这个类的实例时，就要为这个类确定参数。就像在 <code>f2()</code> 中看到的，<strong>fruitReader</strong> 实例可以从 <code>List&lt;Fruit&gt;</code> 中读取一个 <strong>Fruit</strong> ，因为这就是它的确切类型。但是 <code>List&lt;Apple&gt;</code> 也应该产生 <strong>Fruit</strong> 对象，而 <strong>fruitReader</strong> 不允许这么做。<br>为了修正这个问题，<code>CovariantReader.readCovariant()</code> 方法将接受 <code>List&lt;？extends T&gt;</code> ，因此，从这个列表中读取一个 <strong>T</strong> 是安全的（你知道在这个列表中的所有对象至少是一个 <strong>T</strong> ，并且可能是从 T 导出的某种对象）。在 <code>f3()</code> 中，你可以看到现在可以从 <code>List&lt;Apple&gt;</code> 中读取 <strong>Fruit</strong> 了。</p>
<h3 id="无界通配符"><a href="#无界通配符" class="headerlink" title="无界通配符"></a>无界通配符</h3><p><strong>无界通配符 <code>&lt;?&gt;</code> 看起来意味着“任何事物”，因此使用无界通配符好像等价于使用原生类型。</strong>事实上，编译器初看起来是支持这种判断的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/UnboundedWildcards1.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnboundedWildcards1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> List list1;</span><br><span class="line">    <span class="keyword">static</span> List&lt;?&gt; list2;</span><br><span class="line">    <span class="keyword">static</span> List&lt;? extends Object&gt; list3;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign1</span><span class="params">(List list)</span> </span>&#123;</span><br><span class="line">        list1 = list;</span><br><span class="line">        list2 = list;</span><br><span class="line">        <span class="comment">//- list3 = list;</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked conversion</span></span><br><span class="line">        <span class="comment">// list3 = list;</span></span><br><span class="line">        <span class="comment">//         ^</span></span><br><span class="line">        <span class="comment">// required: List&lt;? extends Object&gt;</span></span><br><span class="line">        <span class="comment">// found:    List</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign2</span><span class="params">(List&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line">        list1 = list;</span><br><span class="line">        list2 = list;</span><br><span class="line">        list3 = list;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign3</span><span class="params">(List&lt;? extends Object&gt; list)</span> </span>&#123;</span><br><span class="line">        list1 = list;</span><br><span class="line">        list2 = list;</span><br><span class="line">        list3 = list;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        assign1(<span class="keyword">new</span> ArrayList());</span><br><span class="line">        assign2(<span class="keyword">new</span> ArrayList());</span><br><span class="line">        <span class="comment">//- assign3(new ArrayList());</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked method invocation:</span></span><br><span class="line">        <span class="comment">// method assign3 in class UnboundedWildcards1</span></span><br><span class="line">        <span class="comment">// is applied to given types</span></span><br><span class="line">        <span class="comment">// assign3(new ArrayList());</span></span><br><span class="line">        <span class="comment">//        ^</span></span><br><span class="line">        <span class="comment">// required: List&lt;? extends Object&gt;</span></span><br><span class="line">        <span class="comment">// found: ArrayList</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked conversion</span></span><br><span class="line">        <span class="comment">// assign3(new ArrayList());</span></span><br><span class="line">        <span class="comment">//         ^</span></span><br><span class="line">        <span class="comment">// required: List&lt;? extends Object&gt;</span></span><br><span class="line">        <span class="comment">// found:    ArrayList</span></span><br><span class="line">        <span class="comment">// 2 warnings</span></span><br><span class="line">        assign1(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        assign2(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        assign3(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="comment">// Both forms are acceptable as List&lt;?&gt;:</span></span><br><span class="line">        List&lt;?&gt; wildList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        wildList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        assign1(wildList);</span><br><span class="line">        assign2(wildList);</span><br><span class="line">        assign3(wildList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有很多情况都和你在这里看到的情况类似，即编译器很少关心使用的是原生类型还是 <code>&lt;?&gt;</code> 。在这些情况中，<code>&lt;?&gt;</code> 可以被认为是一种装饰，但是它仍旧是很有价值的，因为，实际上它是在声明：“<strong>我是想用 Java 的泛型来编写这段代码，我在这里并不是要用原生类型，但是在当前这种情况下，泛型参数可以持有任何类型</strong>。”<br>第二个示例展示了无界通配符的一个重要应用。当你在处理多个泛型参数时，有时允许一个参数可以是任何类型，同时为其他参数确定某种特定类型的这种能力会显得很重要：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/UnboundedWildcards2.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnboundedWildcards2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Map map1;</span><br><span class="line">    <span class="keyword">static</span> Map&lt;?,?&gt; map2;</span><br><span class="line">    <span class="keyword">static</span> Map&lt;String,?&gt; map3;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign1</span><span class="params">(Map map)</span> </span>&#123; </span><br><span class="line">        map1 = map; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign2</span><span class="params">(Map&lt;?,?&gt; map)</span> </span>&#123; </span><br><span class="line">        map2 = map; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign3</span><span class="params">(Map&lt;String,?&gt; map)</span> </span>&#123; </span><br><span class="line">        map3 = map; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        assign1(<span class="keyword">new</span> HashMap());</span><br><span class="line">        assign2(<span class="keyword">new</span> HashMap());</span><br><span class="line">        <span class="comment">//- assign3(new HashMap());</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked method invocation:</span></span><br><span class="line">        <span class="comment">// method assign3 in class UnboundedWildcards2</span></span><br><span class="line">        <span class="comment">// is applied to given types</span></span><br><span class="line">        <span class="comment">//     assign3(new HashMap());</span></span><br><span class="line">        <span class="comment">//            ^</span></span><br><span class="line">        <span class="comment">//   required: Map&lt;String,?&gt;</span></span><br><span class="line">        <span class="comment">//   found: HashMap</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked conversion</span></span><br><span class="line">        <span class="comment">//     assign3(new HashMap());</span></span><br><span class="line">        <span class="comment">//             ^</span></span><br><span class="line">        <span class="comment">//   required: Map&lt;String,?&gt;</span></span><br><span class="line">        <span class="comment">//   found:    HashMap</span></span><br><span class="line">        <span class="comment">// 2 warnings</span></span><br><span class="line">        assign1(<span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">        assign2(<span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">        assign3(<span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，当你拥有的全都是无界通配符时，就像在 <code>Map&lt;?,?&gt;</code> 中看到的那样，编译器看起来就无法将其与原生 <strong>Map</strong> 区分开了。另外， <strong>UnboundedWildcards1.java</strong> 展示了编译器处理  <code>List&lt;?&gt;</code> 和 <code>List&lt;? extends Object&gt;</code> 是不同的。<br>令人困惑的是，<strong>编译器并非总是关注像 <code>List</code> 和 <code>List&lt;?&gt;</code> 之间的这种差异，因此它们看起来就像是相同的事物</strong>。事实上，因为<strong>泛型参数擦除到它的第一个边界，因此 <code>List&lt;?&gt;</code> 看起来等价于 <code>List&lt;Object&gt;</code></strong> ，而 <strong>List</strong> 实际上也是 <code>List&lt;Object&gt;</code> ——除非这些语句都不为真。<strong>List</strong> 实际上表示“持有任何 <strong>Object</strong> 类型的原生 <strong>List ** ”，</strong>而 <code>List&lt;?&gt;</code> 表示“具有某种特定类型的非原生 List** ，只是我们不知道类型是什么。”<br>编译器何时才会关注原生类型和涉及无界通配符的类型之间的差异呢？下面的示例使用了前面定义的 <code>Holder&lt;T&gt;</code> 类，它包含接受 <strong>Holder</strong> 作为参数的各种方法，但是它们具有不同的形式：作为原生类型，具有具体的类型参数以及具有无界通配符参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Wildcards.java</span></span><br><span class="line"><span class="comment">// Exploring the meaning of wildcards</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wildcards</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Raw argument:</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rawArgs</span><span class="params">(Holder holder, Object arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//- holder.set(arg);</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked call to set(T)</span></span><br><span class="line">        <span class="comment">// as a member of the raw type Holder</span></span><br><span class="line">        <span class="comment">//     holder.set(arg);</span></span><br><span class="line">        <span class="comment">//               ^</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in class Holder</span></span><br><span class="line">        <span class="comment">// 1 warning</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Can't do this; don't have any 'T':</span></span><br><span class="line">        <span class="comment">// T t = holder.get();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// OK, but type information is lost:</span></span><br><span class="line">        Object obj = holder.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Like rawArgs(), but errors instead of warnings:</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unboundedArg</span><span class="params">(Holder&lt;?&gt; holder, Object arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//- holder.set(arg);</span></span><br><span class="line">        <span class="comment">// error: method set in class Holder&lt;T&gt;</span></span><br><span class="line">        <span class="comment">// cannot be applied to given types;</span></span><br><span class="line">        <span class="comment">//     holder.set(arg);</span></span><br><span class="line">        <span class="comment">//           ^</span></span><br><span class="line">        <span class="comment">//   required: CAP#1</span></span><br><span class="line">        <span class="comment">//   found: Object</span></span><br><span class="line">        <span class="comment">//   reason: argument mismatch;</span></span><br><span class="line">        <span class="comment">//     Object cannot be converted to CAP#1</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in class Holder</span></span><br><span class="line">        <span class="comment">//   where CAP#1 is a fresh type-variable:</span></span><br><span class="line">        <span class="comment">//     CAP#1 extends Object from capture of ?</span></span><br><span class="line">        <span class="comment">// 1 error</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Can't do this; don't have any 'T':</span></span><br><span class="line">        <span class="comment">// T t = holder.get();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// OK, but type information is lost:</span></span><br><span class="line">        Object obj = holder.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">exact1</span><span class="params">(Holder&lt;T&gt; holder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> holder.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">exact2</span><span class="params">(Holder&lt;T&gt; holder, T arg)</span> </span>&#123;</span><br><span class="line">        holder.set(arg);</span><br><span class="line">        <span class="keyword">return</span> holder.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">wildSubtype</span><span class="params">(Holder&lt;? extends T&gt; holder, T arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//- holder.set(arg);</span></span><br><span class="line">        <span class="comment">// error: method set in class Holder&lt;T#2&gt;</span></span><br><span class="line">        <span class="comment">// cannot be applied to given types;</span></span><br><span class="line">        <span class="comment">//     holder.set(arg);</span></span><br><span class="line">        <span class="comment">//           ^</span></span><br><span class="line">        <span class="comment">//   required: CAP#1</span></span><br><span class="line">        <span class="comment">//   found: T#1</span></span><br><span class="line">        <span class="comment">//   reason: argument mismatch;</span></span><br><span class="line">        <span class="comment">//     T#1 cannot be converted to CAP#1</span></span><br><span class="line">        <span class="comment">//   where T#1,T#2 are type-variables:</span></span><br><span class="line">        <span class="comment">//     T#1 extends Object declared in method</span></span><br><span class="line">        <span class="comment">//     &lt;T#1&gt;wildSubtype(Holder&lt;? extends T#1&gt;,T#1)</span></span><br><span class="line">        <span class="comment">//     T#2 extends Object declared in class Holder</span></span><br><span class="line">        <span class="comment">//   where CAP#1 is a fresh type-variable:</span></span><br><span class="line">        <span class="comment">//     CAP#1 extends T#1 from</span></span><br><span class="line">        <span class="comment">//       capture of ? extends T#1</span></span><br><span class="line">        <span class="comment">// 1 error</span></span><br><span class="line">        <span class="keyword">return</span> holder.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">wildSupertype</span><span class="params">(Holder&lt;? <span class="keyword">super</span> T&gt; holder, T arg)</span> </span>&#123;</span><br><span class="line">        holder.set(arg);</span><br><span class="line">        <span class="comment">//- T t = holder.get();</span></span><br><span class="line">        <span class="comment">// error: incompatible types:</span></span><br><span class="line">        <span class="comment">// CAP#1 cannot be converted to T</span></span><br><span class="line">        <span class="comment">//     T t = holder.get();</span></span><br><span class="line">        <span class="comment">//                     ^</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in method</span></span><br><span class="line">        <span class="comment">//       &lt;T&gt;wildSupertype(Holder&lt;? super T&gt;,T)</span></span><br><span class="line">        <span class="comment">//   where CAP#1 is a fresh type-variable:</span></span><br><span class="line">        <span class="comment">//     CAP#1 extends Object super:</span></span><br><span class="line">        <span class="comment">//       T from capture of ? super T</span></span><br><span class="line">        <span class="comment">// 1 error</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// OK, but type information is lost:</span></span><br><span class="line">        Object obj = holder.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Holder raw = <span class="keyword">new</span> Holder&lt;&gt;();</span><br><span class="line">        <span class="comment">// Or:</span></span><br><span class="line">        raw = <span class="keyword">new</span> Holder();</span><br><span class="line">        Holder&lt;Long&gt; qualified = <span class="keyword">new</span> Holder&lt;&gt;();</span><br><span class="line">        Holder&lt;?&gt; unbounded = <span class="keyword">new</span> Holder&lt;&gt;();</span><br><span class="line">        Holder&lt;? extends Long&gt; bounded = <span class="keyword">new</span> Holder&lt;&gt;();</span><br><span class="line">        Long lng = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">        rawArgs(raw, lng);</span><br><span class="line">        rawArgs(qualified, lng);</span><br><span class="line">        rawArgs(unbounded, lng);</span><br><span class="line">        rawArgs(bounded, lng);</span><br><span class="line"></span><br><span class="line">        unboundedArg(raw, lng);</span><br><span class="line">        unboundedArg(qualified, lng);</span><br><span class="line">        unboundedArg(unbounded, lng);</span><br><span class="line">        unboundedArg(bounded, lng);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Object r1 = exact1(raw);</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked method invocation:</span></span><br><span class="line">        <span class="comment">// method exact1 in class Wildcards is applied</span></span><br><span class="line">        <span class="comment">// to given types</span></span><br><span class="line">        <span class="comment">//      Object r1 = exact1(raw);</span></span><br><span class="line">        <span class="comment">//                        ^</span></span><br><span class="line">        <span class="comment">//   required: Holder&lt;T&gt;</span></span><br><span class="line">        <span class="comment">//   found: Holder</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in</span></span><br><span class="line">        <span class="comment">//     method &lt;T&gt;exact1(Holder&lt;T&gt;)</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked conversion</span></span><br><span class="line">        <span class="comment">//      Object r1 = exact1(raw);</span></span><br><span class="line">        <span class="comment">//                         ^</span></span><br><span class="line">        <span class="comment">//   required: Holder&lt;T&gt;</span></span><br><span class="line">        <span class="comment">//   found:    Holder</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in</span></span><br><span class="line">        <span class="comment">//     method &lt;T&gt;exact1(Holder&lt;T&gt;)</span></span><br><span class="line">        <span class="comment">// 2 warnings</span></span><br><span class="line"></span><br><span class="line">        Long r2 = exact1(qualified);</span><br><span class="line">        Object r3 = exact1(unbounded); <span class="comment">// Must return Object</span></span><br><span class="line">        Long r4 = exact1(bounded);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Long r5 = exact2(raw, lng);</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked method invocation:</span></span><br><span class="line">        <span class="comment">// method exact2 in class Wildcards is</span></span><br><span class="line">        <span class="comment">// applied to given types</span></span><br><span class="line">        <span class="comment">//     Long r5 = exact2(raw, lng);</span></span><br><span class="line">        <span class="comment">//                     ^</span></span><br><span class="line">        <span class="comment">//   required: Holder&lt;T&gt;,T</span></span><br><span class="line">        <span class="comment">//   found: Holder,Long</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in</span></span><br><span class="line">        <span class="comment">//       method &lt;T&gt;exact2(Holder&lt;T&gt;,T)</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked conversion</span></span><br><span class="line">        <span class="comment">//     Long r5 = exact2(raw, lng);</span></span><br><span class="line">        <span class="comment">//                      ^</span></span><br><span class="line">        <span class="comment">//   required: Holder&lt;T&gt;</span></span><br><span class="line">        <span class="comment">//   found:    Holder</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in</span></span><br><span class="line">        <span class="comment">//       method &lt;T&gt;exact2(Holder&lt;T&gt;,T)</span></span><br><span class="line">        <span class="comment">// 2 warnings</span></span><br><span class="line"></span><br><span class="line">        Long r6 = exact2(qualified, lng);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Long r7 = exact2(unbounded, lng);</span></span><br><span class="line">        <span class="comment">// error: method exact2 in class Wildcards</span></span><br><span class="line">        <span class="comment">// cannot be applied to given types;</span></span><br><span class="line">        <span class="comment">//     Long r7 = exact2(unbounded, lng);</span></span><br><span class="line">        <span class="comment">//               ^</span></span><br><span class="line">        <span class="comment">//   required: Holder&lt;T&gt;,T</span></span><br><span class="line">        <span class="comment">//   found: Holder&lt;CAP#1&gt;,Long</span></span><br><span class="line">        <span class="comment">//   reason: inference variable T has</span></span><br><span class="line">        <span class="comment">//     incompatible bounds</span></span><br><span class="line">        <span class="comment">//     equality constraints: CAP#1</span></span><br><span class="line">        <span class="comment">//     lower bounds: Long</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in</span></span><br><span class="line">        <span class="comment">//       method &lt;T&gt;exact2(Holder&lt;T&gt;,T)</span></span><br><span class="line">        <span class="comment">//   where CAP#1 is a fresh type-variable:</span></span><br><span class="line">        <span class="comment">//     CAP#1 extends Object from capture of ?</span></span><br><span class="line">        <span class="comment">// 1 error</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Long r8 = exact2(bounded, lng);</span></span><br><span class="line">        <span class="comment">// error: method exact2 in class Wildcards</span></span><br><span class="line">        <span class="comment">// cannot be applied to given types;</span></span><br><span class="line">        <span class="comment">//      Long r8 = exact2(bounded, lng);</span></span><br><span class="line">        <span class="comment">//                ^</span></span><br><span class="line">        <span class="comment">//   required: Holder&lt;T&gt;,T</span></span><br><span class="line">        <span class="comment">//   found: Holder&lt;CAP#1&gt;,Long</span></span><br><span class="line">        <span class="comment">//   reason: inference variable T</span></span><br><span class="line">        <span class="comment">//     has incompatible bounds</span></span><br><span class="line">        <span class="comment">//     equality constraints: CAP#1</span></span><br><span class="line">        <span class="comment">//     lower bounds: Long</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in</span></span><br><span class="line">        <span class="comment">//       method &lt;T&gt;exact2(Holder&lt;T&gt;,T)</span></span><br><span class="line">        <span class="comment">//   where CAP#1 is a fresh type-variable:</span></span><br><span class="line">        <span class="comment">//     CAP#1 extends Long from</span></span><br><span class="line">        <span class="comment">//       capture of ? extends Long</span></span><br><span class="line">        <span class="comment">// 1 error</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Long r9 = wildSubtype(raw, lng);</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked method invocation:</span></span><br><span class="line">        <span class="comment">// method wildSubtype in class Wildcards</span></span><br><span class="line">        <span class="comment">// is applied to given types</span></span><br><span class="line">        <span class="comment">//     Long r9 = wildSubtype(raw, lng);</span></span><br><span class="line">        <span class="comment">//                          ^</span></span><br><span class="line">        <span class="comment">//   required: Holder&lt;? extends T&gt;,T</span></span><br><span class="line">        <span class="comment">//   found: Holder,Long</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in</span></span><br><span class="line">        <span class="comment">//     method &lt;T&gt;wildSubtype(Holder&lt;? extends T&gt;,T)</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked conversion</span></span><br><span class="line">        <span class="comment">//     Long r9 = wildSubtype(raw, lng);</span></span><br><span class="line">        <span class="comment">//                           ^</span></span><br><span class="line">        <span class="comment">//   required: Holder&lt;? extends T&gt;</span></span><br><span class="line">        <span class="comment">//   found:    Holder</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in</span></span><br><span class="line">        <span class="comment">//     method &lt;T&gt;wildSubtype(Holder&lt;? extends T&gt;,T)</span></span><br><span class="line">        <span class="comment">// 2 warnings</span></span><br><span class="line"></span><br><span class="line">        Long r10 = wildSubtype(qualified, lng);</span><br><span class="line">        <span class="comment">// OK, but can only return Object:</span></span><br><span class="line">        Object r11 = wildSubtype(unbounded, lng);</span><br><span class="line">        Long r12 = wildSubtype(bounded, lng);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- wildSupertype(raw, lng);</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked method invocation:</span></span><br><span class="line">        <span class="comment">//   method wildSupertype in class Wildcards</span></span><br><span class="line">        <span class="comment">//   is applied to given types</span></span><br><span class="line">        <span class="comment">//     wildSupertype(raw, lng);</span></span><br><span class="line">        <span class="comment">//                  ^</span></span><br><span class="line">        <span class="comment">//   required: Holder&lt;? super T&gt;,T</span></span><br><span class="line">        <span class="comment">//   found: Holder,Long</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in</span></span><br><span class="line">        <span class="comment">//     method &lt;T&gt;wildSupertype(Holder&lt;? super T&gt;,T)</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked conversion</span></span><br><span class="line">        <span class="comment">//     wildSupertype(raw, lng);</span></span><br><span class="line">        <span class="comment">//                   ^</span></span><br><span class="line">        <span class="comment">//   required: Holder&lt;? super T&gt;</span></span><br><span class="line">        <span class="comment">//   found:    Holder</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in</span></span><br><span class="line">        <span class="comment">//     method &lt;T&gt;wildSupertype(Holder&lt;? super T&gt;,T)</span></span><br><span class="line">        <span class="comment">// 2 warnings</span></span><br><span class="line"></span><br><span class="line">        wildSupertype(qualified, lng);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- wildSupertype(unbounded, lng);</span></span><br><span class="line">        <span class="comment">// error: method wildSupertype in class Wildcards</span></span><br><span class="line">        <span class="comment">// cannot be applied to given types;</span></span><br><span class="line">        <span class="comment">//     wildSupertype(unbounded, lng);</span></span><br><span class="line">        <span class="comment">//     ^</span></span><br><span class="line">        <span class="comment">//   required: Holder&lt;? super T&gt;,T</span></span><br><span class="line">        <span class="comment">//   found: Holder&lt;CAP#1&gt;,Long</span></span><br><span class="line">        <span class="comment">//   reason: cannot infer type-variable(s) T</span></span><br><span class="line">        <span class="comment">//     (argument mismatch; Holder&lt;CAP#1&gt;</span></span><br><span class="line">        <span class="comment">//     cannot be converted to Holder&lt;? super T&gt;)</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in</span></span><br><span class="line">        <span class="comment">//     method &lt;T&gt;wildSupertype(Holder&lt;? super T&gt;,T)</span></span><br><span class="line">        <span class="comment">//   where CAP#1 is a fresh type-variable:</span></span><br><span class="line">        <span class="comment">//     CAP#1 extends Object from capture of ?</span></span><br><span class="line">        <span class="comment">// 1 error</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//- wildSupertype(bounded, lng);</span></span><br><span class="line">        <span class="comment">// error: method wildSupertype in class Wildcards</span></span><br><span class="line">        <span class="comment">// cannot be applied to given types;</span></span><br><span class="line">        <span class="comment">//     wildSupertype(bounded, lng);</span></span><br><span class="line">        <span class="comment">//     ^</span></span><br><span class="line">        <span class="comment">//   required: Holder&lt;? super T&gt;,T</span></span><br><span class="line">        <span class="comment">//   found: Holder&lt;CAP#1&gt;,Long</span></span><br><span class="line">        <span class="comment">//   reason: cannot infer type-variable(s) T</span></span><br><span class="line">        <span class="comment">//     (argument mismatch; Holder&lt;CAP#1&gt;</span></span><br><span class="line">        <span class="comment">//     cannot be converted to Holder&lt;? super T&gt;)</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in</span></span><br><span class="line">        <span class="comment">//     method &lt;T&gt;wildSupertype(Holder&lt;? super T&gt;,T)</span></span><br><span class="line">        <span class="comment">//   where CAP#1 is a fresh type-variable:</span></span><br><span class="line">        <span class="comment">//     CAP#1 extends Long from capture of</span></span><br><span class="line">        <span class="comment">//     ? extends Long</span></span><br><span class="line">        <span class="comment">// 1 error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>rawArgs()</code> 中，编译器知道 <code>Holder</code> 是一个泛型类型，因此即使它在这里被表示成一个原生类型，编译器仍旧知道向 <code>set()</code> 传递一个 <strong>Object</strong> 是不安全的。由于它是原生类型，你可以将任何类型的对象传递给 <code>set()</code> ，而这个对象将被向上转型为 <strong>Object</strong> 。<strong>因此无论何时，只要使用了原生类型，都会放弃编译期检查。</strong>对 <code>get()</code> 的调用说明了相同的问题：没有任何 <strong>T</strong> 类型的对象，因此结果只能是一个 <strong>Object</strong>。<br>人们很自然地会开始考虑原生 <code>Holder</code> 与 <code>Holder&lt;?&gt;</code> 是大致相同的事物。但是 <code>unboundedArg()</code> 强调它们是不同的——它揭示了相同的问题，但是它将这些问题作为错误而不是警告报告，因为原生 <strong>Holder</strong> 将持有任何类型的组合，而 <code>Holder&lt;?&gt;</code> 将持有具有某种具体类型的同构集合，因此不能只是向其中传递 <strong>Object</strong> 。<br>在 <code>exact1()</code> 和 <code>exact2()</code> 中，你可以看到使用了确切的泛型参数——没有任何通配符。你将看到，<code>exact2()</code>与 <code>exact1()</code> 具有不同的限制，因为它有额外的参数。<br>在 <code>wildSubtype()</code> 中，在 <strong>Holder</strong> 类型上的限制被放松为包括持有任何扩展自 <strong>T</strong> 的对象的 <strong>Holder</strong> 。这还是意味着如果 T 是 <strong>Fruit</strong> ，那么 <code>holder</code> 可以是 <code>Holder&lt;Apple&gt;</code> ，这是合法的。为了防止将 <strong>Orange</strong> 放置到 <code>Holder&lt;Apple&gt;</code> 中，对 <code>set()</code> 的调用（或者对任何接受这个类型参数为参数的方法的调用）都是不允许的。但是，<strong>你仍旧知道任何来自 <code>Holder&lt;？extends Fruit&gt;</code> 的对象至少是 Fruit ，因此 <code>get()</code> （或者任何将产生具有这个类型参数的返回值的方法）都是允许的。</strong><br><code>wildSupertype()</code> 展示了超类型通配符，这个方法展示了与 <code>wildSubtype()</code> 相反的行为：<code>holder</code> 可以是持有任何 T 的基类型的容器。因此， <code>set()</code> 可以接受 <strong>T</strong> ，因为任何可以工作于基类的对象都可以多态地作用于导出类（这里就是 <strong>T</strong> ）。但是，尝试着调用 <code>get()</code> 是没有用的，因为由 <code>holder</code> 持有的类型可以是任何超类型，因此唯一安全的类型就是 <strong>Object</strong> 。<br>这个示例还展示了对于在 <code>unbounded()</code> 中使用无界通配符能够做什么不能做什么所做出的限制：因为你没有 <strong>T</strong>，所以你不能将 <code>set()</code> 或 <code>get()</code> 作用于 <strong>T</strong> 上。</p>
<p>在 <code>main()</code> 方法中你看到了某些方法在接受某些类型的参数时没有报错和警告。为了迁移兼容性，<code>rawArgs()</code>  将接受所有 <strong>Holder</strong> 的不同变体，而不会产生警告。<code>unboundedArg()</code> 方法也可以接受相同的所有类型，尽管如前所述，它在方法体内部处理这些类型的方式并不相同。</p>
<p>如果向接受“确切”泛型类型（没有通配符）的方法传递一个原生 <strong>Holder</strong> 引用，就会得到一个警告，因为确切的参数期望得到在原生类型中并不存在的信息。如果向 <code>exact1()</code> 传递一个无界引用，就不会有任何可以确定返回类型的类型信息。<br>可以看到，<code>exact2()</code> 具有最多的限制，因为它希望精确地得到一个 <code>Holder&lt;T&gt;</code> ，以及一个具有类型 <strong>T</strong> 的参数，正由于此，它将产生错误或警告，除非提供确切的参数。有时，这样做很好，但是如果它过于受限，那么就可以使用通配符，这<strong>取决于是否想要从泛型参数中返回类型确定的返回值（就像在 <code>wildSubtype()</code> 中看到的那样），或者是否想要向泛型参数传递类型确定的参数（就像在 <code>wildSupertype()</code> 中看到的那样）。</strong><br>因此，使用确切类型来替代通配符类型的好处是，可以用泛型参数来做更多的事，但是使用通配符使得你必须接受范围更宽的参数化类型作为参数。因此，必须逐个情况地权衡利弊，找到更适合你的需求的方法。</p>
<h3 id="捕获转换"><a href="#捕获转换" class="headerlink" title="捕获转换"></a>捕获转换</h3><p>有一种特殊情况需要使用 <code>&lt;?&gt;</code> 而不是原生类型。如果向一个使用 <code>&lt;?&gt;</code> 的方法传递原生类型，那么对编译器来说，可能会推断出实际的类型参数，使得这个方法可以回转并调用另一个使用这个确切类型的方法。下面的示例演示了这种技术，它被称为捕获转换，因为未指定的通配符类型被捕获，并被转换为确切类型。这里，有关警告的注释只有在 <code>@SuppressWarnings</code> 注解被移除之后才能起作用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/CaptureConversion.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CaptureConversion</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(Holder&lt;T&gt; holder)</span> </span>&#123;</span><br><span class="line">        T t = holder.get();</span><br><span class="line">        System.out.println(t.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">(Holder&lt;?&gt; holder)</span> </span>&#123;</span><br><span class="line">        f1(holder); <span class="comment">// Call with captured type</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Holder raw = <span class="keyword">new</span> Holder&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">        f1(raw);</span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked method invocation:</span></span><br><span class="line">        <span class="comment">// method f1 in class CaptureConversion</span></span><br><span class="line">        <span class="comment">// is applied to given types</span></span><br><span class="line">        <span class="comment">//     f1(raw);</span></span><br><span class="line">        <span class="comment">//       ^</span></span><br><span class="line">        <span class="comment">//   required: Holder&lt;T&gt;</span></span><br><span class="line">        <span class="comment">//   found: Holder</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in</span></span><br><span class="line">        <span class="comment">//     method &lt;T&gt;f1(Holder&lt;T&gt;)</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked conversion</span></span><br><span class="line">        <span class="comment">//     f1(raw);</span></span><br><span class="line">        <span class="comment">//        ^</span></span><br><span class="line">        <span class="comment">//   required: Holder&lt;T&gt;</span></span><br><span class="line">        <span class="comment">//   found:    Holder</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in</span></span><br><span class="line">        <span class="comment">//     method &lt;T&gt;f1(Holder&lt;T&gt;)</span></span><br><span class="line">        <span class="comment">// 2 warnings</span></span><br><span class="line">        f2(raw); <span class="comment">// No warnings</span></span><br><span class="line">        </span><br><span class="line">        Holder rawBasic = <span class="keyword">new</span> Holder();</span><br><span class="line">        rawBasic.set(<span class="keyword">new</span> Object());</span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked call to set(T)</span></span><br><span class="line">        <span class="comment">// as a member of the raw type Holder</span></span><br><span class="line">        <span class="comment">//     rawBasic.set(new Object());</span></span><br><span class="line">        <span class="comment">//                 ^</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in class Holder</span></span><br><span class="line">        <span class="comment">// 1 warning</span></span><br><span class="line">        f2(rawBasic); <span class="comment">// No warnings</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Upcast to Holder&lt;?&gt;, still figures it out:</span></span><br><span class="line">        Holder&lt;?&gt; wildcarded = <span class="keyword">new</span> Holder&lt;&gt;(<span class="number">1.0</span>);</span><br><span class="line">        f2(wildcarded);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Integer</span></span><br><span class="line"><span class="comment">Integer</span></span><br><span class="line"><span class="comment">Object</span></span><br><span class="line"><span class="comment">Double</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><code>f1()</code> 中的类型参数都是确切的，没有通配符或边界。在 <code>f2()</code> 中，<strong>Holder</strong> 参数是一个无界通配符，因此它看起来是未知的。但是，在 <code>f2()</code> 中调用了 <code>f1()</code>，而 <code>f1()</code> 需要一个已知参数。这里所发生的是：在调用 <code>f2()</code> 的过程中捕获了参数类型，并在调用 <code>f1()</code> 时使用了这种类型。<strong>**</strong><br>你可能想知道这项技术是否可以用于写入，但是这要求在传递 <code>Holder&lt;?&gt;</code>** 时同时传递一个具体类型。捕获转换只有在这样的情况下可以工作：即在方法内部，你需要使用确切的类型。注意，不能从 <code>f2()</code> 中返回 <strong>T</strong>，因为 *<em>T *</em> 对于 <code>f2()</code> 来说是未知的。捕获转换十分有趣，但是非常受限。</p>
<!-- Issues -->

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>本节将阐述在使用 Java 泛型时会出现的各类问题。</p>
<h3 id="任何基本类型都不能作为类型参数"><a href="#任何基本类型都不能作为类型参数" class="headerlink" title="任何基本类型都不能作为类型参数"></a>任何基本类型都不能作为类型参数</h3><p>正如本章早先提到的，Java 泛型的限制之一是不能将基本类型用作类型参数。因此，不能创建  <code>ArrayList&lt;int&gt;</code> 之类的东西。<br>解决方法是使用基本类型的包装器类以及自动装箱机制。如果创建一个 <code>ArrayList&lt;Integer&gt;</code>，并将基本类型 <strong>int</strong> 应用于这个集合，那么你将发现自动装箱机制将自动地实现 <strong>int</strong> 到 <strong>Integer</strong> 的双向转换——因此，这几乎就像是有一个 <code>ArrayList&lt;int&gt;</code> 一样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ListOfInt.java</span></span><br><span class="line"><span class="comment">// Autoboxing compensates for the inability</span></span><br><span class="line"><span class="comment">// to use primitives in generics</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListOfInt</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; li = IntStream.range(<span class="number">38</span>, <span class="number">48</span>)</span><br><span class="line">            .boxed() <span class="comment">// Converts ints to Integers</span></span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">        System.out.println(li);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[38, 39, 40, 41, 42, 43, 44, 45, 46, 47]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>通常，这种解决方案工作得很好——能够成功地存储和读取 <strong>int</strong>，自动装箱隐藏了转换的过程。但是<strong>如果性能成为问题的话，就需要使用专门为基本类型适配的特殊版本的集合；</strong>一个开源版本的实现是 <strong>org.apache.commons.collections.primitives</strong>。<br>下面是另外一种方式，它可以创建持有 <strong>Byte</strong> 的 <strong>Set</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ByteSet.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteSet</span> </span>&#123;</span><br><span class="line">    Byte[] possibles = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">    Set&lt;Byte&gt; mySet = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(possibles));</span><br><span class="line">    <span class="comment">// But you can't do this:</span></span><br><span class="line">    <span class="comment">// Set&lt;Byte&gt; mySet2 = new HashSet&lt;&gt;(</span></span><br><span class="line">    <span class="comment">// Arrays.&lt;Byte&gt;asList(1,2,3,4,5,6,7,8,9));</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自动装箱机制解决了一些问题，但并没有解决所有问题。</p>
<p>在下面的示例中，<strong>FillArray</strong> 接口包含一些通用方法，这些方法使用 <strong>Supplier</strong> 来用对象填充数组（这使得类泛型在本例中无法工作，因为这个方法是静态的）。<strong>Supplier</strong> 实现来自 <a href="book/21-Arrays.md">数组</a> 一章,并且在 <code>main()</code> 中，可以看到 <code>FillArray.fill()</code> 使用对象填充了数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/PrimitiveGenericTest.java</span></span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fill an array using a generator:</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">FillArray</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; T[] fill(T[] a, Supplier&lt;T&gt; gen) &#123;</span><br><span class="line">        Arrays.setAll(a, n -&gt; gen.get());</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] fill(<span class="keyword">int</span>[] a, IntSupplier gen) &#123;</span><br><span class="line">        Arrays.setAll(a, n -&gt; gen.getAsInt());</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">long</span>[] fill(<span class="keyword">long</span>[] a, LongSupplier gen) &#123;</span><br><span class="line">        Arrays.setAll(a, n -&gt; gen.getAsLong());</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span>[] fill(<span class="keyword">double</span>[] a, DoubleSupplier gen) &#123;</span><br><span class="line">        Arrays.setAll(a, n -&gt; gen.getAsDouble());</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimitiveGenericTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] strings = FillArray.fill(</span><br><span class="line">            <span class="keyword">new</span> String[<span class="number">5</span>], <span class="keyword">new</span> Rand.String(<span class="number">9</span>));</span><br><span class="line">        System.out.println(Arrays.toString(strings));</span><br><span class="line">        <span class="keyword">int</span>[] integers = FillArray.fill(</span><br><span class="line">            <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>], <span class="keyword">new</span> Rand.Pint());</span><br><span class="line">        System.out.println(Arrays.toString(integers));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[btpenpccu, xszgvgmei, nneeloztd, vewcippcy, gpoalkljl]</span></span><br><span class="line"><span class="comment">[635, 8737, 3941, 4720, 6177, 8479, 6656, 3768, 4948]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>自动装箱不适用于数组</strong>，因此我们必须创建 <code>FillArray.fill()</code> 的重载版本，或创建产生 <strong>Wrapped</strong> 输出的生成器。 <strong>FillArray</strong> 仅比 <code>java.util.Arrays.setAll()</code> 有用一点，因为它返回填充的数组。</p>
<h3 id="实现参数化接口"><a href="#实现参数化接口" class="headerlink" title="实现参数化接口"></a>实现参数化接口</h3><p>一个类不能实现同一个泛型接口的两种变体，由于擦除的原因，这两个变体会成为相同的接口。下面是产生这种冲突的情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/MultipleInterfaceVariants.java</span></span><br><span class="line"><span class="comment">// &#123;WillNotCompile&#125;</span></span><br><span class="line"><span class="keyword">package</span> generics;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Payable</span>&lt;<span class="title">T</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Payable</span>&lt;<span class="title">Employee</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hourly</span> <span class="keyword">extends</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Payable</span>&lt;<span class="title">Hourly</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Hourly</strong> 不能编译，因为擦除会将  <code>Payable&lt;Employe&gt;</code> 和 <code>Payable&lt;Hourly&gt;</code> 简化为相同的类 <strong>Payable</strong>，这样，<strong>上面的代码就意味着在重复两次地实现相同的接口。</strong>十分有趣的是，如果从 <strong>Payable</strong> 的两种用法中都移除掉泛型参数（就像编译器在擦除阶段所做的那样）这段代码就可以编译。</p>
<p>在使用某些更基本的 Java 接口，例如 <code>Comparable&lt;T&gt;</code> 时，这个问题可能会变得十分令人恼火，就像你在本节稍后看到的那样。</p>
<h3 id="转型和警告"><a href="#转型和警告" class="headerlink" title="转型和警告"></a>转型和警告</h3><p><strong>使用带有泛型类型参数的转型或 instanceof 不会有任何效果。</strong>下面的集合在内部将各个值存储为 <strong>Object</strong>，并在获取这些值时，再将它们转型回 <strong>T</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/GenericCast.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FixedSizeStack</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> Object[] storage;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    FixedSizeStack(<span class="keyword">int</span> size) &#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        storage = <span class="keyword">new</span> Object[size];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; size)</span><br><span class="line">            storage[index++] = item;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index == <span class="number">0</span> ? <span class="keyword">null</span> : (T)storage[--index];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function">Stream&lt;T&gt; <span class="title">stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Stream&lt;T&gt;)Arrays.stream(storage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericCast</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String[] letters = <span class="string">"ABCDEFGHIJKLMNOPQRS"</span>.split(<span class="string">""</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FixedSizeStack&lt;String&gt; strings =</span><br><span class="line">            <span class="keyword">new</span> FixedSizeStack&lt;&gt;(letters.length);</span><br><span class="line">        Arrays.stream(<span class="string">"ABCDEFGHIJKLMNOPQRS"</span>.split(<span class="string">""</span>))</span><br><span class="line">            .forEach(strings::push);</span><br><span class="line">        System.out.println(strings.pop());</span><br><span class="line">        strings.stream()</span><br><span class="line">            .map(s -&gt; s + <span class="string">" "</span>)</span><br><span class="line">            .forEach(System.out::print);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">S</span></span><br><span class="line"><span class="comment">A B C D E F G H I J K L M N O P Q R S</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>如果没有 <strong>@SuppressWarnings</strong> 注解，编译器将对 <code>pop()</code> 产生 “unchecked cast” 警告。由于擦除的原因，编译器无法知道这个转型是否是安全的，并且 <code>pop()</code> 方法实际上并没有执行任何转型。<br>这是因为，<strong>T</strong> 被擦除到它的第一个边界，默认情况下是 <strong>Object</strong> ，因此 <code>pop()</code> 实际上只是将 <strong>Object</strong> 转型为 <strong>Object</strong>。<br>有时，泛型没有消除对转型的需要，这就会由编译器产生警告，而这个警告是不恰当的。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/NeedCasting.java</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NeedCasting</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">            <span class="keyword">new</span> FileInputStream(args[<span class="number">0</span>]));</span><br><span class="line">        List&lt;Widget&gt; shapes = (List&lt;Widget&gt;)in.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正如你将在 <a href="book/Appendix-Object-Serialization.md">附录：对象序列化</a> 中学到的那样，<code>readObject()</code> 无法知道它正在读取的是什么，因此它返回的是必须转型的对象。但是当注释掉 <strong>@SuppressWarnings</strong> 注解并编译这个程序时，就会得到下面的警告。</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NeedCasting.java uses unchecked <span class="keyword">or</span> unsafe operations.</span><br><span class="line">Recompile <span class="keyword">with</span> -Xlint:unchecked <span class="keyword">for</span> details.</span><br><span class="line"></span><br><span class="line"><span class="keyword">And</span> <span class="keyword">if</span> you follow the instructions <span class="keyword">and</span> recompile <span class="keyword">with</span>  -</span><br><span class="line">Xlint:unchecked :(如果遵循这条指示，使用-Xlint:unchecked来重新编译：)</span><br><span class="line"></span><br><span class="line">NeedCasting.java:<span class="number">10</span>: <span class="built_in">warning</span>: [unchecked] unchecked <span class="keyword">cast</span></span><br><span class="line">    List&lt;Widget&gt; shapes = (List&lt;Widget&gt;)<span class="keyword">in</span>.readObject();</span><br><span class="line">    required: List&lt;Widget&gt;</span><br><span class="line">    <span class="built_in">found</span>: <span class="keyword">Object</span></span><br><span class="line"><span class="number">1</span> <span class="built_in">warning</span></span><br></pre></td></tr></table></figure>

<p>你会被强制要求转型，但是又被告知不应该转型。为了解决这个问题，必须使用 Java 5 引入的新的转型形式，既通过泛型类来转型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ClassCasting.java</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassCasting</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">            <span class="keyword">new</span> FileInputStream(args[<span class="number">0</span>]));</span><br><span class="line">        <span class="comment">// Won't Compile:</span></span><br><span class="line">        <span class="comment">//    List&lt;Widget&gt; lw1 =</span></span><br><span class="line">        <span class="comment">//    List&lt;&gt;.class.cast(in.readObject());</span></span><br><span class="line">        List&lt;Widget&gt; lw2 = List.class.cast(in.readObject());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，不能转型到实际类型（ <code>List&lt;Widget&gt;</code> ）。也就是说，不能声明：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Widget&gt;<span class="selector-class">.class</span><span class="selector-class">.cast</span>(<span class="keyword">in</span>.readobject())</span><br></pre></td></tr></table></figure>

<p>甚至当你添加一个像下面这样的另一个转型时：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">List</span>&lt;Widget&gt;)<span class="built_in">List</span>.<span class="keyword">class</span>.cast(<span class="keyword">in</span>.readobject())</span><br></pre></td></tr></table></figure>

<p>仍旧会得到一个警告。</p>
<h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>下面的程序是不能编译的，即使它看起来是合理的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/UseList.java</span></span><br><span class="line"><span class="comment">// &#123;WillNotCompile&#125;</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseList</span>&lt;<span class="title">W</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(List&lt;T&gt; v)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(List&lt;W&gt; v)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为擦除，所以重载方法产生了的类型签名。</p>
<p>因而，<strong>当擦除后的参数不能产生唯一的参数列表时</strong>，你必须提供不同的方法名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/UseList2.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseList2</span>&lt;<span class="title">W</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(List&lt;T&gt; v)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(List&lt;W&gt; v)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>幸运的是，编译器可以检测到这类问题。</p>
<h3 id="基类劫持接口"><a href="#基类劫持接口" class="headerlink" title="基类劫持接口"></a>基类劫持接口</h3><p>假设你有一个实现了 <strong>Comparable</strong> 接口的 <strong>Pet</strong> 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ComparablePet.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComparablePet</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">ComparablePet</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(ComparablePet o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尝试缩小 <strong>ComparablePet</strong> 子类的比较类型是有意义的。例如，<strong>Cat</strong> 类可以与其他的 <strong>Cat</strong> 比较：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/HijackedInterface.java</span></span><br><span class="line"><span class="comment">// &#123;WillNotCompile&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">ComparablePet</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Cat</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// error: Comparable cannot be inherited with</span></span><br><span class="line">    <span class="comment">// different arguments: &lt;Cat&gt; and &lt;ComparablePet&gt;</span></span><br><span class="line">    <span class="comment">// class Cat</span></span><br><span class="line">    <span class="comment">// ^</span></span><br><span class="line">    <span class="comment">// 1 error</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Cat arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不幸的是，这不能工作。一旦 <strong>Comparable</strong> 的类型参数设置为 <strong>ComparablePet</strong>，其他的实现类只能比较 <strong>ComparablePet</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/RestrictedComparablePets.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hamster</span> <span class="keyword">extends</span> <span class="title">ComparablePet</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">ComparablePet</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(ComparablePet arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Or just:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gecko</span> <span class="keyword">extends</span> <span class="title">ComparablePet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(ComparablePet arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Hamster</strong> 显示了重新实现 <strong>ComparableSet</strong> 中相同的接口是可能的，只要接口完全相同，包括参数类型。然而正如 <strong>Gecko</strong> 中所示，这与直接覆写基类的方法完全相同。</p>
<!-- Don't get it or don't understand -->

<!-- Self-Bounded Types -->

<h2 id="自限定的类型"><a href="#自限定的类型" class="headerlink" title="自限定的类型"></a>自限定的类型</h2><p>在 Java 泛型中，有一个似乎经常性出现的惯用法，它相当令人费解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelfBounded</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123; <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>这就像两面镜子彼此照向对方所引起的目眩效果一样，是一种无限反射。<strong>SelfBounded</strong> 类接受泛型参数 <strong>T</strong>，而 <strong>T</strong> 由一个边界类限定，这个边界就是拥有 <strong>T</strong> 作为其参数的 <strong>SelfBounded</strong>。</p>
<p>当你首次看到它时，很难去解析它，它强调的是当 <strong>extends</strong> 关键字用于边界与用来创建子类明显是不同的。</p>
<h3 id="古怪的循环泛型"><a href="#古怪的循环泛型" class="headerlink" title="古怪的循环泛型"></a>古怪的循环泛型</h3><p>为了理解自限定类型的含义，我们从这个惯用法的一个简单版本入手，它没有自限定的边界。</p>
<p>不能直接继承一个泛型参数，但是，可以继承在其自己的定义中使用这个泛型参数的类。也就是说，可以声明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/CuriouslyRecurringGeneric.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericType</span>&lt;<span class="title">T</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuriouslyRecurringGeneric</span></span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">GenericType</span>&lt;<span class="title">CuriouslyRecurringGeneric</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这可以按照 Jim Coplien 在 C++ 中的<em>古怪的循环模版模式</em>的命名方式，称为古怪的循环泛型（CRG）<strong>。“古怪的循环”是指类相当古怪地出现在它自己的基类中这一事实</strong>。<br>为了理解其含义，努力大声说：“我在创建一个新类，它继承自一个泛型类型，这个泛型类型接受我的类的名字作为其参数。”当给出导出类的名字时，这个泛型基类能够实现什么呢？好吧，Java 中的泛型关乎参数和返回类型，因此它能够产生使用导出类作为其参数和返回类型的基类。它还能将导出类型用作其域类型，尽管这些将被擦除为 <strong>Object</strong> 的类型。下面是表示了这种情况的一个泛型类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/BasicHolder.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicHolder</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T element;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(T arg)</span> </span>&#123; element = arg; &#125;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> element; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(element.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个普通的泛型类型，它的一些方法将接受和产生具有其参数类型的对象，还有一个方法在其存储的域上执行操作（尽管只是在这个域上执行 <strong>Object</strong> 操作）。<br>我们可以在一个古怪的循环泛型中使用 <strong>BasicHolder</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/CRGWithBasicHolder.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subtype</span> <span class="keyword">extends</span> <span class="title">BasicHolder</span>&lt;<span class="title">Subtype</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CRGWithBasicHolder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Subtype st1 = <span class="keyword">new</span> Subtype(), st2 = <span class="keyword">new</span> Subtype();</span><br><span class="line">        st1.set(st2);</span><br><span class="line">        Subtype st3 = st1.get();</span><br><span class="line">        st1.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Subtype</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>注意，这里有些东西很重要：新类 <strong>Subtype</strong> 接受的参数和返回的值具有 <strong>Subtype</strong> 类型而不仅仅是基类 <strong>BasicHolder</strong> 类型。这就是 CRG 的本质：基类用导出类替代其参数。这意味着泛型基类变成了一种其所有导出类的公共功能的模版，但是这些功能对于其所有参数和返回值，将使用导出类型。也就是说，在所产生的类中将使用确切类型而不是基类型。因此，在<strong>Subtype</strong> 中，传递给 <code>set()</code> 的参数和从 <code>get()</code> 返回的类型都是确切的 <strong>Subtype</strong>。</p>
<h3 id="自限定"><a href="#自限定" class="headerlink" title="自限定"></a>自限定</h3><p><strong>BasicHolder</strong> 可以使用任何类型作为其泛型参数，就像下面看到的那样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Unconstrained.java</span></span><br><span class="line"><span class="comment">// (c)2017 MindView LLC: see Copyright.txt</span></span><br><span class="line"><span class="comment">// We make no guarantees that this code is fit for any purpose.</span></span><br><span class="line"><span class="comment">// Visit http://OnJava8.com for more book information.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Other</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasicOther</span> <span class="keyword">extends</span> <span class="title">BasicHolder</span>&lt;<span class="title">Other</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Unconstrained</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BasicOther b = <span class="keyword">new</span> BasicOther();</span><br><span class="line">        BasicOther b2 = <span class="keyword">new</span> BasicOther();</span><br><span class="line">        b.set(<span class="keyword">new</span> Other());</span><br><span class="line">        Other other = b.get();</span><br><span class="line">        b.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Other</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>限定将采取额外的步骤，强制泛型当作其自身的边界参数来使用。观察所产生的类可以如何使用以及不可以如何使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/SelfBounding.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelfBounded</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    T element;</span><br><span class="line">    <span class="function">SelfBounded&lt;T&gt; <span class="title">set</span><span class="params">(T arg)</span> </span>&#123;</span><br><span class="line">        element = arg;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> element; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">A</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">A</span>&gt; </span>&#123;&#125; <span class="comment">// Also OK</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">C</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">C <span class="title">setAndGet</span><span class="params">(C arg)</span> </span>&#123; </span><br><span class="line">        set(arg); </span><br><span class="line">        <span class="keyword">return</span> get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// Can't do this:</span></span><br><span class="line"><span class="comment">// class E extends SelfBounded&lt;D&gt; &#123;&#125;</span></span><br><span class="line"><span class="comment">// Compile error:</span></span><br><span class="line"><span class="comment">//   Type parameter D is not within its bound</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Alas, you can do this, so you cannot force the idiom:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelfBounding</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        a.set(<span class="keyword">new</span> A());</span><br><span class="line">        a = a.set(<span class="keyword">new</span> A()).get();</span><br><span class="line">        a = a.get();</span><br><span class="line">        C c = <span class="keyword">new</span> C();</span><br><span class="line">        c = c.setAndGet(<span class="keyword">new</span> C());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自限定所做的，就是要求在继承关系中，像下面这样使用这个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">A</span>&gt;</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这会强制要求将正在定义的类当作参数传递给基类。</p>
<p>自限定的参数有何意义呢？它可以保证类型参数必须与正在被定义的类相同。正如你在 B 类的定义中所看到的，还可以从使用了另一个 <strong>SelfBounded</strong> 参数的 <strong>SelfBounded</strong> 中导出，尽管在 <strong>A</strong> 类看到的用法看起来是主要的用法。对定义 <strong>E</strong> 的尝试说明不能使用不是 <strong>SelfBounded</strong> 的类型参数。<br>遗憾的是， <strong>F</strong> 可以编译，不会有任何警告，因此自限定惯用法不是可强制执行的。如果它确实很重要，可以要求一个外部工具来确保不会使用原生类型来替代参数化类型。<br>注意，可以移除自限定这个限制，这样所有的类仍旧是可以编译的，但是 <strong>E</strong> 也会因此而变得可编译：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/NotSelfBounded.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotSelfBounded</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T element;</span><br><span class="line">    <span class="function">NotSelfBounded&lt;T&gt; <span class="title">set</span><span class="params">(T arg)</span> </span>&#123;</span><br><span class="line">        element = arg;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> element; &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A2</span> <span class="keyword">extends</span> <span class="title">NotSelfBounded</span>&lt;<span class="title">A2</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B2</span> <span class="keyword">extends</span> <span class="title">NotSelfBounded</span>&lt;<span class="title">A2</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C2</span> <span class="keyword">extends</span> <span class="title">NotSelfBounded</span>&lt;<span class="title">C2</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">C2 <span class="title">setAndGet</span><span class="params">(C2 arg)</span> </span>&#123; </span><br><span class="line">        set(arg); </span><br><span class="line">        <span class="keyword">return</span> get(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// Now this is OK:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E2</span> <span class="keyword">extends</span> <span class="title">NotSelfBounded</span>&lt;<span class="title">D2</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>因此很明显，自限定限制只能强制作用于继承关系。如果使用自限定，就应该了解这个类所用的类型参数将与使用这个参数的类具有相同的基类型。这会强制要求使用这个类的每个人都要遵循这种形式。<br>还可以将自限定用于泛型方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/SelfBoundingMethods.java</span></span><br><span class="line"><span class="comment">// (c)2017 MindView LLC: see Copyright.txt</span></span><br><span class="line"><span class="comment">// We make no guarantees that this code is fit for any purpose.</span></span><br><span class="line"><span class="comment">// Visit http://OnJava8.com for more book information.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelfBoundingMethods</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T extends SelfBounded&lt;T&gt;&gt; <span class="function">T <span class="title">f</span><span class="params">(T arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arg.set(arg).get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = f(<span class="keyword">new</span> A());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这<strong>可以防止这个方法被应用于除上述形式的自限定参数之外的任何事物上。</strong></p>
<h3 id="参数协变"><a href="#参数协变" class="headerlink" title="参数协变"></a>参数协变</h3><p>自限定类型的价值在于它们可以产生<em>协变参数类型</em>——方法参数类型会随子类而变化。</p>
<p>尽管自限定类型还可以产生与子类类型相同的返回类型，但是这并不十分重要，因为<em>协变返回类型</em>是在 Java 5 引入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/CovariantReturnTypes.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">OrdinaryGetter</span> </span>&#123;</span><br><span class="line">    <span class="function">Base <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">DerivedGetter</span> <span class="keyword">extends</span> <span class="title">OrdinaryGetter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Overridden method return type can vary:</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Derived <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CovariantReturnTypes</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(DerivedGetter d)</span> </span>&#123;</span><br><span class="line">        Derived d2 = d.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>DerivedGetter</strong> 中的 <code>get()</code> 方法覆盖了 <strong>OrdinaryGetter</strong> 中的 <code>get()</code> ，并返回了一个从 <code>OrdinaryGetter.get()</code> 的返回类型中导出的类型。尽管这是完全合乎逻辑的事情（导出类方法应该能够返回比它覆盖的基类方法更具体的类型）但是这在早先的 Java 版本中是不合法的。</p>
<p>自限定泛型事实上将产生确切的导出类型作为其返回值，就像在 <code>get()</code> 中所看到的一样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/GenericsAndReturnTypes.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GenericGetter</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">GenericGetter</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Getter</span> <span class="keyword">extends</span> <span class="title">GenericGetter</span>&lt;<span class="title">Getter</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsAndReturnTypes</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(Getter g)</span> </span>&#123;</span><br><span class="line">        Getter result = g.get();</span><br><span class="line">        GenericGetter gg = g.get(); <span class="comment">// Also the base type</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，这段代码不能编译，除非是使用囊括了协变返回类型的 Java 5。</p>
<p>然而，在非泛型代码中，参数类型不能随子类型发生变化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/OrdinaryArguments.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrdinarySetter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(Base base)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"OrdinarySetter.set(Base)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedSetter</span> <span class="keyword">extends</span> <span class="title">OrdinarySetter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(Derived derived)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"DerivedSetter.set(Derived)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrdinaryArguments</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Base base = <span class="keyword">new</span> Base();</span><br><span class="line">        Derived derived = <span class="keyword">new</span> Derived();</span><br><span class="line">        DerivedSetter ds = <span class="keyword">new</span> DerivedSetter();</span><br><span class="line">        ds.set(derived);</span><br><span class="line">        <span class="comment">// Compiles--overloaded, not overridden!:</span></span><br><span class="line">        ds.set(base);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">DerivedSetter.set(Derived)</span></span><br><span class="line"><span class="comment">OrdinarySetter.set(Base)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><code>set(derived)</code> 和 <code>set(base)</code> 都是合法的，因此 <code>DerivedSetter.set()</code> 没有覆盖 <code>OrdinarySetter.set()</code> ，而是重载了这个方法。从输出中可以看到，在 <strong>DerivedSetter</strong> 中有两个方法，因此基类版本仍旧是可用的，因此可以证明它被重载过。<br>但是，在使用自限定类型时，在导出类中只有一个方法，并且这个方法接受导出类型而不是基类型为参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/SelfBoundingAndCovariantArguments.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SelfBoundSetter</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">SelfBoundSetter</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(T arg)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Setter</span> <span class="keyword">extends</span> <span class="title">SelfBoundSetter</span>&lt;<span class="title">Setter</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelfBoundingAndCovariantArguments</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span></span><br><span class="line">    testA(Setter s1, Setter s2, SelfBoundSetter sbs) &#123;</span><br><span class="line">        s1.set(s2);</span><br><span class="line">        <span class="comment">//- s1.set(sbs);</span></span><br><span class="line">        <span class="comment">// error: method set in interface SelfBoundSetter&lt;T&gt;</span></span><br><span class="line">        <span class="comment">// cannot be applied to given types;</span></span><br><span class="line">        <span class="comment">//     s1.set(sbs);</span></span><br><span class="line">        <span class="comment">//       ^</span></span><br><span class="line">        <span class="comment">//   required: Setter</span></span><br><span class="line">        <span class="comment">//   found: SelfBoundSetter</span></span><br><span class="line">        <span class="comment">//   reason: argument mismatch;</span></span><br><span class="line">        <span class="comment">// SelfBoundSetter cannot be converted to Setter</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends SelfBoundSetter&lt;T&gt; declared in</span></span><br><span class="line">        <span class="comment">//     interface SelfBoundSetter</span></span><br><span class="line">        <span class="comment">// 1 error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器不能识别将基类型当作参数传递给 <code>set()</code> 的尝试，因为没有任何方法具有这样的签名。实际上，这个参数已经被覆盖。<br>如果不使用自限定类型，普通的继承机制就会介入，而你将能够重载，就像在非泛型的情况下一样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/PlainGenericInheritance.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericSetter</span>&lt;<span class="title">T</span>&gt; </span>&#123; <span class="comment">// Not self-bounded</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(T arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"GenericSetter.set(Base)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedGS</span> <span class="keyword">extends</span> <span class="title">GenericSetter</span>&lt;<span class="title">Base</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(Derived derived)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"DerivedGS.set(Derived)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlainGenericInheritance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Base base = <span class="keyword">new</span> Base();</span><br><span class="line">        Derived derived = <span class="keyword">new</span> Derived();</span><br><span class="line">        DerivedGS dgs = <span class="keyword">new</span> DerivedGS();</span><br><span class="line">        dgs.set(derived);</span><br><span class="line">        dgs.set(base); <span class="comment">// Overloaded, not overridden!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">DerivedGS.set(Derived)</span></span><br><span class="line"><span class="comment">GenericSetter.set(Base)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>这段代码在模仿 <strong>OrdinaryArguments.java</strong>；在那个示例中，<strong>DerivedSetter</strong> 继承自包含一个 <code>set(Base)</code> 的<strong>OrdinarySetter</strong> 。而这里，<strong>DerivedGS</strong> 继承自泛型创建的也包含有一个 <code>set(Base)</code>的 <code>GenericSetter&lt;Base&gt;</code>。就像 <strong>OrdinaryArguments.java</strong> 一样，你可以从输出中看到， <strong>DerivedGS</strong> 包含两个  <code>set()</code> 的重载版本。如果不使用自限定，将重载参数类型。如果使用了自限定，只能获得方法的一个版本，它将接受确切的参数类型。</p>
<!-- Dynamic Type Safety -->

<h2 id="动态类型安全"><a href="#动态类型安全" class="headerlink" title="动态类型安全"></a>动态类型安全</h2><p>因为可以向 Java 5 之前的代码传递泛型集合，所以旧式代码仍旧有可能会破坏你的集合。Java 5 的 <strong>java.util.Collections</strong> 中有一组便利工具，可以解决在这种情况下的类型检查问题，它们是：静态方法 <code>checkedCollection()</code> 、<code>checkedList()</code>、 <code>checkedMap()</code> 、 <code>checkedSet()</code> 、<code>checkedSortedMap()</code>和 <code>checkedSortedSet()</code>。<strong>这些方法每一个都会将你希望动态检查的集合当作第一个参数接受，并将你希望强制要求的类型作为第二个参数接受。</strong></p>
<p>受检查的集合在你试图插入类型不正确的对象时抛出 <strong>ClassCastException</strong> ，这与泛型之前的（原生）集合形成了对比，对于后者来说，当你将对象从集合中取出时，才会通知你出现了问题。在后一种情况中，你知道存在问题，但是不知道罪魁祸首在哪里，如果使用受检查的集合，就可以发现谁在试图插入不良对象。<br>让我们用受检查的集合来看看“将猫插入到狗列表中”这个问题。这里，<code>oldStyleMethod()</code> 表示遗留代码，因为它接受的是原生的 <strong>List</strong> ，而 <strong>@SuppressWarnings（“unchecked”）</strong> 注解对于压制所产生的警告是必需的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/CheckedList.java</span></span><br><span class="line"><span class="comment">// Using Collection.checkedList()</span></span><br><span class="line"><span class="keyword">import</span> typeinfo.pets.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckedList</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">oldStyleMethod</span><span class="params">(List probablyDogs)</span> </span>&#123;</span><br><span class="line">        probablyDogs.add(<span class="keyword">new</span> Cat());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Dog&gt; dogs1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        oldStyleMethod(dogs1); <span class="comment">// Quietly accepts a Cat</span></span><br><span class="line">        List&lt;Dog&gt; dogs2 = Collections.checkedList(</span><br><span class="line">            <span class="keyword">new</span> ArrayList&lt;&gt;(), Dog.class);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oldStyleMethod(dogs2); <span class="comment">// Throws an exception</span></span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Expected: "</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Derived types work fine:</span></span><br><span class="line">        List&lt;Pet&gt; pets = Collections.checkedList(</span><br><span class="line">            <span class="keyword">new</span> ArrayList&lt;&gt;(), Pet.class);</span><br><span class="line">        pets.add(<span class="keyword">new</span> Dog());</span><br><span class="line">        pets.add(<span class="keyword">new</span> Cat());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Expected: java.lang.ClassCastException: Attempt to</span></span><br><span class="line"><span class="comment">insert class typeinfo.pets.Cat element into collection</span></span><br><span class="line"><span class="comment">with element type class typeinfo.pets.Dog</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>运行这个程序时，你会发现插入一个 <strong>Cat</strong> 对于 <strong>dogs1</strong> 来说没有任何问题，而 <strong>dogs2</strong> 立即会在这个错误类型的插入操作上抛出一个异常。还可以看到，将导出类型的对象放置到将要检查基类型的受检查容器中是没有问题的。</p>
<!-- skip -->

<!-- Mixins -->

<h2 id="混型"><a href="#混型" class="headerlink" title="混型"></a>混型</h2><p>术语<em>混型<em>随时间的推移好像拥有了无数的含义，但是其最基本的概念是混合多个类的能力，以产生一个可以表示混型中所有类型的类。这往往是你最后的手段，它将使组装多个类变得简单易行。<br>混型的价值之一是它们可以将特性和行为一致地应用于多个类之上。如果想在混型类中修改某些东西，作为一种意外的好处，这些修改将会应用于混型所应用的所有类型之上。正由于此，混型有一点</em>面向切面编程</em> （AOP） 的味道，而切面经常被建议用来解决混型问题。</p>
<h3 id="C-中的混型"><a href="#C-中的混型" class="headerlink" title="C++ 中的混型"></a>C++ 中的混型</h3><p>在 C++ 中，使用多重继承的最大理由，就是为了使用混型。但是，对于混型来说，更有趣、更优雅的方式是使用参数化类型，因为混型就是继承自其类型参数的类。在 C++ 中，可以很容易地创建混型，因为 C++ 能够记住其模版参数的类型。<br>下面是一个 C++ 示例，它有两个混型类型：一个使得你可以在每个对象中混入拥有一个时间戳这样的属性，而另一个可以混入一个序列号。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Mixins.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">TimeStamped</span> :</span> <span class="keyword">public</span> T &#123;</span><br><span class="line">    <span class="keyword">long</span> timeStamp;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TimeStamped() &#123; timeStamp = time(<span class="number">0</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getStamp</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> timeStamp; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">SerialNumbered</span> :</span> <span class="keyword">public</span> T &#123;</span><br><span class="line">    <span class="keyword">long</span> serialNumber;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">long</span> counter;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SerialNumbered() &#123; serialNumber = counter++; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getSerialNumber</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> serialNumber; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Define and initialize the static storage:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">long</span> <span class="title">SerialNumbered</span>&lt;T&gt;:</span>:counter = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Basic</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="built_in">string</span> val)</span> </span>&#123; value = val; &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TimeStamped&lt;SerialNumbered&lt;Basic&gt;&gt; mixin1, mixin2;</span><br><span class="line">    mixin1.<span class="built_in">set</span>(<span class="string">"test string 1"</span>);</span><br><span class="line">    mixin2.<span class="built_in">set</span>(<span class="string">"test string 2"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mixin1.get() &lt;&lt; <span class="string">" "</span> &lt;&lt; mixin1.getStamp() &lt;&lt;</span><br><span class="line">      <span class="string">" "</span> &lt;&lt; mixin1.getSerialNumber() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mixin2.get() &lt;&lt; <span class="string">" "</span> &lt;&lt; mixin2.getStamp() &lt;&lt;</span><br><span class="line">      <span class="string">" "</span> &lt;&lt; mixin2.getSerialNumber() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">test string 1 1452987605 1</span></span><br><span class="line"><span class="comment">test string 2 1452987605 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>在 <code>main()</code> 中， <strong>mixin1</strong> 和 <strong>mixin2</strong> 所产生的类型拥有所混入类型的所有方法。可以将混型看作是一种功能，它可以将现有类映射到新的子类上。注意，使用这种技术来创建一个混型是多么的轻而易举。基本上，只需要声明“这就是我想要的”，紧跟着它就发生了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TimeStamped&lt;SerialNumbered&lt;Basic&gt;&gt; mixin1，mixin2；</span><br></pre></td></tr></table></figure>

<p><strong>遗憾的是，Java 泛型不允许这样。擦除会忘记基类类型，因此</strong></p>
<blockquote>
<p><strong>泛型类不能直接继承自一个泛型参数</strong></p>
</blockquote>
<p>这突显了许多我在 Java 语言设计决策（以及与这些功能一起发布）中遇到的一大问题：处理一件事很有希望，但是当您实际尝试做一些有趣的事情时，您会发现自己做不到。</p>
<h3 id="与接口混合"><a href="#与接口混合" class="headerlink" title="与接口混合"></a>与接口混合</h3><p>一种更常见的推荐解决方案是使用接口来产生混型效果，就像下面这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Mixins.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TimeStamped</span> </span>&#123; <span class="function"><span class="keyword">long</span> <span class="title">getStamp</span><span class="params">()</span></span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeStampedImp</span> <span class="keyword">implements</span> <span class="title">TimeStamped</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timeStamp;</span><br><span class="line">    TimeStampedImp() &#123;</span><br><span class="line">        timeStamp = <span class="keyword">new</span> Date().getTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getStamp</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> timeStamp; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SerialNumbered</span> </span>&#123; <span class="function"><span class="keyword">long</span> <span class="title">getSerialNumber</span><span class="params">()</span></span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SerialNumberedImp</span> <span class="keyword">implements</span> <span class="title">SerialNumbered</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> serialNumber = counter++;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getSerialNumber</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> serialNumber; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Basic</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(String val)</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasicImp</span> <span class="keyword">implements</span> <span class="title">Basic</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String val)</span> </span>&#123; value = val; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mixin</span> <span class="keyword">extends</span> <span class="title">BasicImp</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">TimeStamped</span>, <span class="title">SerialNumbered</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TimeStamped timeStamp = <span class="keyword">new</span> TimeStampedImp();</span><br><span class="line">    <span class="keyword">private</span> SerialNumbered serialNumber =</span><br><span class="line">        <span class="keyword">new</span> SerialNumberedImp();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getStamp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> timeStamp.getStamp();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getSerialNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> serialNumber.getSerialNumber();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mixins</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Mixin mixin1 = <span class="keyword">new</span> Mixin(), mixin2 = <span class="keyword">new</span> Mixin();</span><br><span class="line">        mixin1.set(<span class="string">"test string 1"</span>);</span><br><span class="line">        mixin2.set(<span class="string">"test string 2"</span>);</span><br><span class="line">        System.out.println(mixin1.get() + <span class="string">" "</span> +</span><br><span class="line">            mixin1.getStamp() +  <span class="string">" "</span> + mixin1.getSerialNumber());</span><br><span class="line">        System.out.println(mixin2.get() + <span class="string">" "</span> +</span><br><span class="line">            mixin2.getStamp() +  <span class="string">" "</span> + mixin2.getSerialNumber());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">test string 1 1494331663026 1</span></span><br><span class="line"><span class="comment">test string 2 1494331663027 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>Mixin</strong> 类基本上是在使用<em>委托</em>，因此每个混入类型都要求在 <strong>Mixin</strong> 中有一个相应的域，而你必须在 <strong>Mixin</strong> 中编写所有必需的方法，将方法调用转发给恰当的对象。这个示例使用了非常简单的类，但是当使用更复杂的混型时，代码数量会急速增加。</p>
<h3 id="使用装饰器模式"><a href="#使用装饰器模式" class="headerlink" title="使用装饰器模式"></a>使用装饰器模式</h3><p>当你观察混型的使用方式时，就会发现混型概念好像与<strong><em>装饰器</em>设计模式关系很近。</strong>装饰器经常用于满足各种可能的组合，而直接子类化会产生过多的类，因此是不实际的。<br>装饰器模式使用分层对象来动态透明地向单个对象中添加责任。装饰器指定包装在最初的对象周围的所有对象都具有相同的基本接口。某些事物是可装饰的，可以通过将其他类包装在这个可装饰对象的四周，来将功能分层。这使得对装饰器的使用是透明的——无论对象是否被装饰，你都拥有一个可以向对象发送的公共消息集。装饰类也可以添加新方法，但是正如你所见，这将是受限的。<br>装饰器是通过使用组合和形式化结构（可装饰物/装饰器层次结构）来实现的，而混型是基于继承的。因此可以将基于参数化类型的混型当作是一种泛型装饰器机制，这种机制不需要装饰器设计模式的继承结构。<br>前面的示例可以被改写为使用装饰器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/decorator/Decoration.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;java generics.decorator.Decoration&#125;</span></span><br><span class="line"><span class="keyword">package</span> generics.decorator;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Basic</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String val)</span> </span>&#123; value = val; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">extends</span> <span class="title">Basic</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Basic basic;</span><br><span class="line">    Decorator(Basic basic) &#123; <span class="keyword">this</span>.basic = basic; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String val)</span> </span>&#123; basic.set(val); &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> basic.get(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeStamped</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timeStamp;</span><br><span class="line">    TimeStamped(Basic basic) &#123;</span><br><span class="line">        <span class="keyword">super</span>(basic);</span><br><span class="line">        timeStamp = <span class="keyword">new</span> Date().getTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getStamp</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> timeStamp; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SerialNumbered</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> serialNumber = counter++;</span><br><span class="line">    SerialNumbered(Basic basic) &#123; <span class="keyword">super</span>(basic); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getSerialNumber</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> serialNumber; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decoration</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TimeStamped t = <span class="keyword">new</span> TimeStamped(<span class="keyword">new</span> Basic());</span><br><span class="line">        TimeStamped t2 = <span class="keyword">new</span> TimeStamped(</span><br><span class="line">            <span class="keyword">new</span> SerialNumbered(<span class="keyword">new</span> Basic()));</span><br><span class="line">        <span class="comment">//- t2.getSerialNumber(); // Not available</span></span><br><span class="line">        SerialNumbered s = <span class="keyword">new</span> SerialNumbered(<span class="keyword">new</span> Basic());</span><br><span class="line">        SerialNumbered s2 = <span class="keyword">new</span> SerialNumbered(</span><br><span class="line">            <span class="keyword">new</span> TimeStamped(<span class="keyword">new</span> Basic()));</span><br><span class="line">        <span class="comment">//- s2.getStamp(); // Not available</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>产生自泛型的类包含所有感兴趣的方法，但是由使用装饰器所产生的对象类型是最后被装饰的类型。也就是说，尽管可以添加多个层，但是最后一层才是实际的类型，因此只有最后一层的方法是可视的，而混型的类型是所有被混合到一起的类型。因此对于装饰器来说，其明显的缺陷是它只能有效地工作于装饰中的一层（最后一层），而混型方法显然会更自然一些。因此，装饰器只是对由混型提出的问题的一种局限的解决方案。</p>
<h3 id="与动态代理混合"><a href="#与动态代理混合" class="headerlink" title="与动态代理混合"></a>与动态代理混合</h3><p>可以使用动态代理来创建一种比装饰器更贴近混型模型的机制（查看 <a href="book/19-Type-Information.md">类型信息</a> 一章中关于 Java 的动态代理如何工作的解释）。通过使用动态代理，所产生的类的动态类型将会是已经混入的组合类型。<br>由于动态代理的限制，每个被混入的类都必须是某个接口的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/DynamicProxyMixin.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> onjava.Tuple.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MixinProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; delegatesByMethod;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    MixinProxy(Tuple2&lt;Object, Class&lt;?&gt;&gt;... pairs) &#123;</span><br><span class="line">        delegatesByMethod = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Tuple2&lt;Object, Class&lt;?&gt;&gt; pair : pairs) &#123;</span><br><span class="line">            <span class="keyword">for</span>(Method method : pair.a2.getMethods()) &#123;</span><br><span class="line">                String methodName = method.getName();</span><br><span class="line">                <span class="comment">// The first interface in the map</span></span><br><span class="line">                <span class="comment">// implements the method.</span></span><br><span class="line">                <span class="keyword">if</span>(!delegatesByMethod.containsKey(methodName))</span><br><span class="line">                    delegatesByMethod.put(methodName, pair.a1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method,</span></span></span><br><span class="line"><span class="function"><span class="params">      Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        String methodName = method.getName();</span><br><span class="line">        Object delegate = delegatesByMethod.get(methodName);</span><br><span class="line">        <span class="keyword">return</span> method.invoke(delegate, args);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newInstance</span><span class="params">(Tuple2... pairs)</span> </span>&#123;</span><br><span class="line">        Class[] interfaces = <span class="keyword">new</span> Class[pairs.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pairs.length; i++) &#123;</span><br><span class="line">            interfaces[i] = (Class)pairs[i].a2;</span><br><span class="line">        &#125;</span><br><span class="line">        ClassLoader cl = pairs[<span class="number">0</span>].a1.getClass().getClassLoader();</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(cl, interfaces, <span class="keyword">new</span> MixinProxy(pairs));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyMixin</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object mixin = MixinProxy.newInstance(</span><br><span class="line">          tuple(<span class="keyword">new</span> BasicImp(), Basic.class),</span><br><span class="line">          tuple(<span class="keyword">new</span> TimeStampedImp(), TimeStamped.class),</span><br><span class="line">          tuple(<span class="keyword">new</span> SerialNumberedImp(), SerialNumbered.class));</span><br><span class="line">        Basic b = (Basic)mixin;</span><br><span class="line">        TimeStamped t = (TimeStamped)mixin;</span><br><span class="line">        SerialNumbered s = (SerialNumbered)mixin;</span><br><span class="line">        b.set(<span class="string">"Hello"</span>);</span><br><span class="line">        System.out.println(b.get());</span><br><span class="line">        System.out.println(t.getStamp());</span><br><span class="line">        System.out.println(s.getSerialNumber());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Hello</span></span><br><span class="line"><span class="comment">1494331653339</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>因为只有动态类型而不是静态类型才包含所有的混入类型，因此这仍旧不如 C++ 的方式好，因为可以在具有这些类型的对象上调用方法之前，你被强制要求必须先将这些对象向下转型到恰当的类型。但是，它明显地更接近于真正的混型。<br>为了让 Java 支持混型，人们已经做了大量的工作朝着这个目标努力，包括创建了至少一种附加语言（ Jam 语言），它是专门用来支持混型的。</p>
<!-- Latent Typing -->

<h2 id="潜在类型机制"><a href="#潜在类型机制" class="headerlink" title="潜在类型机制"></a>潜在类型机制</h2><p>在本章的开头介绍过这样的思想，即要编写能够尽可能广泛地应用的代码。为了实现这一点，<strong>我们需要各种途径来放松对我们的代码将要作用的类型所作的限制，同时不丢失静态类型检查的好处。</strong>然后，我们就可以编写出无需修改就可以应用于更多情况的代码，即更加“泛化”的代码。</p>
<p>Java 泛型看起来是向这一方向迈进了一步。当你在编写或使用只是持有对象的泛型时，这些代码将可以工作于任何类型（除了基本类型，尽管正如你所见到的，自动装箱机制可以克服这一点）。或者，换个角度讲，“持有器”泛型能够声明：“我不关心你是什么类型”。如果代码不关心它将要作用的类型，那么这种代码就可以真正地应用于任何地方，并因此而相当泛化。</p>
<p>还是正如你所见到的，当要在泛型类型上执行操作（即调用 <strong>Object</strong> 方法之外的方法）时，就会产生问题。<strong>擦除强制要求指定可能会用到的泛型类型的边界，以安全地调用代码中的泛型对象上的具体方法。这是对“泛化”概念的一种明显的限制，因为必须限制你的泛型类型，使它们继承自特定的类，或者实现特定的接口。</strong>在某些情况下，你最终可能会使用普通类或普通接口，因为限定边界的泛型可能会和指定类或接口没有任何区别。</p>
<p>某些编程语言提供的一种<strong>解决方案称为<em>潜在类型机制</em>或<em>结构化类型机制</em>，而更古怪的术语称为<em>鸭子类型机制</em>，</strong>即“如果它走起来像鸭子，并且叫起来也像鸭子，那么你就可以将它当作鸭子对待。”鸭子类型机制变成了一种相当流行的术语，可能是因为它不像其他的术语那样承载着历史的包袱。</p>
<p>泛型代码典型地只能在泛型类型上调用少量方法，而具有潜在类型机制的语言只要求实现某个方法子集，而不是某个特定类或接口，从而放松了这种限制（并且可以产生更加泛化的代码）。正由于此，潜在类型机制使得你可以横跨类继承结构，调用不属于某个公共接口的方法。因此，实际上一段代码可以声明：“我不关心你是什么类型，只要你可以 <code>speak()</code> 和 <code>sit()</code> 即可。”由于不要求具体类型，因此代码就可以更加泛化。</p>
<p><strong>潜在类型机制是一种代码组织和复用机制。有了它，编写出的代码相对于没有它编写出的代码，能够更容易地复用。</strong>代码组织和复用是所有计算机编程的基本手段：编写一次，多次使用，并在一个位置保存代码。因为我并未被要求去命名我的代码要操作于其上的确切接口，所以，有了潜在类型机制，我就可以编写更少的代码，并更容易地将其应用于多个地方。</p>
<p>支持潜在类型机制的语言包括 Python（可以从 <a href="http://www.Python.org" target="_blank" rel="noopener">www.Python.org</a> 免费下载）、C++、Ruby、SmallTalk 和 Go。Python 是动态类型语言（几乎所有的类型检查都发生在运行时），而 C++ 和 Go 是静态类型语言（类型检查发生在编译期），因此潜在类型机制不要求静态或动态类型检查。</p>
<h3 id="pyhton-中的潜在类型"><a href="#pyhton-中的潜在类型" class="headerlink" title="pyhton 中的潜在类型"></a>pyhton 中的潜在类型</h3><p>如果我们将上面的描述用 Python 来表示，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># generics/DogsAndRobots.py</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Arf!"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sit</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Sitting"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reproduce</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Robot</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Click!"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sit</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Clank!"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">oilChange</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">perform</span><span class="params">(anything)</span>:</span></span><br><span class="line">    anything.speak()</span><br><span class="line">    anything.sit()</span><br><span class="line"></span><br><span class="line">a = Dog()</span><br><span class="line">b = Robot()</span><br><span class="line">perform(a)</span><br><span class="line">perform(b)</span><br><span class="line"></span><br><span class="line">output = <span class="string">"""</span></span><br><span class="line"><span class="string">Arf!</span></span><br><span class="line"><span class="string">Sitting</span></span><br><span class="line"><span class="string">Click!</span></span><br><span class="line"><span class="string">Clank!</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<p>Python 使用缩进来确定作用域（因此不需要任何花括号），而冒号将表示新的作用域的开始。“<strong>#</strong>” 表示注释到行尾，就像Java中的 “ <strong>//</strong> ”。类的方法需要显式地指定 <strong>this</strong> 引用的等价物作为第一个参数，按惯例成为 <strong>self</strong> 。构造器调用不要求任何类型的“ <strong>new</strong> ”关键字，并且 Python 允许普通（非成员）函数，就像 <code>perform()</code> 所表明的那样。注意，在 <code>perform(anything)</code> 中，没有任何针对 <strong>anything</strong> 的类型，<strong>anything</strong> 只是一个标识符，它必须能够执行 <code>perform()</code> 期望它执行的操作，因此这里隐含着一个接口。但是你从来都不必显式地写出这个接口——它是潜在的。<code>perform()</code> 不关心其参数的类型，因此我可以向它传递任何对象，只要该对象支持  <code>speak()</code> 和 <code>sit()</code> 方法。如果传递给 <code>perform()</code> 的对象不支持这些操作，那么将会得到运行时异常。</p>
<p>输出规定使用三重引号创建带有内嵌换行符的字符串。</p>
<h3 id="C-中的潜在类型"><a href="#C-中的潜在类型" class="headerlink" title="C++ 中的潜在类型"></a>C++ 中的潜在类型</h3><p>我们可以用 C++ 产生相同的效果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/DogsAndRobots.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Arf!"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sit</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Sitting"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reproduce</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Robot</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Click!"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sit</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Clank!"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">oilChange</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">perform</span>(<span class="title">T</span> <span class="title">anything</span>) &#123;</span></span><br><span class="line">    anything.speak();</span><br><span class="line">    anything.sit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Dog d;</span><br><span class="line">    Robot r;</span><br><span class="line">    perform(d);</span><br><span class="line">    perform(r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Arf!</span></span><br><span class="line"><span class="comment">Sitting</span></span><br><span class="line"><span class="comment">Click!</span></span><br><span class="line"><span class="comment">Clank!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>在 Python 和 C++ 中，<strong>Dog</strong> 和 <strong>Robot</strong> 没有任何共同的东西，只是碰巧有两个方法具有相同的签名。从类型的观点看，它们是完全不同的类型。但是，<code>perform()</code> 不关心其参数的具体类型，并且潜在类型机制允许它接受这两种类型的对象。<br>C++ 确保了它实际上可以发送的那些消息，如果试图传递错误类型，编译器就会给你一个错误消息（这些错误消息从历史上看是相当可怕和冗长的，是 C++ 的模版名声欠佳的主要原因）。尽管它们是在不同时期实现这一点的<strong>，C++ 在编译期，而 Python 在运行时，但是这两种语言都可以确保类型不会被误用，因此被认为是强类型的。潜在类型机制没有损害强类型机制。</strong></p>
<h3 id="Go-中的潜在类型"><a href="#Go-中的潜在类型" class="headerlink" title="Go 中的潜在类型"></a>Go 中的潜在类型</h3><p>这里用 Go 语言编写相同的程序：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/dogsandrobots.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this Dog)</span> <span class="title">speak</span><span class="params">()</span></span> &#123; fmt.Printf(<span class="string">"Arf!\n"</span>)&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this Dog)</span> <span class="title">sit</span><span class="params">()</span></span> &#123; fmt.Printf(<span class="string">"Sitting\n"</span>)&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this Dog)</span> <span class="title">reproduce</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Robot <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this Robot)</span> <span class="title">speak</span><span class="params">()</span></span> &#123; fmt.Printf(<span class="string">"Click!\n"</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this Robot)</span> <span class="title">sit</span><span class="params">()</span></span> &#123; fmt.Printf(<span class="string">"Clank!\n"</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this Robot)</span> <span class="title">oilChange</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">perform</span><span class="params">(speaker <span class="keyword">interface</span> &#123; speak()</span>; <span class="title">sit</span><span class="params">()</span> &#125;)</span> &#123;</span><br><span class="line">  speaker.speak();</span><br><span class="line">  speaker.sit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  perform(Dog&#123;&#125;)</span><br><span class="line">  perform(Robot&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Arf!</span></span><br><span class="line"><span class="comment">Sitting</span></span><br><span class="line"><span class="comment">Click!</span></span><br><span class="line"><span class="comment">Clank!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>Go 没有 <strong>class</strong> 关键字，但是可以使用上述形式创建等效的基本类：它通常不定义为类，而是定义为 <strong>struct</strong> ，在其中定义数据字段（此处不存在）。 对于每种方法，都以 <strong>func</strong> 关键字开头，然后（为了将该方法附加到您的类上）放在括号中，该括号包含对象引用，该对象引用可以是任何标识符，但是我在这里使用 <strong>this</strong> 来提醒您，就像在 C ++ 或 Java 中的 <strong>this</strong> 一样。 然后，在Go中像这样定义其余的函数。</p>
<p>Go也没有继承关系，因此这种“面向对象的目标”形式是相对原始的，并且可能是我无法花更多的时间来学习该语言的主要原因。 但是，Go 的组成很简单。</p>
<p><code>perform()</code> 函数使用潜在类型：参数的确切类型并不重要，只要它包含了 <code>speak()</code> 和  <code>sit()</code> 方法即可。 该接口在此处匿名定义，内联，如 <code>perform()</code> 的参数列表所示。</p>
<p><code>main()</code> 证明 <code>perform()</code> 确实对其参数的确切类型不在乎，只要可以在该参数上调用 <code>talk()</code> 和 <code>sit()</code> 即可。 但是，就像 C ++ 模板函数一样，在编译时检查类型。</p>
<p>语法 <strong>Dog {}</strong> 和 <strong>Robot {}</strong> 创建匿名的 <strong>Dog</strong> 和 <strong>Robot</strong> 结构。</p>
<h3 id="java中的直接潜在类型"><a href="#java中的直接潜在类型" class="headerlink" title="java中的直接潜在类型"></a>java中的直接潜在类型</h3><p>因为泛型是在这场竞赛的后期才添加到 Java 中，因此没有任何机会可以去实现任何类型的潜在类型机制，因此 Java 没有对这种特性的支持。所以，初看起来，<strong>Java 的泛型机制比支持潜在类型机制的语言更“缺乏泛化性”。（使用擦除来实现 Java 泛型的实现有时称为第二类泛型类型）</strong>例如，在 Java 8  之前如果我们试图用 Java 实现上面 dogs-and-robots 的示例，那么就会被强制要求使用一个类或接口，并在边界表达式中指定它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Performs.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Performs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sit</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/DogsAndRobots.java</span></span><br><span class="line"><span class="comment">// No (direct) latent typing in Java</span></span><br><span class="line"><span class="keyword">import</span> typeinfo.pets.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PerformingDog</span> <span class="keyword">extends</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">Performs</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"Woof!"</span>); &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sit</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"Sitting"</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reproduce</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Robot</span> <span class="keyword">implements</span> <span class="title">Performs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"Click!"</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sit</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"Clank!"</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">oilChange</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Communicate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Performs&gt;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">perform</span><span class="params">(T performer)</span> </span>&#123;</span><br><span class="line">        performer.speak();</span><br><span class="line">        performer.sit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DogsAndRobots</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Communicate.perform(<span class="keyword">new</span> PerformingDog());</span><br><span class="line">        Communicate.perform(<span class="keyword">new</span> Robot());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Woof!</span></span><br><span class="line"><span class="comment">Sitting</span></span><br><span class="line"><span class="comment">Click!</span></span><br><span class="line"><span class="comment">Clank!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>但是要注意，<code>perform()</code> 不需要使用泛型来工作，它可以被简单地指定为接受一个 <strong>Performs</strong> 对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/SimpleDogsAndRobots.java</span></span><br><span class="line"><span class="comment">// Removing the generic; code still works</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommunicateSimply</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">perform</span><span class="params">(Performs performer)</span> </span>&#123;</span><br><span class="line">        performer.speak();</span><br><span class="line">        performer.sit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDogsAndRobots</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CommunicateSimply.perform(<span class="keyword">new</span> PerformingDog());</span><br><span class="line">        CommunicateSimply.perform(<span class="keyword">new</span> Robot());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Woof!</span></span><br><span class="line"><span class="comment">Sitting</span></span><br><span class="line"><span class="comment">Click!</span></span><br><span class="line"><span class="comment">Clank!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>在本例中，<strong>泛型不是必需的</strong>，因为这些类已经被强制要求实现 <strong>Performs</strong> 接口。</p>
<!-- Compensating for the Lack of (Direct) Latent -->

<h2 id="对缺乏潜在类型机制的补偿"><a href="#对缺乏潜在类型机制的补偿" class="headerlink" title="对缺乏潜在类型机制的补偿"></a>对缺乏潜在类型机制的补偿</h2><p>尽管 Java 不直接支持潜在类型机制，但是这并不意味着泛型代码不能在不同的类型层次结构之间应用。也就是说，我们仍旧可以创建真正的泛型代码，但是这需要付出一些额外的努力。</p>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>可以使用的一种方式是反射，下面的 <code>perform()</code> 方法就是用了潜在类型机制：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/LatentReflection.java</span></span><br><span class="line"><span class="comment">// Using reflection for latent typing</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Does not implement Performs:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mime</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walkAgainstTheWind</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Pretending to sit"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushInvisibleWalls</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Mime"</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Does not implement Performs:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartDog</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"Woof!"</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sit</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"Sitting"</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reproduce</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommunicateReflectively</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">perform</span><span class="params">(Object speaker)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; spkr = speaker.getClass();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Method speak = spkr.getMethod(<span class="string">"speak"</span>);</span><br><span class="line">                speak.invoke(speaker);</span><br><span class="line">            &#125; <span class="keyword">catch</span>(NoSuchMethodException e) &#123;</span><br><span class="line">                System.out.println(speaker + <span class="string">" cannot speak"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Method sit = spkr.getMethod(<span class="string">"sit"</span>);</span><br><span class="line">                sit.invoke(speaker);</span><br><span class="line">            &#125; <span class="keyword">catch</span>(NoSuchMethodException e) &#123;</span><br><span class="line">                System.out.println(speaker + <span class="string">" cannot sit"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(SecurityException |</span><br><span class="line">            IllegalAccessException |</span><br><span class="line">            IllegalArgumentException |</span><br><span class="line">            InvocationTargetException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(speaker.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LatentReflection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CommunicateReflectively.perform(<span class="keyword">new</span> SmartDog());</span><br><span class="line">        CommunicateReflectively.perform(<span class="keyword">new</span> Robot());</span><br><span class="line">        CommunicateReflectively.perform(<span class="keyword">new</span> Mime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Woof!</span></span><br><span class="line"><span class="comment">Sitting</span></span><br><span class="line"><span class="comment">Click!</span></span><br><span class="line"><span class="comment">Clank!</span></span><br><span class="line"><span class="comment">Mime cannot speak</span></span><br><span class="line"><span class="comment">Pretending to sit</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>上例中，这些类完全是彼此分离的，没有任何公共基类（除了 <strong>Object</strong> ）或接口。通过反射, <code>CommunicateReflectively.perform()</code> 能够动态地确定所需要的方法是否可用并调用它们。它甚至能够处理 <strong>Mime</strong> 只具有一个必需的方法这一事实，并能够部分实现其目标。</p>
<h3 id="将一个方法应用于序列"><a href="#将一个方法应用于序列" class="headerlink" title="将一个方法应用于序列"></a>将一个方法应用于序列</h3><p>反射提供了一些有用的可能性，但是它<strong>将所有的类型检查都转移到了运行时</strong>，因此在许多情况下并不是我们所希望的。如果能够实现编译期类型检查，这通常会更符合要求。但是有可能实现编译期类型检查和潜在类型机制吗？</p>
<p>让我们看一个说明这个问题的示例。假设想要创建一个 <code>apply()</code> 方法，它能够将任何方法应用于某个序列中的所有对象。这种情况下使用接口不适合，因为你想要将任何方法应用于一个对象集合，而接口不可能描述任何方法。如何用 Java 来实现这个需求呢？</p>
<p>最初，我们可以用反射来解决这个问题，<strong>由于有了 Java 的可变参数，这种方式被证明是相当优雅的</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Apply.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apply</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, S extends Iterable&lt;T&gt;&gt;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(S seq, Method f, Object... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(T t: seq)</span><br><span class="line">                f.invoke(t, args);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IllegalAccessException |</span><br><span class="line">            IllegalArgumentException |</span><br><span class="line">            InvocationTargetException e) &#123;</span><br><span class="line">            <span class="comment">// Failures are programmer errors</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <strong>Apply.java</strong> 中，异常被转换为 <strong>RuntimeException</strong> ，因为没有多少办法可以从这种异常中恢复——在这种情况下，它们实际上代表着程序员的错误。</p>
<p>为什么我们不只使用 Java 8 方法参考（稍后显示）而不是反射方法 <strong>f</strong> ？ 注意，<code>invoke()</code> 和 <code>apply()</code> 的优点是它们可以接受任意数量的参数。 在某些情况下，灵活性可能至关重要。</p>
<p>为了测试 <strong>Apply</strong> ，我们首先创建一个 <strong>Shape</strong> 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Shape.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id = counter++;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getSimpleName() + <span class="string">" "</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span> + <span class="string">" rotate"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newSize)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span> + <span class="string">" resize "</span> + newSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>被一个子类 <strong>Square</strong> 继承：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Square.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>通过这些，我们可以测试 <strong>Apply</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ApplyTest.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplyTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        List&lt;Shape&gt; shapes =</span><br><span class="line">          Suppliers.create(ArrayList::<span class="keyword">new</span>, Shape::<span class="keyword">new</span>, <span class="number">3</span>);</span><br><span class="line">        Apply.apply(shapes, Shape.class.getMethod(<span class="string">"rotate"</span>));</span><br><span class="line">        Apply.apply(shapes, Shape.class.getMethod(<span class="string">"resize"</span>, <span class="keyword">int</span>.class), <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Square&gt; squares =</span><br><span class="line">          Suppliers.create(ArrayList::<span class="keyword">new</span>, Square::<span class="keyword">new</span>, <span class="number">3</span>);</span><br><span class="line">        Apply.apply(squares, Shape.class.getMethod(<span class="string">"rotate"</span>));</span><br><span class="line">        Apply.apply(squares, Shape.class.getMethod(<span class="string">"resize"</span>, <span class="keyword">int</span>.class), <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">        Apply.apply(<span class="keyword">new</span> FilledList&lt;&gt;(Shape::<span class="keyword">new</span>, <span class="number">3</span>),</span><br><span class="line">          Shape.class.getMethod(<span class="string">"rotate"</span>));</span><br><span class="line">        Apply.apply(<span class="keyword">new</span> FilledList&lt;&gt;(Square::<span class="keyword">new</span>, <span class="number">3</span>),</span><br><span class="line">          Shape.class.getMethod(<span class="string">"rotate"</span>));</span><br><span class="line"></span><br><span class="line">        SimpleQueue&lt;Shape&gt; shapeQ = Suppliers.fill(</span><br><span class="line">          <span class="keyword">new</span> SimpleQueue&lt;&gt;(), SimpleQueue::add,</span><br><span class="line">          Shape::<span class="keyword">new</span>, <span class="number">3</span>);</span><br><span class="line">        Suppliers.fill(shapeQ, SimpleQueue::add,</span><br><span class="line">          Square::<span class="keyword">new</span>, <span class="number">3</span>);</span><br><span class="line">        Apply.apply(shapeQ, Shape.class.getMethod(<span class="string">"rotate"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Shape 0 rotate</span></span><br><span class="line"><span class="comment">Shape 1 rotate</span></span><br><span class="line"><span class="comment">Shape 2 rotate</span></span><br><span class="line"><span class="comment">Shape 0 resize 7</span></span><br><span class="line"><span class="comment">Shape 1 resize 7</span></span><br><span class="line"><span class="comment">Shape 2 resize 7</span></span><br><span class="line"><span class="comment">Square 3 rotate</span></span><br><span class="line"><span class="comment">Square 4 rotate</span></span><br><span class="line"><span class="comment">Square 5 rotate</span></span><br><span class="line"><span class="comment">Square 3 resize 7</span></span><br><span class="line"><span class="comment">Square 4 resize 7</span></span><br><span class="line"><span class="comment">Square 5 resize 7</span></span><br><span class="line"><span class="comment">Shape 6 rotate</span></span><br><span class="line"><span class="comment">Shape 7 rotate</span></span><br><span class="line"><span class="comment">Shape 8 rotate</span></span><br><span class="line"><span class="comment">Square 9 rotate</span></span><br><span class="line"><span class="comment">Square 10 rotate</span></span><br><span class="line"><span class="comment">Square 11 rotate</span></span><br><span class="line"><span class="comment">Shape 12 rotate</span></span><br><span class="line"><span class="comment">Shape 13 rotate</span></span><br><span class="line"><span class="comment">Shape 14 rotate</span></span><br><span class="line"><span class="comment">Square 15 rotate</span></span><br><span class="line"><span class="comment">Square 16 rotate</span></span><br><span class="line"><span class="comment">Square 17 rotate</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>在 <strong>Apply</strong> 中，我们运气很好，因为碰巧在 Java 中内建了一个由 Java 集合类库使用的 <strong>Iterable</strong> 接口。正由于此， <code>apply()</code> 方法可以接受任何实现了 <strong>Iterable</strong> 接口的事物，包括诸如 <strong>List</strong> 这样的所有 <strong>Collection</strong> 类。但是它还可以接受其他任何事物，只要能够使这些事物是 <strong>Iterable</strong> 的——例如，在 <code>main()</code> 中使用下面定义的 <strong>SimpleQueue</strong> 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/SimpleQueue.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A different kind of Iterable collection</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleQueue</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;T&gt; storage = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T t)</span> </span>&#123; storage.offer(t); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> storage.poll(); &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> storage.iterator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正如反射解决方案看起来那样优雅，我们必须观察到反射（尽管在 Java 的最新版本中得到了显着改进）通常比非反射实现要慢，因为在运行时发生了很多事情。 但它不应阻止您尝试这种解决方案，这依然是值得考虑的一点。</p>
<p>几乎可以肯定，你会首先使用 Java 8 的函数式方法，并且只有在解决了特殊需求时才诉诸反射。 这里对 <strong>ApplyTest.java</strong> 进行了重写，以利用 Java 8 的流和函数工具：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ApplyFunctional.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplyFunctional</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream.of(</span><br><span class="line">          Stream.generate(Shape::<span class="keyword">new</span>).limit(<span class="number">2</span>),</span><br><span class="line">          Stream.generate(Square::<span class="keyword">new</span>).limit(<span class="number">2</span>))</span><br><span class="line">        .flatMap(c -&gt; c) <span class="comment">// flatten into one stream</span></span><br><span class="line">        .peek(Shape::rotate)</span><br><span class="line">        .forEach(s -&gt; s.resize(<span class="number">7</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> FilledList&lt;&gt;(Shape::<span class="keyword">new</span>, <span class="number">2</span>)</span><br><span class="line">          .forEach(Shape::rotate);</span><br><span class="line">        <span class="keyword">new</span> FilledList&lt;&gt;(Square::<span class="keyword">new</span>, <span class="number">2</span>)</span><br><span class="line">          .forEach(Shape::rotate);</span><br><span class="line"></span><br><span class="line">        SimpleQueue&lt;Shape&gt; shapeQ = Suppliers.fill(</span><br><span class="line">          <span class="keyword">new</span> SimpleQueue&lt;&gt;(), SimpleQueue::add,</span><br><span class="line">          Shape::<span class="keyword">new</span>, <span class="number">2</span>);</span><br><span class="line">        Suppliers.fill(shapeQ, SimpleQueue::add,</span><br><span class="line">          Square::<span class="keyword">new</span>, <span class="number">2</span>);</span><br><span class="line">        shapeQ.forEach(Shape::rotate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Shape 0 rotate</span></span><br><span class="line"><span class="comment">Shape 0 resize 7</span></span><br><span class="line"><span class="comment">Shape 1 rotate</span></span><br><span class="line"><span class="comment">Shape 1 resize 7</span></span><br><span class="line"><span class="comment">Square 2 rotate</span></span><br><span class="line"><span class="comment">Square 2 resize 7</span></span><br><span class="line"><span class="comment">Square 3 rotate</span></span><br><span class="line"><span class="comment">Square 3 resize 7</span></span><br><span class="line"><span class="comment">Shape 4 rotate</span></span><br><span class="line"><span class="comment">Shape 5 rotate</span></span><br><span class="line"><span class="comment">Square 6 rotate</span></span><br><span class="line"><span class="comment">Square 7 rotate</span></span><br><span class="line"><span class="comment">Shape 8 rotate</span></span><br><span class="line"><span class="comment">Shape 9 rotate</span></span><br><span class="line"><span class="comment">Square 10 rotate</span></span><br><span class="line"><span class="comment">Square 11 rotate</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>由于使用 Java 8，因此不需要 <code>Apply.apply()</code> 。</p>
<p>我们首先生成两个 <strong>Stream</strong> ： 一个是 <strong>Shape</strong> ，一个是 <strong>Square</strong> ，并将它们展平为单个流。 尽管 Java 缺少功能语言中经常出现的 <code>flatten()</code> ，但是我们可以使用 <code>flatMap(c-&gt; c)</code> 产生相同的结果，后者使用身份映射将操作简化为“  <strong>flatten</strong> ”。</p>
<p>我们使用 <code>peek()</code> 当做对 <code>rotate()</code> 的调用，因为 <code>peek()</code> 执行一个操作（此处是出于副作用），并在未更改的情况下传递对象。</p>
<p>注意，使用 <strong>FilledList</strong> 和 <strong>shapeQ</strong> 调用 <code>forEach()</code> 比 <code>Apply.apply()</code> 代码整洁得多。 在代码简单性和可读性方面，结果比以前的方法好得多。 并且，现在也不可能从  <code>main()</code> 引发异常。</p>
<!--skip -->

<!-- Assisted Latent Typing in Java 8 -->

<h2 id="Java8-中的辅助潜在类型"><a href="#Java8-中的辅助潜在类型" class="headerlink" title="Java8 中的辅助潜在类型"></a>Java8 中的辅助潜在类型</h2><p>先前声明关于 Java 缺乏对潜在类型的支持在 Java 8 之前是完全正确的。但是，Java 8 中的非绑定方法引用使我们能够产生一种潜在类型的形式，以满足创建一段可工作在不相干类型上的代码。因为 Java 最初并不是如此设计，所以结果可想而知，比其他语言中要尴尬一些。但是，至少现在成为了可能，只是缺乏令人惊艳之处。</p>
<p>我在其他地方从没遇过这种技术，因此我将其称为辅助潜在类型。</p>
<p>我们将重写 <strong>DogsAndRobots.java</strong> 来演示该技术。 为使外观看起来与原始示例尽可能相似，我仅向每个原始类名添加了 <strong>A</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/DogsAndRobotMethodReferences.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// "Assisted Latent Typing"</span></span><br><span class="line"><span class="keyword">import</span> typeinfo.pets.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PerformingDogA</span> <span class="keyword">extends</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"Woof!"</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sit</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"Sitting"</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reproduce</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RobotA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"Click!"</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sit</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"Clank!"</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">oilChange</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommunicateA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;P&gt; <span class="function"><span class="keyword">void</span> <span class="title">perform</span><span class="params">(P performer,</span></span></span><br><span class="line"><span class="function"><span class="params">      Consumer&lt;P&gt; action1, Consumer&lt;P&gt; action2)</span> </span>&#123;</span><br><span class="line">        action1.accept(performer);</span><br><span class="line">        action2.accept(performer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DogsAndRobotMethodReferences</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CommunicateA.perform(<span class="keyword">new</span> PerformingDogA(),</span><br><span class="line">          PerformingDogA::speak, PerformingDogA::sit);</span><br><span class="line">        CommunicateA.perform(<span class="keyword">new</span> RobotA(),</span><br><span class="line">          RobotA::speak, RobotA::sit);</span><br><span class="line">        CommunicateA.perform(<span class="keyword">new</span> Mime(),</span><br><span class="line">          Mime::walkAgainstTheWind,</span><br><span class="line">          Mime::pushInvisibleWalls);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Woof!</span></span><br><span class="line"><span class="comment">Sitting</span></span><br><span class="line"><span class="comment">Click!</span></span><br><span class="line"><span class="comment">Clank!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>PerformingDogA</strong> 和 <strong>RobotA</strong> 与 <strong>DogsAndRobots.java</strong> 中的相同，不同之处在于它们不继承通用接口 <strong>Performs</strong> ，因此它们没有通用性。</p>
<p><code>CommunicateA.perform()</code> 在没有约束的 <strong>P</strong> 上生成。 只要可以使用 <code>Consumer &lt;P&gt;</code>，它在这里就可以是任何东西，这些 <code>Consumer&lt;P&gt;</code> 代表不带参数的 <strong>P</strong> 方法的未绑定方法引用。当您调用 <strong>Consumer</strong>  的 <code>accept()</code> 方法时，它将方法引用绑定到执行者对象并调用该方法。 由于 <a href="book/13-Functional-Programming.md">函数式编程</a> 一章中描述的“魔术”，我们可以将任何符合签名的未绑定方法引用传递给 <code>CommunicateA.perform()</code> 。</p>
<p>之所以称其为“辅助”，是因为您必须显式地为 <code>perform()</code> 提供要使用的方法引用。 它不能只按名称调用方法。</p>
<p>尽管传递未绑定的方法引用似乎要花很多力气，但潜在类型的最终目标还是可以实现的。 我们创建了一个代码片段 <code>CommunicateA.perform()</code> ，该代码可用于任何具有符合签名的方法引用的类型。 请注意，这与我们看到的其他语言中的潜在类型有所不同，因为这些语言不仅需要签名以符合规范，还需要方法名称。 因此，该技术可以说产生了更多的通用代码。</p>
<p>为了证明这一点，我还从 <strong>LatentReflection.java</strong> 中引入了 <strong>Mime</strong>。</p>
<h3 id="使用Suppliers类的通用方法"><a href="#使用Suppliers类的通用方法" class="headerlink" title="使用Suppliers类的通用方法"></a>使用<strong>Suppliers</strong>类的通用方法</h3><p>通过辅助潜在类型，我们可以定义本章其他部分中使用的 <strong>Suppliers</strong> 类。 此类包含使用生成器填充 <strong>Collection</strong> 的工具方法。 泛化这些操作很有意义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/Suppliers.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A utility to use with Suppliers</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Suppliers</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Create a collection and fill it:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, C extends Collection&lt;T&gt;&gt; C</span><br><span class="line">      create(Supplier&lt;C&gt; factory, Supplier&lt;T&gt; gen, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">return</span> Stream.generate(gen)</span><br><span class="line">            .limit(n)</span><br><span class="line">            .collect(factory, C::add, C::addAll);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Fill an existing collection:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, C extends Collection&lt;T&gt;&gt;</span><br><span class="line">      <span class="function">C <span class="title">fill</span><span class="params">(C coll, Supplier&lt;T&gt; gen, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        Stream.generate(gen)</span><br><span class="line">            .limit(n)</span><br><span class="line">            .forEach(coll::add);</span><br><span class="line">        <span class="keyword">return</span> coll;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Use an unbound method reference to</span></span><br><span class="line">    <span class="comment">// produce a more general method:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;H, A&gt; <span class="function">H <span class="title">fill</span><span class="params">(H holder,</span></span></span><br><span class="line"><span class="function"><span class="params">      BiConsumer&lt;H, A&gt; adder, Supplier&lt;A&gt; gen, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        Stream.generate(gen)</span><br><span class="line">            .limit(n)</span><br><span class="line">            .forEach(a -&gt; adder.accept(holder, a));</span><br><span class="line">        <span class="keyword">return</span> holder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>create()</code> 为你创建一个新的 <strong>Collection</strong> 子类型，而 <code>fill()</code> 的第一个版本将元素放入 <strong>Collection</strong> 的现有子类型中。 请注意，还会返回传入的容器的确切类型，因此不会丢失类型信息。</p>
<p>前两种方法一般都受约束，只能与 <strong>Collection</strong> 子类型一起使用。<code>fill()</code> 的第二个版本适用于任何类型的 <strong>holder</strong> 。 它需要一个附加参数：未绑定方法引用 <code>adder. fill()</code> ，使用辅助潜在类型来使其与任何具有添加元素方法的 <strong>holder</strong> 类型一起使用。因为此未绑定方法 <strong>adder</strong> 必须带有一个参数（要添加到 <strong>holder</strong> 的元素），所以 <strong>adder</strong> 必须是 <code>BiConsumer &lt;H，A&gt;</code> ，其中 <strong>H</strong> 是要绑定到的 <strong>holder</strong> 对象的类型，而 <strong>A</strong> 是要被添加的绑定元素类型。 对 <code>accept()</code> 的调用将使用参数 a 调用对象 <strong>holder</strong> 上的未绑定方法 <strong>holder</strong>。</p>
<p>在一个稍作模拟的测试中对 <strong>Suppliers</strong> 工具程序进行了测试，该仿真还使用了本章前面定义的 <strong>RandomList</strong> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/BankTeller.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A very simple bank teller simulation</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id = counter++;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Customer "</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teller</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id = counter++;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Teller "</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;BankTeller&gt; tellers =</span><br><span class="line">        <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(BankTeller bt)</span> </span>&#123;</span><br><span class="line">        tellers.add(bt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BankTeller</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serve</span><span class="params">(Teller t, Customer c)</span> </span>&#123;</span><br><span class="line">        System.out.println(t + <span class="string">" serves "</span> + c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Demonstrate create():</span></span><br><span class="line">        RandomList&lt;Teller&gt; tellers =</span><br><span class="line">            Suppliers.create(</span><br><span class="line">            RandomList::<span class="keyword">new</span>, Teller::<span class="keyword">new</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="comment">// Demonstrate fill():</span></span><br><span class="line">        List&lt;Customer&gt; customers = Suppliers.fill(</span><br><span class="line">            <span class="keyword">new</span> ArrayList&lt;&gt;(), Customer::<span class="keyword">new</span>, <span class="number">12</span>);</span><br><span class="line">        customers.forEach(c -&gt;</span><br><span class="line">            serve(tellers.select(), c));</span><br><span class="line">        <span class="comment">// Demonstrate assisted latent typing:</span></span><br><span class="line">        Bank bank = Suppliers.fill(</span><br><span class="line">            <span class="keyword">new</span> Bank(), Bank::put, BankTeller::<span class="keyword">new</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">// Can also use second version of fill():</span></span><br><span class="line">        List&lt;Customer&gt; customers2 = Suppliers.fill(</span><br><span class="line">            <span class="keyword">new</span> ArrayList&lt;&gt;(),</span><br><span class="line">            List::add, Customer::<span class="keyword">new</span>, <span class="number">12</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Teller 3 serves Customer 1</span></span><br><span class="line"><span class="comment">Teller 2 serves Customer 2</span></span><br><span class="line"><span class="comment">Teller 3 serves Customer 3</span></span><br><span class="line"><span class="comment">Teller 1 serves Customer 4</span></span><br><span class="line"><span class="comment">Teller 1 serves Customer 5</span></span><br><span class="line"><span class="comment">Teller 3 serves Customer 6</span></span><br><span class="line"><span class="comment">Teller 1 serves Customer 7</span></span><br><span class="line"><span class="comment">Teller 2 serves Customer 8</span></span><br><span class="line"><span class="comment">Teller 3 serves Customer 9</span></span><br><span class="line"><span class="comment">Teller 3 serves Customer 10</span></span><br><span class="line"><span class="comment">Teller 2 serves Customer 11</span></span><br><span class="line"><span class="comment">Teller 4 serves Customer 12</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>可以看到 <code>create()</code> 生成一个新的 <strong>Collection</strong> 对象，而 <code>fill()</code> 添加到现有 <strong>Collection</strong> 中。第二个版本<code>fill()</code> 显示，它不仅与无关的新类型 <strong>Bank</strong> 一起使用，还能与 <strong>List</strong> 一起使用。因此，从技术上讲，<code>fill()</code> 的第一个版本在技术上不是必需的，但在使用 <strong>Collection</strong> 时提供了较短的语法。</p>
<!-- Summary: Is Casting Really So Bad? -->

<h2 id="总结：类型转换真的如此之糟吗？"><a href="#总结：类型转换真的如此之糟吗？" class="headerlink" title="总结：类型转换真的如此之糟吗？"></a>总结：类型转换真的如此之糟吗？</h2><p>自从 C++ 模版出现以来，我就一直在致力于解释它，我可能比大多数人都更早地提出了下面的论点。直到最近，我才停下来，去思考这个论点到底在多少时间内是有效的——我将要描述的问题到底有多少次可以穿越障碍得以解决。</p>
<p>这个论点就是：使用泛型类型机制的最吸引人的地方，就是在使用集合类的地方，这些类包括诸如各种 <strong>List</strong> 、各种 <strong>Set</strong> 、各种 <strong>Map</strong> 等你在 <a href="book/12-Collections.md">集合</a> 和 <a href="book/Appendix-Collection-Topics.md">附录：集合主题</a> 这两章所见。在 Java 5 之前，当你将一个对象放置到集合中时，这个对象就会被向上转型为 <strong>Object</strong> ，因此你会丢失类型信息。当你想要将这个对象从集合中取回，用它去执行某些操作时，必须将其向下转型回正确的类型。我用的示例是持有 <strong>Cat</strong> 的 <strong>List</strong> （这个示例的一种使用苹果和桔子的变体在 <a href="book/12-Collections.md">集合</a> 章节的开头展示过）。如果没有 Java 5 泛型版本的集合，你放到容集里和从集合中取回的都是 <strong>Object</strong> 。因此，我们很可能会将一个 <strong>Dog</strong> 放置到 <strong>Cat</strong> 的 <strong>List</strong> 中。</p>
<p>但是，泛型出现之前的 Java 并不会让你误用放入到集合中的对象。如果将一个 <strong>Dog</strong> 扔到 <strong>Cat</strong> 的集合中，并且试图将这个集合中的所有东西都当作 <strong>Cat</strong> 处理，那么当你从这个 <strong>Cat</strong> 集合中取回那个 <strong>Dog</strong> 引用，并试图将其转型为 <strong>Cat</strong> 时，就会得到一个 <strong>RuntimeException</strong> 。你仍旧可以发现问题，但是是在运行时而非编译期发现它的。</p>
<p>在本书以前的版本中，我曾经说过：</p>
<blockquote>
<p>这不止令人恼火，它还可能会产生难以发现的缺陷。如果这个程序的某个部分（或数个部分）向集合中插入了对象，并且通过异常，你在程序的另一个独立的部分中发现有不良对象被放置到了集合中，那么必须发现这个不良插入到底是在何处发生的。</p>
</blockquote>
<p>但是，随着对这个论点的进一步检查，我开始怀疑它了。首先，这会多么频繁地发生呢？我记得这类事情从未发生在我身上，并且当我在会议上询问其他人时，我也从来没有听说过有人碰上过。另一本书使用了一个称为 <strong>files</strong> 的 list 示例，它包含 <strong>String</strong> 对象。在这个示例中，向 <strong>files</strong> 中添加一个 <strong>File</strong> 对象看起来相当自然，因此这个对象的名字可能叫 <strong>fileNames</strong> 更好。无论 Java 提供了多少类型检查，仍旧可能会写出晦涩的程序，而编写差劲儿的程序即便可以编译，它仍旧是编写差劲儿的程序。可能大多数人都会使用命名良好的集合，例如 <strong>cats</strong> ，因为它们可以向试图添加非 <strong>Cat</strong> 对象的程序员提供可视的警告。并且即便这类事情发生了，它真正又能潜伏多久呢？只要你开始用真实数据来运行测试，就会非常快地看到异常。</p>
<p>有一位作者甚至断言，这样的缺陷将“<em>潜伏数年</em>”。但是我不记得有任何大量的相关报告，来说明人们在查找“狗在猫列表中”这类缺陷时困难重重，或者是说明人们会非常频繁地产生这种错误。然而，你将在 <a href="book/24-Concurrent-Programming.md">多线程编程</a> 章节中看到，在使用线程时，出现那些可能看起来极罕见的缺陷，是很寻常并容易发生的事，而且，对于到底出了什么错，这些缺陷只能给你一个很模糊的概念。因此，对于泛型是添加到 Java 中的非常显著和相当复杂的特性这一点，“狗在猫列表中”这个论据真的能够成为它的理由吗？<br>我相信被称为<em>泛型</em>的通用语言特性（并非必须是其在 Java 中的特定实现）的目的在于可表达性，而不仅仅是为了创建类型安全的集合。类型安全的集合是能够创建更通用代码这一能力所带来的副作用。<br>因此，即便“狗在猫列表中”这个论据经常被用来证明泛型是必要的，但是它仍旧是有问题的。就像我在本章开头声称的，我不相信这就是泛型这个概念真正的含义。相反，<strong>泛型正如其名称所暗示的：它是一种方法，通过它可以编写出更“泛化”的代码，这些代码对于它们能够作用的类型具有更少的限制，因此单个的代码段可以应用到更多的类型上。</strong>正如你在本章中看到的，编写真正泛化的“持有器”类（ Java 的容器就是这种类）相当简单，但是编写出能够操作其泛型类型的泛化代码就需要额外的努力了，这些努力需要类创建者和类消费者共同付出，他们必须理解这些代码的概念和实现。这些额外的努力会增加使用这种特性的难度，并可能会因此而使其在某些场合缺乏可应用性，而在这些场合中，它可能会带来附加的价值。</p>
<p>还要注意到，<strong>因为泛型是后来添加到 Java 中，而不是从一开始就设计到这种语言中的，所以某些容器无法达到它们应该具备的健壮性。</strong>例如，观察一下 <strong>Map</strong> ，在特定的方法 <code>containsKey(Object key)</code>和 <code>get(Object key)</code> 中就包含这类情况。如果这些类是使用在它们之前就存在的泛型设计的，那么这些方法将会使用参数化类型而不是 <strong>Object</strong> ，因此也就可以提供这些泛型假设会提供的编译期检查。例如，在 C++ 的 <strong>map</strong> 中，键的类型总是在编译期检查的。</p>
<p>有一件事很明显：在一种语言已经被广泛应用之后，在其较新的版本中引入任何种类的泛型机制，都会是一项非常非常棘手的任务，并且是一项不付出艰辛就无法完成的任务。在 C++ 中，模版是在其最初的 ISO 版本中就引入的（即便如此，也引发了阵痛，因为在第一个标准 C++ 出现之前，有很多非模版版本在使用），因此实际上模版一直都是这种语言的一部分。在 Java 中，泛型是在这种语言首次发布大约 10 年之后才引入的，因此向泛型迁移的问题特别多，并且对泛型的设计产生了明显的影响。其结果就是，程序员将承受这些痛苦，而这一切都是由于 Java 设计者在设计 1.0 版本时所表现出来的短视造成的。当 Java 最初被创建时，它的设计者们当然了解 C++ 的模版，他们甚至考虑将其囊括到 Java 语言中，但是出于这样或那样的原因，他们决定将模版排除在外（其迹象就是他们过于匆忙）。因此， Java 语言和使用它的程序员都将承受这些痛苦。只有时间将会说明 Java 的泛型方式对这种语言所造成的最终影响。<br>某些语言，已经融入了更简洁、影响更小的方式，来实现参数化类型。我们不可能不去想象这样的语言将会成为 Java 的继任者，因为它们采用的方式，与 C++ 通过 C 来实现的方式相同：按原样使用它，然后对其进行改进。</p>
<h2 id="进阶阅读"><a href="#进阶阅读" class="headerlink" title="进阶阅读"></a>进阶阅读</h2><p>泛型的入门文档是 《Generics in the Java Programming Language》，作者是 Gilad Bracha，可以从 <a href="http://java.oracle.com" target="_blank" rel="noopener">http://java.oracle.com</a> 获取。</p>
<p>Angelika Langer 的《Java Generics FAQs》是一份非常有帮助的资料，可以从 <a href="http://www.angelikalanger.com/GenericsFAQ/JavaGenericsFAQ.html" target="_blank" rel="noopener">http://www.angelikalanger.com/GenericsFAQ/JavaGenericsFAQ.html</a> 获取。</p>
<p>你可以从 《Adding Wildcards to the Java Programming Language》中学到更多关于通配符的知识，作者是 Torgerson、Ernst、Hansen、von der Ahe、Bracha 和 Gafter，地址是 <a href="http://www.jot.fm/issues/issue_2004_12/article5。" target="_blank" rel="noopener">http://www.jot.fm/issues/issue_2004_12/article5。</a></p>
<p>Neal After 对于 Java 问题（尤其是擦除）的看法可以从这里找到：<a href="http://www.infoq.com/articles/neal-gafter-on-java。" target="_blank" rel="noopener">http://www.infoq.com/articles/neal-gafter-on-java。</a></p>
<p>[^1]: 在编写本章期间，Angelika Langer的 Java 泛型常见问题解答以及她的其他著作（与Klaus Kreft一起）是非常宝贵的。<br>[^2]: <a href="http://gafter.blogspot.com/2004/09/puzzling-through-erasureanswer.html" target="_blank" rel="noopener">http://gafter.blogspot.com/2004/09/puzzling-through-erasureanswer.html</a><br>[^3]: 参见本章章末引文。<br>[^4]: 注意，一些编程环境，如 Eclipse 和 IntelliJ IDEA，将会自动生成委托代码。<br>[^5]: 因为可以使用转型，有效地禁止了类型系统，一些人就认为 C++ 是弱类型，但这太极端了。一种可能更好的说法是 C++ 是有一道暗门的强类型语言。<br>[^6]: 我再次从 Brian Goetz 那获得帮助。</p>
<!-- 分页 -->

<!-- Arrays -->

<h1 id="第二十一章-数组"><a href="#第二十一章-数组" class="headerlink" title="第二十一章 数组"></a>第二十一章 数组</h1><p>简单来看，数组需要你去创建和初始化，你可以<strong>通过下标对数组元素进行访问，数组的大小不会改变。</strong>大多数时候你只需要知道这些，但有时候你必须在数组上进行更复杂的操作，你也可能需要在数组和更加灵活的 <strong>集合</strong> (Collection)之间做出评估。因此本章我们将对数组进行更加深入的分析。</p>
<p><strong>注意：</strong> 随着 Java Collection 和 Stream 类中高级功能的不断增加，日常编程中使用数组的需求也在变少，所以你暂且可以放心地略读甚至跳过这一章。但是，即使你自己避免使用数组，也总会有需要阅读别人数组代码的那一天。</p>
<!-- Why Arrays are Special -->

<h2 id="数组特性"><a href="#数组特性" class="headerlink" title="数组特性"></a>数组特性</h2><p>明明还有很多其他的办法来保存对象，那么是什么令数组如此特别？</p>
<p>将数组和其他类型的集合区分开来的原因有三：<strong>效率，类型，保存基本数据类型的能力。</strong>在 Java 中，使用数组存储和随机访问对象引用序列是非常高效的。数组是简单的线性序列，这使得对元素的访问变得非常快。然而这种高速也是有代价的，代价就是数组对象的大小是固定的，且在该数组的生存期内不能更改。</p>
<p>速度通常并不是问题，如果有问题，你保存和检索对象的方式也很少是罪魁祸首。你应该总是从 <strong>ArrayList</strong> (来自 <a href="book/12-Collections.md">集合</a>)开始，它将数组封装起来。必要时，它会自动分配更多的数组空间，创建新数组，并将旧数组中的引用移动到新数组。这种灵活性需要开销，所以一个 <strong>ArrayList</strong> 的效率不如数组。在极少的情况下效率会成为问题，所以这种时候你可以直接使用数组。</p>
<p>数组和集合(Collections)都不能滥用。不管你使用数组还是集合，如果你越界，你都会得到一个 <strong>RuntimeException</strong> 的异常提醒，这表明你的程序中存在错误。</p>
<p>在泛型前，其他的集合类以一种宽泛的方式处理对象（就好像它们没有特定类型一样）。事实上，这些集合类把保存对象的类型默认为 <strong>Object</strong>，也就是 Java 中所有类的基类。而数组是优于 <strong>预泛型</strong> (pre-generic)集合类的，因为你创建一个数组就可以保存特定类型的数据。这意味着你获得了一个编译时的类型检查，而这可以防止你插入错误的数据类型，或者搞错你正在提取的数据类型。</p>
<p>当然，不管在编译时还是运行时，Java都会阻止你犯向对象发送不正确消息的错误。然而不管怎样，使用数组都不会有更大的风险。比较好的地方在于，如果编译器报错，最终的用户更容易理解抛出异常的含义。</p>
<p>一个数组可以保存基本数据类型，而一个预泛型的集合不可以。然而对于泛型而言，集合可以指定和检查他们保存对象的类型，而通过 <strong>自动装箱</strong> (autoboxing)机制，集合表现地就像它们可以保存基本数据类型一样，因为这种转换是自动的。</p>
<p>所以在概念上，两者很容易切换。但是就像你在<a href="book/12-Collections.md">集合</a>中看到的，集合的功能明显多于数组。随着 Java 自动装箱技术的出现，通过集合使用基本数据类型几乎和通过数组一样简单。<strong>数组唯一剩下的优势就是效率。</strong>然而，当你解决一个更加普遍的问题时，数组可能限制太多，这种情形下，您可以使用集合类。</p>
<h3 id="用于显示数组的实用程序"><a href="#用于显示数组的实用程序" class="headerlink" title="用于显示数组的实用程序"></a>用于显示数组的实用程序</h3><p>在本章中，我们处处都要显示数组。Java 提供了 <strong>Arrays.toString()</strong> 来将数组转换为可读字符串，然后可以在控制台上显示。然而这种方式视觉上噪音太大，所以我们创建一个小的库来完成这项工作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/ArrayShow.java</span></span><br><span class="line"><span class="comment">// (c)2017 MindView LLC: see Copyright.txt</span></span><br><span class="line"><span class="comment">// We make no guarantees that this code is fit for any purpose.</span></span><br><span class="line"><span class="comment">// Visit http://OnJava8.com for more book information.</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ArrayShow</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">    System.out.println(Arrays.toString(a));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">boolean</span>[] a)</span> </span>&#123;</span><br><span class="line">    System.out.println(Arrays.toString(a));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">byte</span>[] a)</span> </span>&#123;</span><br><span class="line">    System.out.println(Arrays.toString(a));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">char</span>[] a)</span> </span>&#123;</span><br><span class="line">    System.out.println(Arrays.toString(a));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">short</span>[] a)</span> </span>&#123;</span><br><span class="line">    System.out.println(Arrays.toString(a));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    System.out.println(Arrays.toString(a));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">long</span>[] a)</span> </span>&#123;</span><br><span class="line">    System.out.println(Arrays.toString(a));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">float</span>[] a)</span> </span>&#123;</span><br><span class="line">    System.out.println(Arrays.toString(a));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">double</span>[] a)</span> </span>&#123;</span><br><span class="line">    System.out.println(Arrays.toString(a));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Start with a description:</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String info, Object[] a)</span> </span>&#123;</span><br><span class="line">    System.out.print(info + <span class="string">": "</span>);</span><br><span class="line">    show(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String info, <span class="keyword">boolean</span>[] a)</span> </span>&#123;</span><br><span class="line">    System.out.print(info + <span class="string">": "</span>);</span><br><span class="line">    show(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String info, <span class="keyword">byte</span>[] a)</span> </span>&#123;</span><br><span class="line">    System.out.print(info + <span class="string">": "</span>);</span><br><span class="line">    show(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String info, <span class="keyword">char</span>[] a)</span> </span>&#123;</span><br><span class="line">    System.out.print(info + <span class="string">": "</span>);</span><br><span class="line">    show(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String info, <span class="keyword">short</span>[] a)</span> </span>&#123;</span><br><span class="line">    System.out.print(info + <span class="string">": "</span>);</span><br><span class="line">    show(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String info, <span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    System.out.print(info + <span class="string">": "</span>);</span><br><span class="line">    show(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String info, <span class="keyword">long</span>[] a)</span> </span>&#123;</span><br><span class="line">    System.out.print(info + <span class="string">": "</span>);</span><br><span class="line">    show(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String info, <span class="keyword">float</span>[] a)</span> </span>&#123;</span><br><span class="line">    System.out.print(info + <span class="string">": "</span>);</span><br><span class="line">    show(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String info, <span class="keyword">double</span>[] a)</span> </span>&#123;</span><br><span class="line">    System.out.print(info + <span class="string">": "</span>);</span><br><span class="line">    show(a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个方法适用于对象数组，包括那些包装基本数据类型的数组。所有的方法重载对于不同的数据类型是必要的。</p>
<p>第二组重载方法可以让你显示带有信息 <strong>字符串</strong> 前缀的数组。</p>
<p>为了简单起见，你通常可以静态地导入它们。</p>
<!-- Arrays are First-Class Objects -->

<h2 id="一等对象"><a href="#一等对象" class="headerlink" title="一等对象"></a>一等对象</h2><p>不管你使用的什么类型的数组，<strong>数组中的数据集实际上都是对堆中真正对象的引用</strong>。<strong>数组是保存指向其他对象的引用的对象</strong>，数组可以隐式地创建，作为数组初始化语法的一部分，也可以显式地创建，比如使用一个 <strong>new</strong> 表达式。数组对象的一部分（事实上，你唯一可以使用的方法）就是只读的 <strong>length</strong> 成员函数，它能告诉你数组对象中可以存储多少元素。<strong>[ ]</strong> 语法是你访问数组对象的唯一方式。</p>
<!-- Arrays are First-Class Objects -->

<h2 id="一等对象-1"><a href="#一等对象-1" class="headerlink" title="一等对象"></a>一等对象</h2><p>不管你使用的什么类型的数组，<strong>数组中的数据集实际上都是对堆中真正对象的引用</strong>。<strong>数组是保存指向其他对象的引用的对象</strong>，数组可以隐式地创建，作为数组初始化语法的一部分，也可以显式地创建，比如使用一个 <strong>new</strong> 表达式。数组对象的一部分（事实上，你唯一可以使用的方法）就是只读的 <strong>length</strong> 成员函数，它能告诉你数组对象中可以存储多少元素。<strong>[ ]</strong> 语法是你访问数组对象的唯一方式。</p>
<p>对象数组和基元数组在使用上是完全相同的。唯一的不同之处就是对象数组存储的是对象的引用，而基元数组则直接存储基本数据类型的值。</p>
<p>你无法找出到底有多少元素存储在数组中，因为 <strong>length</strong> 只能告诉你数组可以存储多少元素；这就是说，<strong>数组对象的大小并不是真正存储在数组中对象的个数。</strong>然而，<strong>当你创建一个数组对象，其引用将自动初始化为 null，</strong>因此你可以通过检查特定数组元素中的引用是否为 <strong>null</strong> 来判断其中是否有对象。<strong>基元数组也有类似的机制</strong>，比如自动将数值类型初始化为 <strong>0</strong>，char 型初始化为 <strong>(char)0</strong>，布尔类型初始化为 <strong>false</strong>。</p>
<p>表达式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = d;</span><br></pre></td></tr></table></figure>

<p>显示了你如何获取指向一个数组对象的引用并将其分配给另一个数组对象。就像你可以处理其他类型的对象引用。现在 <strong>a</strong> 和 <strong>d</strong> 都指向了堆中的同一个数组对象。</p>
<!-- Returning an Array -->

<h2 id="返回数组"><a href="#返回数组" class="headerlink" title="返回数组"></a>返回数组</h2><p>假设你写了一个方法，这个方法不是返回一个元素，而是返回多个元素。对 C++/C 这样的语言来说这是很困难的，因为你无法返回一个数组，只能是返回一个指向数组的指针。这会带来一些问题，因为对数组生存期的控制变得很混乱，这会导致内存泄露。</p>
<p><strong>而在 Java 中，你只需返回数组</strong>，你永远不用为数组担心，只要你需要它，它就可用，<strong>垃圾收集器会在你用完后把它清理干净。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String[] flavorSet(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; FLAVORS.length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Set too big"</span>);</span><br><span class="line">    String[] results = <span class="keyword">new</span> String[n];</span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!-- Multidimensional Arrays -->

<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>要创建多维的基元数组，你要用大括号来界定数组中的向量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arrays/MultidimensionalPrimitiveArray.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultidimensionalPrimitiveArray</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] a = &#123;</span><br><span class="line">      &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, &#125;,</span><br><span class="line">      &#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(Arrays.deepToString(a));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[[1, 2, 3], [4, 5, 6]]</span></span><br><span class="line"><span class="comment">*/</span>。</span><br></pre></td></tr></table></figure>

<p>每个嵌套的大括号都代表了数组的一个维度。</p>
<p>这个例子使用 <strong>Arrays.deepToString()</strong> 方法，将多维数组转换成 <strong>String</strong> 类型，就像输出中显示的那样。</p>
<p>你也可以使用 <strong>new</strong> 分配数组。这是一个使用 <strong>new</strong> 表达式分配的三维数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arrays/ThreeDWithNew.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreeDWithNew</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 3-D array with fixed length:</span></span><br><span class="line">    <span class="keyword">int</span>[][][] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">2</span>][<span class="number">4</span>];</span><br><span class="line">    System.out.println(Arrays.deepToString(a));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[[[0, 0, 0, 0], [0, 0, 0, 0]], [[0, 0, 0, 0], [0, 0, 0,</span></span><br><span class="line"><span class="comment">0]]]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>倘若你不对基元数组进行显式的初始化，它的值会自动初始化。而对象数组将被初始化为 <strong>null</strong> 。</p>
<p>组成矩阵的数组中每一个向量都可以是任意长度的（这叫做不规则数组）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arrays/RaggedArray.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RaggedArray</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> val = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SplittableRandom rand = <span class="keyword">new</span> SplittableRandom(<span class="number">47</span>);</span><br><span class="line">    <span class="comment">// 3-D array with varied-length vectors:</span></span><br><span class="line">    <span class="keyword">int</span>[][][] a = <span class="keyword">new</span> <span class="keyword">int</span>[rand.nextInt(<span class="number">7</span>)][][];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">      a[i] = <span class="keyword">new</span> <span class="keyword">int</span>[rand.nextInt(<span class="number">5</span>)][];</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a[i].length; j++) &#123;</span><br><span class="line">        a[i][j] = <span class="keyword">new</span> <span class="keyword">int</span>[rand.nextInt(<span class="number">5</span>)];</span><br><span class="line">        Arrays.setAll(a[i][j], n -&gt; val++); <span class="comment">// [1]</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Arrays.deepToString(a));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[[[1], []], [[2, 3, 4, 5], [6]], [[7, 8, 9], [10, 11,</span></span><br><span class="line"><span class="comment">12], []]]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>第一个 <strong>new</strong> 创建了一个数组，这个数组首元素长度随机，其余的则不确定。第二个 <strong>new</strong> 在 for 循环中给数组填充了第二个元素，第三个 <strong>new</strong>  为数组的最后一个索引填充元素。</p>
<ul>
<li><strong>[1]</strong> Java 8 增加了 <strong>Arrays.setAll()</strong> 方法,其使用生成器来生成插入数组中的值。此生成器符合函数式接口 <strong>IntUnaryOperator</strong> ，只使用一个非 <strong>默认</strong> 的方法 <strong>ApplyAsint(int操作数)</strong> 。 <strong>Arrays.setAll()</strong> 传递当前数组索引作为操作数，因此一个选项是提供 <strong>n -&gt; n</strong> 的 lambda 表达式来显示数组的索引（在上面的代码中很容易尝试）。这里，我们忽略索引，只是插入递增计数器的值。</li>
</ul>
<p>非基元的对象数组也可以定义为不规则数组。这里，我们收集了许多使用大括号的 <strong>new</strong> 表达式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arrays/MultidimensionalObjectArrays.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultidimensionalObjectArrays</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    BerylliumSphere[][] spheres = &#123;</span><br><span class="line">      &#123; <span class="keyword">new</span> BerylliumSphere(), <span class="keyword">new</span> BerylliumSphere() &#125;,</span><br><span class="line">      &#123; <span class="keyword">new</span> BerylliumSphere(), <span class="keyword">new</span> BerylliumSphere(),</span><br><span class="line">        <span class="keyword">new</span> BerylliumSphere(), <span class="keyword">new</span> BerylliumSphere() &#125;,</span><br><span class="line">      &#123; <span class="keyword">new</span> BerylliumSphere(), <span class="keyword">new</span> BerylliumSphere(),</span><br><span class="line">        <span class="keyword">new</span> BerylliumSphere(), <span class="keyword">new</span> BerylliumSphere(),</span><br><span class="line">        <span class="keyword">new</span> BerylliumSphere(), <span class="keyword">new</span> BerylliumSphere(),</span><br><span class="line">        <span class="keyword">new</span> BerylliumSphere(), <span class="keyword">new</span> BerylliumSphere() &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(Arrays.deepToString(spheres));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[[Sphere 0, Sphere 1], [Sphere 2, Sphere 3, Sphere 4,</span></span><br><span class="line"><span class="comment">Sphere 5], [Sphere 6, Sphere 7, Sphere 8, Sphere 9,</span></span><br><span class="line"><span class="comment">Sphere 10, Sphere 11, Sphere 12, Sphere 13]]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>数组初始化时使用自动装箱技术：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arrays/AutoboxingArrays.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoboxingArrays</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer[][] a = &#123; <span class="comment">// Autoboxing:</span></span><br><span class="line">      &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;,</span><br><span class="line">      &#123; <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span> &#125;,</span><br><span class="line">      &#123; <span class="number">51</span>, <span class="number">52</span>, <span class="number">53</span>, <span class="number">54</span>, <span class="number">55</span>, <span class="number">56</span>, <span class="number">57</span>, <span class="number">58</span>, <span class="number">59</span>, <span class="number">60</span> &#125;,</span><br><span class="line">      &#123; <span class="number">71</span>, <span class="number">72</span>, <span class="number">73</span>, <span class="number">74</span>, <span class="number">75</span>, <span class="number">76</span>, <span class="number">77</span>, <span class="number">78</span>, <span class="number">79</span>, <span class="number">80</span> &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(Arrays.deepToString(a));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [21, 22, 23, 24, 25,</span></span><br><span class="line"><span class="comment">26, 27, 28, 29, 30], [51, 52, 53, 54, 55, 56, 57, 58,</span></span><br><span class="line"><span class="comment">59, 60], [71, 72, 73, 74, 75, 76, 77, 78, 79, 80]]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>以下是如何逐个构建非基元的对象数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arrays/AssemblingMultidimensionalArrays.java</span></span><br><span class="line"><span class="comment">// Creating multidimensional arrays</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AssemblingMultidimensionalArrays</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer[][] a;</span><br><span class="line">    a = <span class="keyword">new</span> Integer[<span class="number">3</span>][];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">      a[i] = <span class="keyword">new</span> Integer[<span class="number">3</span>];</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a[i].length; j++)</span><br><span class="line">        a[i][j] = i * j; <span class="comment">// Autoboxing</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Arrays.deepToString(a));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[[0, 0, 0], [0, 1, 2], [0, 2, 4]]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>i * j</strong> 在这里只是为了向 <strong>Integer</strong> 中添加有趣的值。</p>
<p><strong>Arrays.deepToString()</strong> 方法同时适用于基元数组和对象数组。</p>
<!-- Arrays and Generics -->

<h2 id="泛型数组-1"><a href="#泛型数组-1" class="headerlink" title="泛型数组"></a>泛型数组</h2><p>一般来说，数组和泛型并不能很好的结合。你不能实例化参数化类型的数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Peel&lt;Banana&gt;[] peels = <span class="keyword">new</span> Peel&lt;Banana&gt;[<span class="number">10</span>]; <span class="comment">// Illegal</span></span><br></pre></td></tr></table></figure>

<p>类型擦除需要删除参数类型信息，而且数组必须知道它们所保存的确切类型，以强制保证类型安全。</p>
<p>但是，可以参数化数组本身的类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arrays/ParameterizedArrayType.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassParameter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> T[] f(T[] arg) &#123; <span class="keyword">return</span> arg; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MethodParameter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] f(T[] arg) &#123; <span class="keyword">return</span> arg; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParameterizedArrayType</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer[] ints = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    Double[] doubles = &#123; <span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span>, <span class="number">5.5</span> &#125;;</span><br><span class="line">    Integer[] ints2 =</span><br><span class="line">      <span class="keyword">new</span> ClassParameter&lt;Integer&gt;().f(ints);</span><br><span class="line">    Double[] doubles2 =</span><br><span class="line">      <span class="keyword">new</span> ClassParameter&lt;Double&gt;().f(doubles);</span><br><span class="line">    ints2 = MethodParameter.f(ints);</span><br><span class="line">    doubles2 = MethodParameter.f(doubles);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比起使用参数化类，使用参数化方法很方便。您不必为应用它的每个不同类型都实例化一个带有参数的类，但是可以使它成为 <strong>静态</strong> 的。<strong>你不能总是选择使用参数化方法而不用参数化的类，但通常参数化方法是更好的选择。</strong></p>
<p>你不能创建泛型类型的数组，这种说法并不完全正确。是的，编译器不会让你 <em>实例化</em> 一个泛型的数组。但是，它将允许您创建对此类数组的引用。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] ls;</span><br></pre></td></tr></table></figure>

<p>无可争议的，这可以通过编译。尽管不能创建包含泛型的实际数组对象，但是你可以创建一个非泛型的数组并对其进行强制类型转换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arrays/ArrayOfGenerics.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayOfGenerics</span> </span>&#123;</span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt;[] ls;</span><br><span class="line">    List[] la = <span class="keyword">new</span> List[<span class="number">10</span>];</span><br><span class="line">    ls = (List&lt;String&gt;[])la; <span class="comment">// Unchecked cast</span></span><br><span class="line">    ls[<span class="number">0</span>] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//- ls[1] = new ArrayList&lt;Integer&gt;();</span></span><br><span class="line">    <span class="comment">// error: incompatible types: ArrayList&lt;Integer&gt;</span></span><br><span class="line">    <span class="comment">// cannot be converted to List&lt;String&gt;</span></span><br><span class="line">    <span class="comment">//     ls[1] = new ArrayList&lt;Integer&gt;();</span></span><br><span class="line">    <span class="comment">//             ^</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// The problem: List&lt;String&gt; is a subtype of Object</span></span><br><span class="line">    Object[] objects = ls; <span class="comment">// So assignment is OK</span></span><br><span class="line">    <span class="comment">// Compiles and runs without complaint:</span></span><br><span class="line">    objects[<span class="number">1</span>] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// However, if your needs are straightforward it is</span></span><br><span class="line">    <span class="comment">// possible to create an array of generics, albeit</span></span><br><span class="line">    <span class="comment">// with an "unchecked cast" warning:</span></span><br><span class="line">    List&lt;BerylliumSphere&gt;[] spheres =</span><br><span class="line">      (List&lt;BerylliumSphere&gt;[])<span class="keyword">new</span> List[<span class="number">10</span>];</span><br><span class="line">    Arrays.setAll(spheres, n -&gt; <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦你有了对 <strong>List<string>[]</string></strong> 的引用 , 你会发现多了一些编译时检查。问题是数组是协变的，所以 <strong>List<string>[]</string></strong> 也是一个 <strong>Object[]</strong>  ，你可以用这来将 *<em>ArrayList<integer> *</integer></em> 分配进你的数组，在编译或者运行时都不会出错。</p>
<p>如果你知道你不会进行向上类型转换，你的需求相对简单，那么可以创建一个泛型数组，它将提供基本的编译时类型检查。然而，一个泛型 <strong>Collection</strong> 实际上是一个比泛型数组更好的选择。</p>
<p>一般来说，您会发现泛型在类或方法的边界上是有效的。在内部，擦除常常会使泛型不可使用。所以，就像下面的例子，不能创建泛型类型的数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arrays/ArrayOfGenericType.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayOfGenericType</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  T[] array; <span class="comment">// OK</span></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ArrayOfGenericType</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// error: generic array creation:</span></span><br><span class="line">    <span class="comment">//- array = new T[size];</span></span><br><span class="line">    array = (T[])<span class="keyword">new</span> Object[size]; <span class="comment">// unchecked cast</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// error: generic array creation:</span></span><br><span class="line">  <span class="comment">//- public &lt;U&gt; U[] makeArray() &#123; return new U[10]; &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>擦除再次从中作梗，这个例子试图创建已经擦除的类型数组，因此它们是未知的类型。你可以创建一个 <strong>对象</strong> 数组，然后对其进行强制类型转换，但如果没有 <strong>@SuppressWarnings</strong> 注释，你将会得到一个 “unchecked” 警告，因为数组实际上不真正支持而且将对类型 <strong>T</strong> 动态检查 。这就是说，如果我创建了一个 <strong>String[]</strong> , Java将在编译时和运行时强制执行，我只能在数组中放置字符串对象。然而，如果我创建一个 <strong>Object[]</strong> ,我可以把除了基元类型外的任何东西放入数组。</p>
<!-- Arrays.fill() -->

<h2 id="Arrays的fill方法"><a href="#Arrays的fill方法" class="headerlink" title="Arrays的fill方法"></a>Arrays的fill方法</h2><p>通常情况下，当对数组和程序进行实验时，能够很轻易地生成充满测试数据的数组是很有帮助的。 Java 标准库 <strong>Arrays</strong> 类包括一个普通的 <strong>fill()</strong> 方法，<strong>该方法将单个值复制到整个数组，或者在对象数组的情况下，将相同的引用复制到整个数组</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arrays/FillingArrays.java</span></span><br><span class="line"><span class="comment">// Using Arrays.fill()</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> onjava.ArrayShow.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FillingArrays</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[] a1 = <span class="keyword">new</span> <span class="keyword">boolean</span>[size];</span><br><span class="line">    <span class="keyword">byte</span>[] a2 = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</span><br><span class="line">    <span class="keyword">char</span>[] a3 = <span class="keyword">new</span> <span class="keyword">char</span>[size];</span><br><span class="line">    <span class="keyword">short</span>[] a4 = <span class="keyword">new</span> <span class="keyword">short</span>[size];</span><br><span class="line">    <span class="keyword">int</span>[] a5 = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">    <span class="keyword">long</span>[] a6 = <span class="keyword">new</span> <span class="keyword">long</span>[size];</span><br><span class="line">    <span class="keyword">float</span>[] a7 = <span class="keyword">new</span> <span class="keyword">float</span>[size];</span><br><span class="line">    <span class="keyword">double</span>[] a8 = <span class="keyword">new</span> <span class="keyword">double</span>[size];</span><br><span class="line">    String[] a9 = <span class="keyword">new</span> String[size];</span><br><span class="line">    Arrays.fill(a1, <span class="keyword">true</span>);</span><br><span class="line">    show(<span class="string">"a1"</span>, a1);</span><br><span class="line">    Arrays.fill(a2, (<span class="keyword">byte</span>)<span class="number">11</span>);</span><br><span class="line">    show(<span class="string">"a2"</span>, a2);</span><br><span class="line">    Arrays.fill(a3, <span class="string">'x'</span>);</span><br><span class="line">    show(<span class="string">"a3"</span>, a3);</span><br><span class="line">    Arrays.fill(a4, (<span class="keyword">short</span>)<span class="number">17</span>);</span><br><span class="line">    show(<span class="string">"a4"</span>, a4);</span><br><span class="line">    Arrays.fill(a5, <span class="number">19</span>);</span><br><span class="line">    show(<span class="string">"a5"</span>, a5);</span><br><span class="line">    Arrays.fill(a6, <span class="number">23</span>);</span><br><span class="line">    show(<span class="string">"a6"</span>, a6);</span><br><span class="line">    Arrays.fill(a7, <span class="number">29</span>);</span><br><span class="line">    show(<span class="string">"a7"</span>, a7);</span><br><span class="line">    Arrays.fill(a8, <span class="number">47</span>);</span><br><span class="line">    show(<span class="string">"a8"</span>, a8);</span><br><span class="line">    Arrays.fill(a9, <span class="string">"Hello"</span>);</span><br><span class="line">    show(<span class="string">"a9"</span>, a9);</span><br><span class="line">    <span class="comment">// Manipulating ranges:</span></span><br><span class="line">    Arrays.fill(a9, <span class="number">3</span>, <span class="number">5</span>, <span class="string">"World"</span>);</span><br><span class="line">    show(<span class="string">"a9"</span>, a9);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;gedan</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">a1: [true, true, true, true, true, true]</span></span><br><span class="line"><span class="comment">a2: [11, 11, 11, 11, 11, 11]</span></span><br><span class="line"><span class="comment">a3: [x, x, x, x, x, x]</span></span><br><span class="line"><span class="comment">a4: [17, 17, 17, 17, 17, 17]</span></span><br><span class="line"><span class="comment">a5: [19, 19, 19, 19, 19, 19]</span></span><br><span class="line"><span class="comment">a6: [23, 23, 23, 23, 23, 23]</span></span><br><span class="line"><span class="comment">a7: [29.0, 29.0, 29.0, 29.0, 29.0, 29.0]</span></span><br><span class="line"><span class="comment">a8: [47.0, 47.0, 47.0, 47.0, 47.0, 47.0]</span></span><br><span class="line"><span class="comment">a9: [Hello, Hello, Hello, Hello, Hello, Hello]</span></span><br><span class="line"><span class="comment">a9: [Hello, Hello, Hello, World, World, Hello]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>你既可以填充整个数组，也可以像最后两个语句所示，填充一系列的元素。但是由于你只能使用单个值调用 <strong>Arrays.fill()</strong> ，因此结果并非特别有用。</p>
<!-- Arrays.setAll() -->

<h2 id="Arrays的setAll方法"><a href="#Arrays的setAll方法" class="headerlink" title="Arrays的setAll方法"></a>Arrays的setAll方法</h2><p>在Java 8中， 在<strong>RaggedArray.java</strong> 中引入并在 <strong>ArrayOfGenerics.java.Array.setAll()</strong> 中重用。它使用一个生成器并生成不同的值，可以选择基于数组的索引元素（通过访问当前索引，生成器可以读取数组值并对其进行修改）。 <strong>static Arrays.setAll()</strong> 的重载签名为：</p>
<ul>
<li><strong>void setAll(int[] a, IntUnaryOperator gen)</strong></li>
<li><strong>void setAll(long[] a, IntToLongFunction gen)</strong></li>
<li><strong>void setAll(double[] a, IntToDoubleFunctiongen)</strong></li>
<li><strong><t> void setAll(T[] a, IntFunction&lt;? extendsT&gt; gen)</t></strong></li>
</ul>
<p>除了 <strong>int</strong> , <strong>long</strong> , <strong>double</strong> 有特殊的版本，其他的一切都由泛型版本处理。生成器不是 <strong>Supplier</strong> 因为它们不带参数，并且必须将 <strong>int</strong> 数组索引作为参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arrays/SimpleSetAll.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> onjava.ArrayShow.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bob</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> id;</span><br><span class="line">  Bob(<span class="keyword">int</span> n) &#123; id = n; &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Bob"</span> + id; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleSetAll</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SZ = <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> val = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span>[] chars = <span class="string">"abcdefghijklmnopqrstuvwxyz"</span></span><br><span class="line">    .toCharArray();</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">char</span> <span class="title">getChar</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">return</span> chars[n]; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] ia = <span class="keyword">new</span> <span class="keyword">int</span>[SZ];</span><br><span class="line">    <span class="keyword">long</span>[] la = <span class="keyword">new</span> <span class="keyword">long</span>[SZ];</span><br><span class="line">    <span class="keyword">double</span>[] da = <span class="keyword">new</span> <span class="keyword">double</span>[SZ];</span><br><span class="line">    Arrays.setAll(ia, n -&gt; n); <span class="comment">// [1]</span></span><br><span class="line">    Arrays.setAll(la, n -&gt; n);</span><br><span class="line">    Arrays.setAll(da, n -&gt; n);</span><br><span class="line">    show(ia);</span><br><span class="line">    show(la);</span><br><span class="line">    show(da);</span><br><span class="line">    Arrays.setAll(ia, n -&gt; val++); <span class="comment">// [2]</span></span><br><span class="line">    Arrays.setAll(la, n -&gt; val++);</span><br><span class="line">    Arrays.setAll(da, n -&gt; val++);</span><br><span class="line">    show(ia);</span><br><span class="line">    show(la);</span><br><span class="line">    show(da);</span><br><span class="line"></span><br><span class="line">    Bob[] ba = <span class="keyword">new</span> Bob[SZ];</span><br><span class="line">    Arrays.setAll(ba, Bob::<span class="keyword">new</span>); <span class="comment">// [3]</span></span><br><span class="line">    show(ba);</span><br><span class="line"></span><br><span class="line">    Character[] ca = <span class="keyword">new</span> Character[SZ];</span><br><span class="line">    Arrays.setAll(ca, SimpleSetAll::getChar); <span class="comment">// [4]</span></span><br><span class="line">    show(ca);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[0, 1, 2, 3, 4, 5, 6, 7]</span></span><br><span class="line"><span class="comment">[0, 1, 2, 3, 4, 5, 6, 7]</span></span><br><span class="line"><span class="comment">[0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0]</span></span><br><span class="line"><span class="comment">[1, 2, 3, 4, 5, 6, 7, 8]</span></span><br><span class="line"><span class="comment">[9, 10, 11, 12, 13, 14, 15, 16]</span></span><br><span class="line"><span class="comment">[17.0, 18.0, 19.0, 20.0, 21.0, 22.0, 23.0, 24.0]</span></span><br><span class="line"><span class="comment">[Bob0, Bob1, Bob2, Bob3, Bob4, Bob5, Bob6, Bob7]</span></span><br><span class="line"><span class="comment">[a, b, c, d, e, f, g, h]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>[1]</strong> 这里，我们只是将数组索引作为值插入数组。这将自动转化为 <strong>long</strong> 和 <strong>double</strong> 版本。</li>
<li><strong>[2]</strong> 这个函数只需要接受索引就能产生正确结果。这个，我们忽略索引值并且使用 <strong>val</strong> 生成结果。</li>
<li><strong>[3]</strong> 方法引用有效，因为 <strong>Bob</strong> 的构造器接收一个 <strong>int</strong> 参数。只要我们传递的函数接收一个 <strong>int</strong> 参数且能产生正确的结果，就认为它完成了工作。</li>
<li><strong>[4]</strong> 为了处理除了  <strong>int</strong> ，<strong>long</strong> ，<strong>double</strong> 之外的基元类型，请为基元创建包装类的数组。然后使用 <strong>setAll()</strong> 的泛型版本。请注意，<strong>getChar（）</strong> 生成基元类型，因此这是自动装箱到 <strong>Character</strong> 。</li>
</ul>
<!-- Incremental Generators -->

<h2 id="增量生成"><a href="#增量生成" class="headerlink" title="增量生成"></a>增量生成</h2><p>这是一个方法库，用于为不同类型生成增量值。</p>
<p>这些被作为内部类来生成容易记住的名字；比如，为了使用 <strong>Integer</strong> 工具你可以用 <strong>new Conut.Interger()</strong> , 如果你想要使用基本数据类型 <strong>int</strong> 工具，你可以用 <strong>new Count.Pint()</strong>  (基本类型的名字不能被直接使用，所以它们都在前面添加一个 <strong>P</strong>  来表示基本数据类型’primitive’, 我们的第一选择是使用基本类型名字后面跟着下划线，比如 <strong>int_</strong> 和 <strong>double_</strong>  ,但是这种方式违背Java的命名习惯）。每个包装类的生成器都使用 <strong>get()</strong> 方法实现了它的 <strong>Supplier</strong> 。要使用<strong>Array.setAll()</strong> ，一个重载的 <strong>get(int n)</strong> 方法要接受（并忽略）其参数，以便接受 <strong>setAll()</strong> 传递的索引值。</p>
<p>注意，通过使用包装类的名称作为内部类名，我们必须调用 <strong>java.lang</strong> 包来保证我们可以使用实际包装类的名字：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/Count.java</span></span><br><span class="line"><span class="comment">// Generate incremental values of different types</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> onjava.ConvertTo.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Count</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Boolean</span></span></span><br><span class="line"><span class="class">  <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">java</span>.<span class="title">lang</span>.<span class="title">Boolean</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> b = <span class="keyword">true</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">Boolean <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      b = !b;</span><br><span class="line">      <span class="keyword">return</span> java.lang.Boolean.valueOf(b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">Boolean <span class="title">get</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> java.lang.Boolean[] array(<span class="keyword">int</span> sz) &#123;</span><br><span class="line">      java.lang.Boolean[] result =</span><br><span class="line">        <span class="keyword">new</span> java.lang.Boolean[sz];</span><br><span class="line">      Arrays.setAll(result, n -&gt; get());</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Pboolean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> b = <span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      b = !b;</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">return</span> get(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span>[] array(<span class="keyword">int</span> sz) &#123;</span><br><span class="line">      <span class="keyword">return</span> primitive(<span class="keyword">new</span> Boolean().array(sz));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Byte</span></span></span><br><span class="line"><span class="class">  <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">java</span>.<span class="title">lang</span>.<span class="title">Byte</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span> b;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">Byte <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> b++; &#125;</span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">Byte <span class="title">get</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> java.lang.Byte[] array(<span class="keyword">int</span> sz) &#123;</span><br><span class="line">      java.lang.Byte[] result =</span><br><span class="line">        <span class="keyword">new</span> java.lang.Byte[sz];</span><br><span class="line">      Arrays.setAll(result, n -&gt; get());</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Pbyte</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span> b;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> b++; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">return</span> get(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] array(<span class="keyword">int</span> sz) &#123;</span><br><span class="line">      <span class="keyword">return</span> primitive(<span class="keyword">new</span> Byte().array(sz));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">char</span>[] CHARS =</span><br><span class="line">    <span class="string">"abcdefghijklmnopqrstuvwxyz"</span>.toCharArray();</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Character</span></span></span><br><span class="line"><span class="class">  <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">java</span>.<span class="title">lang</span>.<span class="title">Character</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">Character <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      i = (i + <span class="number">1</span>) % CHARS.length;</span><br><span class="line">      <span class="keyword">return</span> CHARS[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">Character <span class="title">get</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> java.lang.Character[] array(<span class="keyword">int</span> sz) &#123;</span><br><span class="line">      java.lang.Character[] result =</span><br><span class="line">        <span class="keyword">new</span> java.lang.Character[sz];</span><br><span class="line">      Arrays.setAll(result, n -&gt; get());</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Pchar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      i = (i + <span class="number">1</span>) % CHARS.length;</span><br><span class="line">      <span class="keyword">return</span> CHARS[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">return</span> get(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">char</span>[] array(<span class="keyword">int</span> sz) &#123;</span><br><span class="line">      <span class="keyword">return</span> primitive(<span class="keyword">new</span> Character().array(sz));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Short</span></span></span><br><span class="line"><span class="class">  <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">java</span>.<span class="title">lang</span>.<span class="title">Short</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">short</span> s;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">Short <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> s++; &#125;</span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">Short <span class="title">get</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> java.lang.Short[] array(<span class="keyword">int</span> sz) &#123;</span><br><span class="line">      java.lang.Short[] result =</span><br><span class="line">        <span class="keyword">new</span> java.lang.Short[sz];</span><br><span class="line">      Arrays.setAll(result, n -&gt; get());</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Pshort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">short</span> s;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">short</span> <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> s++; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">short</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">return</span> get(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">short</span>[] array(<span class="keyword">int</span> sz) &#123;</span><br><span class="line">      <span class="keyword">return</span> primitive(<span class="keyword">new</span> Short().array(sz));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Integer</span></span></span><br><span class="line"><span class="class">  <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">java</span>.<span class="title">lang</span>.<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">Integer <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i++; &#125;</span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">Integer <span class="title">get</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> java.lang.Integer[] array(<span class="keyword">int</span> sz) &#123;</span><br><span class="line">      java.lang.Integer[] result =</span><br><span class="line">        <span class="keyword">new</span> java.lang.Integer[sz];</span><br><span class="line">      Arrays.setAll(result, n -&gt; get());</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Pint</span> <span class="keyword">implements</span> <span class="title">IntSupplier</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i++; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">return</span> get(); &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAsInt</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> get(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] array(<span class="keyword">int</span> sz) &#123;</span><br><span class="line">      <span class="keyword">return</span> primitive(<span class="keyword">new</span> Integer().array(sz));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Long</span></span></span><br><span class="line"><span class="class">  <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">java</span>.<span class="title">lang</span>.<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> l;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">Long <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> l++; &#125;</span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">Long <span class="title">get</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> java.lang.Long[] array(<span class="keyword">int</span> sz) &#123;</span><br><span class="line">      java.lang.Long[] result =</span><br><span class="line">        <span class="keyword">new</span> java.lang.Long[sz];</span><br><span class="line">      Arrays.setAll(result, n -&gt; get());</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Plong</span> <span class="keyword">implements</span> <span class="title">LongSupplier</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> l;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> l++; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">return</span> get(); &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getAsLong</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> get(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span>[] array(<span class="keyword">int</span> sz) &#123;</span><br><span class="line">      <span class="keyword">return</span> primitive(<span class="keyword">new</span> Long().array(sz));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Float</span></span></span><br><span class="line"><span class="class">  <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">java</span>.<span class="title">lang</span>.<span class="title">Float</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">Float <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> java.lang.Float.valueOf(i++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">Float <span class="title">get</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> java.lang.Float[] array(<span class="keyword">int</span> sz) &#123;</span><br><span class="line">      java.lang.Float[] result =</span><br><span class="line">        <span class="keyword">new</span> java.lang.Float[sz];</span><br><span class="line">      Arrays.setAll(result, n -&gt; get());</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Pfloat</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i++; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">return</span> get(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span>[] array(<span class="keyword">int</span> sz) &#123;</span><br><span class="line">      <span class="keyword">return</span> primitive(<span class="keyword">new</span> Float().array(sz));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Double</span></span></span><br><span class="line"><span class="class">  <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">java</span>.<span class="title">lang</span>.<span class="title">Double</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">Double <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> java.lang.Double.valueOf(i++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">Double <span class="title">get</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> java.lang.Double[] array(<span class="keyword">int</span> sz) &#123;</span><br><span class="line">      java.lang.Double[] result =</span><br><span class="line">        <span class="keyword">new</span> java.lang.Double[sz];</span><br><span class="line">      Arrays.setAll(result, n -&gt; get());</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Pdouble</span> <span class="keyword">implements</span> <span class="title">DoubleSupplier</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i++; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">return</span> get(); &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getAsDouble</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> get(<span class="number">0</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] array(<span class="keyword">int</span> sz) &#123;</span><br><span class="line">      <span class="keyword">return</span> primitive(<span class="keyword">new</span> Double().array(sz));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 <strong>int</strong> ，<strong>long</strong> ，<strong>double</strong> 这三个有特殊 <strong>Supplier</strong> 接口的原始数据类型来说，<strong>Pint</strong> ， <strong>Plong</strong> 和 <strong>Pdouble</strong> 实现了这些接口。</p>
<p>这里是对 <strong>Count</strong> 的测试，这同样给我们提供了如何使用它的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arrays/TestCount.java</span></span><br><span class="line"><span class="comment">// Test counting generators</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> onjava.ArrayShow.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCount</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SZ = <span class="number">5</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Boolean"</span>);</span><br><span class="line">    Boolean[] a1 = <span class="keyword">new</span> Boolean[SZ];</span><br><span class="line">    Arrays.setAll(a1, <span class="keyword">new</span> Count.Boolean()::get);</span><br><span class="line">    show(a1);</span><br><span class="line">    a1 = Stream.generate(<span class="keyword">new</span> Count.Boolean())</span><br><span class="line">      .limit(SZ + <span class="number">1</span>).toArray(Boolean[]::<span class="keyword">new</span>);</span><br><span class="line">    show(a1);</span><br><span class="line">    a1 = <span class="keyword">new</span> Count.Boolean().array(SZ + <span class="number">2</span>);</span><br><span class="line">    show(a1);</span><br><span class="line">    <span class="keyword">boolean</span>[] a1b =</span><br><span class="line">      <span class="keyword">new</span> Count.Pboolean().array(SZ + <span class="number">3</span>);</span><br><span class="line">    show(a1b);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"Byte"</span>);</span><br><span class="line">    Byte[] a2 = <span class="keyword">new</span> Byte[SZ];</span><br><span class="line">    Arrays.setAll(a2, <span class="keyword">new</span> Count.Byte()::get);</span><br><span class="line">    show(a2);</span><br><span class="line">    a2 = Stream.generate(<span class="keyword">new</span> Count.Byte())</span><br><span class="line">      .limit(SZ + <span class="number">1</span>).toArray(Byte[]::<span class="keyword">new</span>);</span><br><span class="line">    show(a2);</span><br><span class="line">    a2 = <span class="keyword">new</span> Count.Byte().array(SZ + <span class="number">2</span>);</span><br><span class="line">    show(a2);</span><br><span class="line">    <span class="keyword">byte</span>[] a2b = <span class="keyword">new</span> Count.Pbyte().array(SZ + <span class="number">3</span>);</span><br><span class="line">    show(a2b);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"Character"</span>);</span><br><span class="line">    Character[] a3 = <span class="keyword">new</span> Character[SZ];</span><br><span class="line">    Arrays.setAll(a3, <span class="keyword">new</span> Count.Character()::get);</span><br><span class="line">    show(a3);</span><br><span class="line">    a3 = Stream.generate(<span class="keyword">new</span> Count.Character())</span><br><span class="line">      .limit(SZ + <span class="number">1</span>).toArray(Character[]::<span class="keyword">new</span>);</span><br><span class="line">    show(a3);</span><br><span class="line">    a3 = <span class="keyword">new</span> Count.Character().array(SZ + <span class="number">2</span>);</span><br><span class="line">    show(a3);</span><br><span class="line">    <span class="keyword">char</span>[] a3b = <span class="keyword">new</span> Count.Pchar().array(SZ + <span class="number">3</span>);</span><br><span class="line">    show(a3b);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"Short"</span>);</span><br><span class="line">    Short[] a4 = <span class="keyword">new</span> Short[SZ];</span><br><span class="line">    Arrays.setAll(a4, <span class="keyword">new</span> Count.Short()::get);</span><br><span class="line">    show(a4);</span><br><span class="line">    a4 = Stream.generate(<span class="keyword">new</span> Count.Short())</span><br><span class="line">      .limit(SZ + <span class="number">1</span>).toArray(Short[]::<span class="keyword">new</span>);</span><br><span class="line">    show(a4);</span><br><span class="line">    a4 = <span class="keyword">new</span> Count.Short().array(SZ + <span class="number">2</span>);</span><br><span class="line">    show(a4);</span><br><span class="line">    <span class="keyword">short</span>[] a4b = <span class="keyword">new</span> Count.Pshort().array(SZ + <span class="number">3</span>);</span><br><span class="line">    show(a4b);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"Integer"</span>);</span><br><span class="line">    <span class="keyword">int</span>[] a5 = <span class="keyword">new</span> <span class="keyword">int</span>[SZ];</span><br><span class="line">    Arrays.setAll(a5, <span class="keyword">new</span> Count.Integer()::get);</span><br><span class="line">    show(a5);</span><br><span class="line">    Integer[] a5b =</span><br><span class="line">      Stream.generate(<span class="keyword">new</span> Count.Integer())</span><br><span class="line">        .limit(SZ + <span class="number">1</span>).toArray(Integer[]::<span class="keyword">new</span>);</span><br><span class="line">    show(a5b);</span><br><span class="line">    a5b = <span class="keyword">new</span> Count.Integer().array(SZ + <span class="number">2</span>);</span><br><span class="line">    show(a5b);</span><br><span class="line">    a5 = IntStream.generate(<span class="keyword">new</span> Count.Pint())</span><br><span class="line">      .limit(SZ + <span class="number">1</span>).toArray();</span><br><span class="line">    show(a5);</span><br><span class="line">    a5 = <span class="keyword">new</span> Count.Pint().array(SZ + <span class="number">3</span>);</span><br><span class="line">    show(a5);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"Long"</span>);</span><br><span class="line">    <span class="keyword">long</span>[] a6 = <span class="keyword">new</span> <span class="keyword">long</span>[SZ];</span><br><span class="line">    Arrays.setAll(a6, <span class="keyword">new</span> Count.Long()::get);</span><br><span class="line">    show(a6);</span><br><span class="line">    Long[] a6b = Stream.generate(<span class="keyword">new</span> Count.Long())</span><br><span class="line">      .limit(SZ + <span class="number">1</span>).toArray(Long[]::<span class="keyword">new</span>);</span><br><span class="line">    show(a6b);</span><br><span class="line">    a6b = <span class="keyword">new</span> Count.Long().array(SZ + <span class="number">2</span>);</span><br><span class="line">    show(a6b);</span><br><span class="line">    a6 = LongStream.generate(<span class="keyword">new</span> Count.Plong())</span><br><span class="line">      .limit(SZ + <span class="number">1</span>).toArray();</span><br><span class="line">    show(a6);</span><br><span class="line">    a6 = <span class="keyword">new</span> Count.Plong().array(SZ + <span class="number">3</span>);</span><br><span class="line">    show(a6);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"Float"</span>);</span><br><span class="line">    Float[] a7 = <span class="keyword">new</span> Float[SZ];</span><br><span class="line">    Arrays.setAll(a7, <span class="keyword">new</span> Count.Float()::get);</span><br><span class="line">    show(a7);</span><br><span class="line">    a7 = Stream.generate(<span class="keyword">new</span> Count.Float())</span><br><span class="line">      .limit(SZ + <span class="number">1</span>).toArray(Float[]::<span class="keyword">new</span>);</span><br><span class="line">    show(a7);</span><br><span class="line">    a7 = <span class="keyword">new</span> Count.Float().array(SZ + <span class="number">2</span>);</span><br><span class="line">    show(a7);</span><br><span class="line">    <span class="keyword">float</span>[] a7b = <span class="keyword">new</span> Count.Pfloat().array(SZ + <span class="number">3</span>);</span><br><span class="line">    show(a7b);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"Double"</span>);</span><br><span class="line">    <span class="keyword">double</span>[] a8 = <span class="keyword">new</span> <span class="keyword">double</span>[SZ];</span><br><span class="line">    Arrays.setAll(a8, <span class="keyword">new</span> Count.Double()::get);</span><br><span class="line">    show(a8);</span><br><span class="line">    Double[] a8b =</span><br><span class="line">      Stream.generate(<span class="keyword">new</span> Count.Double())</span><br><span class="line">        .limit(SZ + <span class="number">1</span>).toArray(Double[]::<span class="keyword">new</span>);</span><br><span class="line">    show(a8b);</span><br><span class="line">    a8b = <span class="keyword">new</span> Count.Double().array(SZ + <span class="number">2</span>);</span><br><span class="line">    show(a8b);</span><br><span class="line">    a8 = DoubleStream.generate(<span class="keyword">new</span> Count.Pdouble())</span><br><span class="line">      .limit(SZ + <span class="number">1</span>).toArray();</span><br><span class="line">    show(a8);</span><br><span class="line">    a8 = <span class="keyword">new</span> Count.Pdouble().array(SZ + <span class="number">3</span>);</span><br><span class="line">    show(a8);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Boolean</span></span><br><span class="line"><span class="comment">[false, true, false, true, false]</span></span><br><span class="line"><span class="comment">[false, true, false, true, false, true]</span></span><br><span class="line"><span class="comment">[false, true, false, true, false, true, false]</span></span><br><span class="line"><span class="comment">[false, true, false, true, false, true, false, true]</span></span><br><span class="line"><span class="comment">Byte</span></span><br><span class="line"><span class="comment">[0, 1, 2, 3, 4]</span></span><br><span class="line"><span class="comment">[0, 1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="comment">[0, 1, 2, 3, 4, 5, 6]</span></span><br><span class="line"><span class="comment">[0, 1, 2, 3, 4, 5, 6, 7]</span></span><br><span class="line"><span class="comment">Character</span></span><br><span class="line"><span class="comment">[b, c, d, e, f]</span></span><br><span class="line"><span class="comment">[b, c, d, e, f, g]</span></span><br><span class="line"><span class="comment">[b, c, d, e, f, g, h]</span></span><br><span class="line"><span class="comment">[b, c, d, e, f, g, h, i]</span></span><br><span class="line"><span class="comment">Short</span></span><br><span class="line"><span class="comment">[0, 1, 2, 3, 4]</span></span><br><span class="line"><span class="comment">[0, 1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="comment">[0, 1, 2, 3, 4, 5, 6]</span></span><br><span class="line"><span class="comment">[0, 1, 2, 3, 4, 5, 6, 7]</span></span><br><span class="line"><span class="comment">Integer</span></span><br><span class="line"><span class="comment">[0, 1, 2, 3, 4]</span></span><br><span class="line"><span class="comment">[0, 1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="comment">[0, 1, 2, 3, 4, 5, 6]</span></span><br><span class="line"><span class="comment">[0, 1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="comment">[0, 1, 2, 3, 4, 5, 6, 7]</span></span><br><span class="line"><span class="comment">Long</span></span><br><span class="line"><span class="comment">[0, 1, 2, 3, 4]</span></span><br><span class="line"><span class="comment">[0, 1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="comment">[0, 1, 2, 3, 4, 5, 6]</span></span><br><span class="line"><span class="comment">[0, 1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="comment">[0, 1, 2, 3, 4, 5, 6, 7]</span></span><br><span class="line"><span class="comment">Float</span></span><br><span class="line"><span class="comment">[0.0, 1.0, 2.0, 3.0, 4.0]</span></span><br><span class="line"><span class="comment">[0.0, 1.0, 2.0, 3.0, 4.0, 5.0]</span></span><br><span class="line"><span class="comment">[0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0]</span></span><br><span class="line"><span class="comment">[0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0]</span></span><br><span class="line"><span class="comment">Double</span></span><br><span class="line"><span class="comment">[0.0, 1.0, 2.0, 3.0, 4.0]</span></span><br><span class="line"><span class="comment">[0.0, 1.0, 2.0, 3.0, 4.0, 5.0]</span></span><br><span class="line"><span class="comment">[0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0]</span></span><br><span class="line"><span class="comment">[0.0, 1.0, 2.0, 3.0, 4.0, 5.0]</span></span><br><span class="line"><span class="comment">[0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>注意到原始数组类型 <strong>int[]</strong> ，<strong>long[]</strong> ，<strong>double[]</strong> 可以直接被 <strong>Arrays.setAll()</strong> 填充，但是其他的原始类型都要求用包装器类型的数组。</p>
<p>通过 <strong>Stream.generate()</strong> 创建的包装数组显示了 <strong>toArray（）</strong> 的重载用法，在这里你应该提供给它要创建的数组类型的构造器。</p>
<!-- Random Generators -->

<h2 id="随机生成"><a href="#随机生成" class="headerlink" title="随机生成"></a>随机生成</h2><p>我们可以按照 <strong>Count.java</strong> 的结构创建一个生成随机值的工具：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/Rand.java</span></span><br><span class="line"><span class="comment">// (c)2017 MindView LLC: see Copyright.txt</span></span><br><span class="line"><span class="comment">// We make no guarantees that this code is fit for any purpose.</span></span><br><span class="line"><span class="comment">// Visit http://OnJava8.com for more book information.</span></span><br><span class="line"><span class="comment">// Generate random values of different types</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> onjava.ConvertTo.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Rand</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> MOD = <span class="number">10_000</span>;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Boolean</span></span></span><br><span class="line"><span class="class">  <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">java</span>.<span class="title">lang</span>.<span class="title">Boolean</span>&gt; </span>&#123;</span><br><span class="line">    SplittableRandom r = <span class="keyword">new</span> SplittableRandom(<span class="number">47</span>);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">Boolean <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> r.nextBoolean();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">Boolean <span class="title">get</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> java.lang.Boolean[] array(<span class="keyword">int</span> sz) &#123;</span><br><span class="line">      java.lang.Boolean[] result =</span><br><span class="line">        <span class="keyword">new</span> java.lang.Boolean[sz];</span><br><span class="line">      Arrays.setAll(result, n -&gt; get());</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Pboolean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span>[] array(<span class="keyword">int</span> sz) &#123;</span><br><span class="line">      <span class="keyword">return</span> primitive(<span class="keyword">new</span> Boolean().array(sz));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Byte</span></span></span><br><span class="line"><span class="class">  <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">java</span>.<span class="title">lang</span>.<span class="title">Byte</span>&gt; </span>&#123;</span><br><span class="line">    SplittableRandom r = <span class="keyword">new</span> SplittableRandom(<span class="number">47</span>);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">Byte <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="keyword">byte</span>)r.nextInt(MOD);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">Byte <span class="title">get</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> java.lang.Byte[] array(<span class="keyword">int</span> sz) &#123;</span><br><span class="line">      java.lang.Byte[] result =</span><br><span class="line">        <span class="keyword">new</span> java.lang.Byte[sz];</span><br><span class="line">      Arrays.setAll(result, n -&gt; get());</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Pbyte</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] array(<span class="keyword">int</span> sz) &#123;</span><br><span class="line">      <span class="keyword">return</span> primitive(<span class="keyword">new</span> Byte().array(sz));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Character</span></span></span><br><span class="line"><span class="class">  <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">java</span>.<span class="title">lang</span>.<span class="title">Character</span>&gt; </span>&#123;</span><br><span class="line">    SplittableRandom r = <span class="keyword">new</span> SplittableRandom(<span class="number">47</span>);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">Character <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="keyword">char</span>)r.nextInt(<span class="string">'a'</span>, <span class="string">'z'</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">Character <span class="title">get</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> java.lang.Character[] array(<span class="keyword">int</span> sz) &#123;</span><br><span class="line">      java.lang.Character[] result =</span><br><span class="line">        <span class="keyword">new</span> java.lang.Character[sz];</span><br><span class="line">      Arrays.setAll(result, n -&gt; get());</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Pchar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">char</span>[] array(<span class="keyword">int</span> sz) &#123;</span><br><span class="line">      <span class="keyword">return</span> primitive(<span class="keyword">new</span> Character().array(sz));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Short</span></span></span><br><span class="line"><span class="class">  <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">java</span>.<span class="title">lang</span>.<span class="title">Short</span>&gt; </span>&#123;</span><br><span class="line">    SplittableRandom r = <span class="keyword">new</span> SplittableRandom(<span class="number">47</span>);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">Short <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="keyword">short</span>)r.nextInt(MOD);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">Short <span class="title">get</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> java.lang.Short[] array(<span class="keyword">int</span> sz) &#123;</span><br><span class="line">      java.lang.Short[] result =</span><br><span class="line">        <span class="keyword">new</span> java.lang.Short[sz];</span><br><span class="line">      Arrays.setAll(result, n -&gt; get());</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Pshort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">short</span>[] array(<span class="keyword">int</span> sz) &#123;</span><br><span class="line">      <span class="keyword">return</span> primitive(<span class="keyword">new</span> Short().array(sz));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Integer</span></span></span><br><span class="line"><span class="class">  <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">java</span>.<span class="title">lang</span>.<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    SplittableRandom r = <span class="keyword">new</span> SplittableRandom(<span class="number">47</span>);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">Integer <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> r.nextInt(MOD);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">Integer <span class="title">get</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> java.lang.Integer[] array(<span class="keyword">int</span> sz) &#123;</span><br><span class="line">      <span class="keyword">int</span>[] primitive = <span class="keyword">new</span> Pint().array(sz);</span><br><span class="line">      java.lang.Integer[] result =</span><br><span class="line">        <span class="keyword">new</span> java.lang.Integer[sz];</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++)</span><br><span class="line">        result[i] = primitive[i];</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Pint</span> <span class="keyword">implements</span> <span class="title">IntSupplier</span> </span>&#123;</span><br><span class="line">    SplittableRandom r = <span class="keyword">new</span> SplittableRandom(<span class="number">47</span>);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAsInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> r.nextInt(MOD);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">return</span> getAsInt(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] array(<span class="keyword">int</span> sz) &#123;</span><br><span class="line">      <span class="keyword">return</span> r.ints(sz, <span class="number">0</span>, MOD).toArray();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Long</span></span></span><br><span class="line"><span class="class">  <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">java</span>.<span class="title">lang</span>.<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    SplittableRandom r = <span class="keyword">new</span> SplittableRandom(<span class="number">47</span>);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">Long <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> r.nextLong(MOD);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">Long <span class="title">get</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> java.lang.Long[] array(<span class="keyword">int</span> sz) &#123;</span><br><span class="line">      <span class="keyword">long</span>[] primitive = <span class="keyword">new</span> Plong().array(sz);</span><br><span class="line">      java.lang.Long[] result =</span><br><span class="line">        <span class="keyword">new</span> java.lang.Long[sz];</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++)</span><br><span class="line">        result[i] = primitive[i];</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Plong</span> <span class="keyword">implements</span> <span class="title">LongSupplier</span> </span>&#123;</span><br><span class="line">    SplittableRandom r = <span class="keyword">new</span> SplittableRandom(<span class="number">47</span>);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getAsLong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> r.nextLong(MOD);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">return</span> getAsLong(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span>[] array(<span class="keyword">int</span> sz) &#123;</span><br><span class="line">      <span class="keyword">return</span> r.longs(sz, <span class="number">0</span>, MOD).toArray();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Float</span></span></span><br><span class="line"><span class="class">  <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">java</span>.<span class="title">lang</span>.<span class="title">Float</span>&gt; </span>&#123;</span><br><span class="line">    SplittableRandom r = <span class="keyword">new</span> SplittableRandom(<span class="number">47</span>);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">Float <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="keyword">float</span>)trim(r.nextDouble());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">Float <span class="title">get</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> java.lang.Float[] array(<span class="keyword">int</span> sz) &#123;</span><br><span class="line">      java.lang.Float[] result =</span><br><span class="line">        <span class="keyword">new</span> java.lang.Float[sz];</span><br><span class="line">      Arrays.setAll(result, n -&gt; get());</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Pfloat</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span>[] array(<span class="keyword">int</span> sz) &#123;</span><br><span class="line">      <span class="keyword">return</span> primitive(<span class="keyword">new</span> Float().array(sz));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">trim</span><span class="params">(<span class="keyword">double</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">      ((<span class="keyword">double</span>)Math.round(d * <span class="number">1000.0</span>)) / <span class="number">100.0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Double</span></span></span><br><span class="line"><span class="class">  <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">java</span>.<span class="title">lang</span>.<span class="title">Double</span>&gt; </span>&#123;</span><br><span class="line">    SplittableRandom r = <span class="keyword">new</span> SplittableRandom(<span class="number">47</span>);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">Double <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> trim(r.nextDouble());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">Double <span class="title">get</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> java.lang.Double[] array(<span class="keyword">int</span> sz) &#123;</span><br><span class="line">      <span class="keyword">double</span>[] primitive =</span><br><span class="line">        <span class="keyword">new</span> Rand.Pdouble().array(sz);</span><br><span class="line">      java.lang.Double[] result =</span><br><span class="line">        <span class="keyword">new</span> java.lang.Double[sz];</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++)</span><br><span class="line">        result[i] = primitive[i];</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Pdouble</span> <span class="keyword">implements</span> <span class="title">DoubleSupplier</span> </span>&#123;</span><br><span class="line">    SplittableRandom r = <span class="keyword">new</span> SplittableRandom(<span class="number">47</span>);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getAsDouble</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> trim(r.nextDouble());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> getAsDouble();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] array(<span class="keyword">int</span> sz) &#123;</span><br><span class="line">      <span class="keyword">double</span>[] result = r.doubles(sz).toArray();</span><br><span class="line">      Arrays.setAll(result,</span><br><span class="line">        n -&gt; result[n] = trim(result[n]));</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">  <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">java</span>.<span class="title">lang</span>.<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    SplittableRandom r = <span class="keyword">new</span> SplittableRandom(<span class="number">47</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> strlen = <span class="number">7</span>; <span class="comment">// Default length</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">int</span> strLength)</span> </span>&#123;</span><br><span class="line">      strlen = strLength;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> r.ints(strlen, <span class="string">'a'</span>, <span class="string">'z'</span> + <span class="number">1</span>)</span><br><span class="line">        .collect(StringBuilder::<span class="keyword">new</span>,</span><br><span class="line">                 StringBuilder::appendCodePoint,</span><br><span class="line">                 StringBuilder::append).toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">get</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> java.lang.String[] array(<span class="keyword">int</span> sz) &#123;</span><br><span class="line">      java.lang.String[] result =</span><br><span class="line">        <span class="keyword">new</span> java.lang.String[sz];</span><br><span class="line">      Arrays.setAll(result, n -&gt; get());</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于除了 <strong>int</strong> 、 <strong>long</strong> 和 <strong>double</strong> 之外的所有基本类型元素生成器，只生成数组，而不是 Count 中看到的完整操作集。这只是一个设计选择，因为本书不需要额外的功能。</p>
<p>下面是对所有 <strong>Rand</strong> 工具的测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arrays/TestRand.java</span></span><br><span class="line"><span class="comment">// Test random generators</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> onjava.ArrayShow.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRand</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SZ = <span class="number">5</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Boolean"</span>);</span><br><span class="line">    Boolean[] a1 = <span class="keyword">new</span> Boolean[SZ];</span><br><span class="line">    Arrays.setAll(a1, <span class="keyword">new</span> Rand.Boolean()::get);</span><br><span class="line">    show(a1);</span><br><span class="line">    a1 = Stream.generate(<span class="keyword">new</span> Rand.Boolean())</span><br><span class="line">      .limit(SZ + <span class="number">1</span>).toArray(Boolean[]::<span class="keyword">new</span>);</span><br><span class="line">    show(a1);</span><br><span class="line">    a1 = <span class="keyword">new</span> Rand.Boolean().array(SZ + <span class="number">2</span>);</span><br><span class="line">    show(a1);</span><br><span class="line">    <span class="keyword">boolean</span>[] a1b =</span><br><span class="line">      <span class="keyword">new</span> Rand.Pboolean().array(SZ + <span class="number">3</span>);</span><br><span class="line">    show(a1b);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"Byte"</span>);</span><br><span class="line">    Byte[] a2 = <span class="keyword">new</span> Byte[SZ];</span><br><span class="line">    Arrays.setAll(a2, <span class="keyword">new</span> Rand.Byte()::get);</span><br><span class="line">    show(a2);</span><br><span class="line">    a2 = Stream.generate(<span class="keyword">new</span> Rand.Byte())</span><br><span class="line">      .limit(SZ + <span class="number">1</span>).toArray(Byte[]::<span class="keyword">new</span>);</span><br><span class="line">    show(a2);</span><br><span class="line">    a2 = <span class="keyword">new</span> Rand.Byte().array(SZ + <span class="number">2</span>);</span><br><span class="line">    show(a2);</span><br><span class="line">    <span class="keyword">byte</span>[] a2b = <span class="keyword">new</span> Rand.Pbyte().array(SZ + <span class="number">3</span>);</span><br><span class="line">    show(a2b);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"Character"</span>);</span><br><span class="line">    Character[] a3 = <span class="keyword">new</span> Character[SZ];</span><br><span class="line">    Arrays.setAll(a3, <span class="keyword">new</span> Rand.Character()::get);</span><br><span class="line">    show(a3);</span><br><span class="line">    a3 = Stream.generate(<span class="keyword">new</span> Rand.Character())</span><br><span class="line">      .limit(SZ + <span class="number">1</span>).toArray(Character[]::<span class="keyword">new</span>);</span><br><span class="line">    show(a3);</span><br><span class="line">    a3 = <span class="keyword">new</span> Rand.Character().array(SZ + <span class="number">2</span>);</span><br><span class="line">    show(a3);</span><br><span class="line">    <span class="keyword">char</span>[] a3b = <span class="keyword">new</span> Rand.Pchar().array(SZ + <span class="number">3</span>);</span><br><span class="line">    show(a3b);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"Short"</span>);</span><br><span class="line">    Short[] a4 = <span class="keyword">new</span> Short[SZ];</span><br><span class="line">    Arrays.setAll(a4, <span class="keyword">new</span> Rand.Short()::get);</span><br><span class="line">    show(a4);</span><br><span class="line">    a4 = Stream.generate(<span class="keyword">new</span> Rand.Short())</span><br><span class="line">      .limit(SZ + <span class="number">1</span>).toArray(Short[]::<span class="keyword">new</span>);</span><br><span class="line">    show(a4);</span><br><span class="line">    a4 = <span class="keyword">new</span> Rand.Short().array(SZ + <span class="number">2</span>);</span><br><span class="line">    show(a4);</span><br><span class="line">    <span class="keyword">short</span>[] a4b = <span class="keyword">new</span> Rand.Pshort().array(SZ + <span class="number">3</span>);</span><br><span class="line">    show(a4b);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"Integer"</span>);</span><br><span class="line">    <span class="keyword">int</span>[] a5 = <span class="keyword">new</span> <span class="keyword">int</span>[SZ];</span><br><span class="line">    Arrays.setAll(a5, <span class="keyword">new</span> Rand.Integer()::get);</span><br><span class="line">    show(a5);</span><br><span class="line">    Integer[] a5b =</span><br><span class="line">      Stream.generate(<span class="keyword">new</span> Rand.Integer())</span><br><span class="line">        .limit(SZ + <span class="number">1</span>).toArray(Integer[]::<span class="keyword">new</span>);</span><br><span class="line">    show(a5b);</span><br><span class="line">    a5b = <span class="keyword">new</span> Rand.Integer().array(SZ + <span class="number">2</span>);</span><br><span class="line">    show(a5b);</span><br><span class="line">    a5 = IntStream.generate(<span class="keyword">new</span> Rand.Pint())</span><br><span class="line">      .limit(SZ + <span class="number">1</span>).toArray();</span><br><span class="line">    show(a5);</span><br><span class="line">    a5 = <span class="keyword">new</span> Rand.Pint().array(SZ + <span class="number">3</span>);</span><br><span class="line">    show(a5);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"Long"</span>);</span><br><span class="line">    <span class="keyword">long</span>[] a6 = <span class="keyword">new</span> <span class="keyword">long</span>[SZ];</span><br><span class="line">    Arrays.setAll(a6, <span class="keyword">new</span> Rand.Long()::get);</span><br><span class="line">    show(a6);</span><br><span class="line">    Long[] a6b = Stream.generate(<span class="keyword">new</span> Rand.Long())</span><br><span class="line">      .limit(SZ + <span class="number">1</span>).toArray(Long[]::<span class="keyword">new</span>);</span><br><span class="line">    show(a6b);</span><br><span class="line">    a6b = <span class="keyword">new</span> Rand.Long().array(SZ + <span class="number">2</span>);</span><br><span class="line">    show(a6b);</span><br><span class="line">    a6 = LongStream.generate(<span class="keyword">new</span> Rand.Plong())</span><br><span class="line">      .limit(SZ + <span class="number">1</span>).toArray();</span><br><span class="line">    show(a6);</span><br><span class="line">    a6 = <span class="keyword">new</span> Rand.Plong().array(SZ + <span class="number">3</span>);</span><br><span class="line">    show(a6);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"Float"</span>);</span><br><span class="line">    Float[] a7 = <span class="keyword">new</span> Float[SZ];</span><br><span class="line">    Arrays.setAll(a7, <span class="keyword">new</span> Rand.Float()::get);</span><br><span class="line">    show(a7);</span><br><span class="line">    a7 = Stream.generate(<span class="keyword">new</span> Rand.Float())</span><br><span class="line">      .limit(SZ + <span class="number">1</span>).toArray(Float[]::<span class="keyword">new</span>);</span><br><span class="line">    show(a7);</span><br><span class="line">    a7 = <span class="keyword">new</span> Rand.Float().array(SZ + <span class="number">2</span>);</span><br><span class="line">    show(a7);</span><br><span class="line">    <span class="keyword">float</span>[] a7b = <span class="keyword">new</span> Rand.Pfloat().array(SZ + <span class="number">3</span>);</span><br><span class="line">    show(a7b);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"Double"</span>);</span><br><span class="line">    <span class="keyword">double</span>[] a8 = <span class="keyword">new</span> <span class="keyword">double</span>[SZ];</span><br><span class="line">    Arrays.setAll(a8, <span class="keyword">new</span> Rand.Double()::get);</span><br><span class="line">    show(a8);</span><br><span class="line">    Double[] a8b =</span><br><span class="line">      Stream.generate(<span class="keyword">new</span> Rand.Double())</span><br><span class="line">        .limit(SZ + <span class="number">1</span>).toArray(Double[]::<span class="keyword">new</span>);</span><br><span class="line">    show(a8b);</span><br><span class="line">    a8b = <span class="keyword">new</span> Rand.Double().array(SZ + <span class="number">2</span>);</span><br><span class="line">    show(a8b);</span><br><span class="line">    a8 = DoubleStream.generate(<span class="keyword">new</span> Rand.Pdouble())</span><br><span class="line">      .limit(SZ + <span class="number">1</span>).toArray();</span><br><span class="line">    show(a8);</span><br><span class="line">    a8 = <span class="keyword">new</span> Rand.Pdouble().array(SZ + <span class="number">3</span>);</span><br><span class="line">    show(a8);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"String"</span>);</span><br><span class="line">    String[] s = <span class="keyword">new</span> String[SZ - <span class="number">1</span>];</span><br><span class="line">    Arrays.setAll(s, <span class="keyword">new</span> Rand.String()::get);</span><br><span class="line">    show(s);</span><br><span class="line">    s = Stream.generate(<span class="keyword">new</span> Rand.String())</span><br><span class="line">      .limit(SZ).toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line">    show(s);</span><br><span class="line">    s = <span class="keyword">new</span> Rand.String().array(SZ + <span class="number">1</span>);</span><br><span class="line">    show(s);</span><br><span class="line"></span><br><span class="line">    Arrays.setAll(s, <span class="keyword">new</span> Rand.String(<span class="number">4</span>)::get);</span><br><span class="line">    show(s);</span><br><span class="line">    s = Stream.generate(<span class="keyword">new</span> Rand.String(<span class="number">4</span>))</span><br><span class="line">      .limit(SZ).toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line">    show(s);</span><br><span class="line">    s = <span class="keyword">new</span> Rand.String(<span class="number">4</span>).array(SZ + <span class="number">1</span>);</span><br><span class="line">    show(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Boolean</span></span><br><span class="line"><span class="comment">[true, false, true, true, true]</span></span><br><span class="line"><span class="comment">[true, false, true, true, true, false]</span></span><br><span class="line"><span class="comment">[true, false, true, true, true, false, false]</span></span><br><span class="line"><span class="comment">[true, false, true, true, true, false, false, true]</span></span><br><span class="line"><span class="comment">Byte</span></span><br><span class="line"><span class="comment">[123, 33, 101, 112, 33]</span></span><br><span class="line"><span class="comment">[123, 33, 101, 112, 33, 31]</span></span><br><span class="line"><span class="comment">[123, 33, 101, 112, 33, 31, 0]</span></span><br><span class="line"><span class="comment">[123, 33, 101, 112, 33, 31, 0, -72]</span></span><br><span class="line"><span class="comment">Character</span></span><br><span class="line"><span class="comment">[b, t, p, e, n]</span></span><br><span class="line"><span class="comment">[b, t, p, e, n, p]</span></span><br><span class="line"><span class="comment">[b, t, p, e, n, p, c]</span></span><br><span class="line"><span class="comment">[b, t, p, e, n, p, c, c]</span></span><br><span class="line"><span class="comment">Short</span></span><br><span class="line"><span class="comment">[635, 8737, 3941, 4720, 6177]</span></span><br><span class="line"><span class="comment">[635, 8737, 3941, 4720, 6177, 8479]</span></span><br><span class="line"><span class="comment">[635, 8737, 3941, 4720, 6177, 8479, 6656]</span></span><br><span class="line"><span class="comment">[635, 8737, 3941, 4720, 6177, 8479, 6656, 3768]</span></span><br><span class="line"><span class="comment">Integer</span></span><br><span class="line"><span class="comment">[635, 8737, 3941, 4720, 6177]</span></span><br><span class="line"><span class="comment">[635, 8737, 3941, 4720, 6177, 8479]</span></span><br><span class="line"><span class="comment">[635, 8737, 3941, 4720, 6177, 8479, 6656]</span></span><br><span class="line"><span class="comment">[635, 8737, 3941, 4720, 6177, 8479]</span></span><br><span class="line"><span class="comment">[635, 8737, 3941, 4720, 6177, 8479, 6656, 3768]</span></span><br><span class="line"><span class="comment">Long</span></span><br><span class="line"><span class="comment">[6882, 3765, 692, 9575, 4439]</span></span><br><span class="line"><span class="comment">[6882, 3765, 692, 9575, 4439, 2638]</span></span><br><span class="line"><span class="comment">[6882, 3765, 692, 9575, 4439, 2638, 4011]</span></span><br><span class="line"><span class="comment">[6882, 3765, 692, 9575, 4439, 2638]</span></span><br><span class="line"><span class="comment">[6882, 3765, 692, 9575, 4439, 2638, 4011, 9610]</span></span><br><span class="line"><span class="comment">Float</span></span><br><span class="line"><span class="comment">[4.83, 2.89, 2.9, 1.97, 3.01]</span></span><br><span class="line"><span class="comment">[4.83, 2.89, 2.9, 1.97, 3.01, 0.18]</span></span><br><span class="line"><span class="comment">[4.83, 2.89, 2.9, 1.97, 3.01, 0.18, 0.99]</span></span><br><span class="line"><span class="comment">[4.83, 2.89, 2.9, 1.97, 3.01, 0.18, 0.99, 8.28]</span></span><br><span class="line"><span class="comment">Double</span></span><br><span class="line"><span class="comment">[4.83, 2.89, 2.9, 1.97, 3.01]</span></span><br><span class="line"><span class="comment">[4.83, 2.89, 2.9, 1.97, 3.01, 0.18]</span></span><br><span class="line"><span class="comment">[4.83, 2.89, 2.9, 1.97, 3.01, 0.18, 0.99]</span></span><br><span class="line"><span class="comment">[4.83, 2.89, 2.9, 1.97, 3.01, 0.18]</span></span><br><span class="line"><span class="comment">[4.83, 2.89, 2.9, 1.97, 3.01, 0.18, 0.99, 8.28]</span></span><br><span class="line"><span class="comment">String</span></span><br><span class="line"><span class="comment">[btpenpc, cuxszgv, gmeinne, eloztdv]</span></span><br><span class="line"><span class="comment">[btpenpc, cuxszgv, gmeinne, eloztdv, ewcippc]</span></span><br><span class="line"><span class="comment">[btpenpc, cuxszgv, gmeinne, eloztdv, ewcippc, ygpoalk]</span></span><br><span class="line"><span class="comment">[btpe, npcc, uxsz, gvgm, einn, eelo]</span></span><br><span class="line"><span class="comment">[btpe, npcc, uxsz, gvgm, einn]</span></span><br><span class="line"><span class="comment">[btpe, npcc, uxsz, gvgm, einn, eelo]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>注意（除了 <strong>String</strong> 部分之外），这段代码与 <strong>TestCount.java</strong> 中的代码相同，<strong>Count</strong> 被 <strong>Rand</strong> 替换。</p>
<!-- Generics and Primitive Arrays -->

<h2 id="泛型和基本数组"><a href="#泛型和基本数组" class="headerlink" title="泛型和基本数组"></a>泛型和基本数组</h2><p>在本章的前面，我们被提醒，泛型不能和基元一起工作。在这种情况下，我们必须从基元数组转换为包装类型的数组，并且还必须从另一个方向转换。下面是一个转换器可以同时对所有类型的数据执行操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/ConvertTo.java</span></span><br><span class="line"><span class="comment">// (c)2017 MindView LLC: see Copyright.txt</span></span><br><span class="line"><span class="comment">// We make no guarantees that this code is fit for any purpose.</span></span><br><span class="line"><span class="comment">// Visit http://OnJava8.com for more book information.</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConvertTo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">boolean</span>[] primitive(Boolean[] in) &#123;</span><br><span class="line">    <span class="keyword">boolean</span>[] result = <span class="keyword">new</span> <span class="keyword">boolean</span>[in.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; in.length; i++)</span><br><span class="line">      result[i] = in[i]; <span class="comment">// Autounboxing</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span>[] primitive(Character[] in) &#123;</span><br><span class="line">    <span class="keyword">char</span>[] result = <span class="keyword">new</span> <span class="keyword">char</span>[in.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; in.length; i++)</span><br><span class="line">      result[i] = in[i];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">byte</span>[] primitive(Byte[] in) &#123;</span><br><span class="line">    <span class="keyword">byte</span>[] result = <span class="keyword">new</span> <span class="keyword">byte</span>[in.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; in.length; i++)</span><br><span class="line">      result[i] = in[i];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">short</span>[] primitive(Short[] in) &#123;</span><br><span class="line">    <span class="keyword">short</span>[] result = <span class="keyword">new</span> <span class="keyword">short</span>[in.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; in.length; i++)</span><br><span class="line">      result[i] = in[i];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span>[] primitive(Integer[] in) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[in.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; in.length; i++)</span><br><span class="line">      result[i] = in[i];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">long</span>[] primitive(Long[] in) &#123;</span><br><span class="line">    <span class="keyword">long</span>[] result = <span class="keyword">new</span> <span class="keyword">long</span>[in.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; in.length; i++)</span><br><span class="line">      result[i] = in[i];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">float</span>[] primitive(Float[] in) &#123;</span><br><span class="line">    <span class="keyword">float</span>[] result = <span class="keyword">new</span> <span class="keyword">float</span>[in.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; in.length; i++)</span><br><span class="line">      result[i] = in[i];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">double</span>[] primitive(Double[] in) &#123;</span><br><span class="line">    <span class="keyword">double</span>[] result = <span class="keyword">new</span> <span class="keyword">double</span>[in.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; in.length; i++)</span><br><span class="line">      result[i] = in[i];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Convert from primitive array to wrapped array:</span></span><br><span class="line">  <span class="keyword">static</span> Boolean[] boxed(<span class="keyword">boolean</span>[] in) &#123;</span><br><span class="line">    Boolean[] result = <span class="keyword">new</span> Boolean[in.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; in.length; i++)</span><br><span class="line">      result[i] = in[i]; <span class="comment">// Autoboxing</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> Character[] boxed(<span class="keyword">char</span>[] in) &#123;</span><br><span class="line">    Character[] result = <span class="keyword">new</span> Character[in.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; in.length; i++)</span><br><span class="line">      result[i] = in[i];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> Byte[] boxed(<span class="keyword">byte</span>[] in) &#123;</span><br><span class="line">    Byte[] result = <span class="keyword">new</span> Byte[in.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; in.length; i++)</span><br><span class="line">      result[i] = in[i];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> Short[] boxed(<span class="keyword">short</span>[] in) &#123;</span><br><span class="line">    Short[] result = <span class="keyword">new</span> Short[in.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; in.length; i++)</span><br><span class="line">      result[i] = in[i];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> Integer[] boxed(<span class="keyword">int</span>[] in) &#123;</span><br><span class="line">    Integer[] result = <span class="keyword">new</span> Integer[in.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; in.length; i++)</span><br><span class="line">      result[i] = in[i];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> Long[] boxed(<span class="keyword">long</span>[] in) &#123;</span><br><span class="line">    Long[] result = <span class="keyword">new</span> Long[in.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; in.length; i++)</span><br><span class="line">      result[i] = in[i];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> Float[] boxed(<span class="keyword">float</span>[] in) &#123;</span><br><span class="line">    Float[] result = <span class="keyword">new</span> Float[in.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; in.length; i++)</span><br><span class="line">      result[i] = in[i];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> Double[] boxed(<span class="keyword">double</span>[] in) &#123;</span><br><span class="line">    Double[] result = <span class="keyword">new</span> Double[in.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; in.length; i++)</span><br><span class="line">      result[i] = in[i];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>primitive()</strong> 的每个版本都创建一个准确长度的适当基元数组，然后从包装类的 <strong>in</strong> 数组中复制元素。如果任何包装的数组元素是 <strong>null</strong> ，你将得到一个异常（这是合理的—否则无法选择有意义的值进行替换)。注意在这个任务中自动装箱如何发生。</p>
<p>下面是对 <strong>ConvertTo</strong> 中所有方法的测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arrays/TestConvertTo.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> onjava.ArrayShow.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> onjava.ConvertTo.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConvertTo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">6</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Boolean[] a1 = <span class="keyword">new</span> Boolean[SIZE];</span><br><span class="line">    Arrays.setAll(a1, <span class="keyword">new</span> Rand.Boolean()::get);</span><br><span class="line">    <span class="keyword">boolean</span>[] a1p = primitive(a1);</span><br><span class="line">    show(<span class="string">"a1p"</span>, a1p);</span><br><span class="line">    Boolean[] a1b = boxed(a1p);</span><br><span class="line">    show(<span class="string">"a1b"</span>, a1b);</span><br><span class="line"></span><br><span class="line">    Byte[] a2 = <span class="keyword">new</span> Byte[SIZE];</span><br><span class="line">    Arrays.setAll(a2, <span class="keyword">new</span> Rand.Byte()::get);</span><br><span class="line">    <span class="keyword">byte</span>[] a2p = primitive(a2);</span><br><span class="line">    show(<span class="string">"a2p"</span>, a2p);</span><br><span class="line">    Byte[] a2b = boxed(a2p);</span><br><span class="line">    show(<span class="string">"a2b"</span>, a2b);</span><br><span class="line"></span><br><span class="line">    Character[] a3 = <span class="keyword">new</span> Character[SIZE];</span><br><span class="line">    Arrays.setAll(a3, <span class="keyword">new</span> Rand.Character()::get);</span><br><span class="line">    <span class="keyword">char</span>[] a3p = primitive(a3);</span><br><span class="line">    show(<span class="string">"a3p"</span>, a3p);</span><br><span class="line">    Character[] a3b = boxed(a3p);</span><br><span class="line">    show(<span class="string">"a3b"</span>, a3b);</span><br><span class="line"></span><br><span class="line">    Short[] a4 = <span class="keyword">new</span> Short[SIZE];</span><br><span class="line">    Arrays.setAll(a4, <span class="keyword">new</span> Rand.Short()::get);</span><br><span class="line">    <span class="keyword">short</span>[] a4p = primitive(a4);</span><br><span class="line">    show(<span class="string">"a4p"</span>, a4p);</span><br><span class="line">    Short[] a4b = boxed(a4p);</span><br><span class="line">    show(<span class="string">"a4b"</span>, a4b);</span><br><span class="line"></span><br><span class="line">    Integer[] a5 = <span class="keyword">new</span> Integer[SIZE];</span><br><span class="line">    Arrays.setAll(a5, <span class="keyword">new</span> Rand.Integer()::get);</span><br><span class="line">    <span class="keyword">int</span>[] a5p = primitive(a5);</span><br><span class="line">    show(<span class="string">"a5p"</span>, a5p);</span><br><span class="line">    Integer[] a5b = boxed(a5p);</span><br><span class="line">    show(<span class="string">"a5b"</span>, a5b);</span><br><span class="line"></span><br><span class="line">    Long[] a6 = <span class="keyword">new</span> Long[SIZE];</span><br><span class="line">    Arrays.setAll(a6, <span class="keyword">new</span> Rand.Long()::get);</span><br><span class="line">    <span class="keyword">long</span>[] a6p = primitive(a6);</span><br><span class="line">    show(<span class="string">"a6p"</span>, a6p);</span><br><span class="line">    Long[] a6b = boxed(a6p);</span><br><span class="line">    show(<span class="string">"a6b"</span>, a6b);</span><br><span class="line"></span><br><span class="line">    Float[] a7 = <span class="keyword">new</span> Float[SIZE];</span><br><span class="line">    Arrays.setAll(a7, <span class="keyword">new</span> Rand.Float()::get);</span><br><span class="line">    <span class="keyword">float</span>[] a7p = primitive(a7);</span><br><span class="line">    show(<span class="string">"a7p"</span>, a7p);</span><br><span class="line">    Float[] a7b = boxed(a7p);</span><br><span class="line">    show(<span class="string">"a7b"</span>, a7b);</span><br><span class="line"></span><br><span class="line">    Double[] a8 = <span class="keyword">new</span> Double[SIZE];</span><br><span class="line">    Arrays.setAll(a8, <span class="keyword">new</span> Rand.Double()::get);</span><br><span class="line">    <span class="keyword">double</span>[] a8p = primitive(a8);</span><br><span class="line">    show(<span class="string">"a8p"</span>, a8p);</span><br><span class="line">    Double[] a8b = boxed(a8p);</span><br><span class="line">    show(<span class="string">"a8b"</span>, a8b);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">a1p: [true, false, true, true, true, false]</span></span><br><span class="line"><span class="comment">a1b: [true, false, true, true, true, false]</span></span><br><span class="line"><span class="comment">a2p: [123, 33, 101, 112, 33, 31]</span></span><br><span class="line"><span class="comment">a2b: [123, 33, 101, 112, 33, 31]</span></span><br><span class="line"><span class="comment">a3p: [b, t, p, e, n, p]</span></span><br><span class="line"><span class="comment">a3b: [b, t, p, e, n, p]</span></span><br><span class="line"><span class="comment">a4p: [635, 8737, 3941, 4720, 6177, 8479]</span></span><br><span class="line"><span class="comment">a4b: [635, 8737, 3941, 4720, 6177, 8479]</span></span><br><span class="line"><span class="comment">a5p: [635, 8737, 3941, 4720, 6177, 8479]</span></span><br><span class="line"><span class="comment">a5b: [635, 8737, 3941, 4720, 6177, 8479]</span></span><br><span class="line"><span class="comment">a6p: [6882, 3765, 692, 9575, 4439, 2638]</span></span><br><span class="line"><span class="comment">a6b: [6882, 3765, 692, 9575, 4439, 2638]</span></span><br><span class="line"><span class="comment">a7p: [4.83, 2.89, 2.9, 1.97, 3.01, 0.18]</span></span><br><span class="line"><span class="comment">a7b: [4.83, 2.89, 2.9, 1.97, 3.01, 0.18]</span></span><br><span class="line"><span class="comment">a8p: [4.83, 2.89, 2.9, 1.97, 3.01, 0.18]</span></span><br><span class="line"><span class="comment">a8b: [4.83, 2.89, 2.9, 1.97, 3.01, 0.18]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>在每种情况下，原始数组都是为包装类型创建的，并使用 <strong>Arrays.setAll()</strong> 填充，正如我们在 <strong>TestCouner.java</strong> 中所做的那样（这也验证了 <strong>Arrays.setAll()</strong> 是否能同 <strong>Integer</strong> ，<strong>Long</strong> ，和 <strong>Double</strong> ）。然后 <strong>ConvertTo.primitive()</strong>  将包装器数组转换为对应的基元数组，<strong>ConverTo.boxed()</strong> 将其转换回来。</p>
<!-- Modifying Existing Array Elements -->

<h2 id="数组元素修改"><a href="#数组元素修改" class="headerlink" title="数组元素修改"></a>数组元素修改</h2><p>传递给 <strong>Arrays.setAll()</strong> 的生成器函数可以使用它接收到的数组索引修改现有的数组元素:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arrays/ModifyExisting.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> onjava.ArrayShow.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModifyExisting</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span>[] da = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">7</span>];</span><br><span class="line">        Arrays.setAll(da, <span class="keyword">new</span> Rand.Double()::get);</span><br><span class="line">        show(da);</span><br><span class="line">        Arrays.setAll(da, n -&gt; da[n] / <span class="number">100</span>); <span class="comment">// [1]</span></span><br><span class="line">        show(da);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[4.83, 2.89, 2.9, 1.97, 3.01, 0.18, 0.99]</span></span><br><span class="line"><span class="comment">[0.0483, 0.028900000000000002, 0.028999999999999998,</span></span><br><span class="line"><span class="comment">0.0197, 0.0301, 0.0018, 0.009899999999999999]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>[1] Lambdas在这里特别有用，因为数组总是在lambda表达式的范围内。</p>
<!-- An Aside On Parallelism -->

<h2 id="数组并行"><a href="#数组并行" class="headerlink" title="数组并行"></a>数组并行</h2><p>我们很快就不得不面对并行的主题。例如，“并行”一词在许多Java库方法中使用。您可能听说过类似“并行程序运行得更快”这样的说法，这是有道理的—当您可以有多个处理器时，为什么只有一个处理器在您的程序上工作呢? 如果您认为您应该利用其中的“并行”，这是很容易被原谅的。<br>要是这么简单就好了。不幸的是，通过采用这种方法，您可以很容易地编写比非并行版本运行速度更慢的代码。在你深刻理解所有的问题之前，并行编程看起来更像是一门艺术而非科学。<br>以下是简短的版本:用简单的方法编写代码。不要开始处理并行性，除非它成为一个问题。您仍然会遇到并行性。在本章中，我们将介绍一些为并行执行而编写的Java库方法。因此，您必须对它有足够的了解，以便进行基本的讨论，并避免出现错误。</p>
<p>在阅读并发编程这一章之后，您将更深入地理解它(但是，唉，这还远远不够。只是这些的话，充分理解这个主题是不可能的)。<br>在某些情况下，即使您只有一个处理器，无论您是否显式地尝试并行，并行实现是惟一的、最佳的或最符合逻辑的选择。它是一个可以一直使用的工具，所以您必须了解它的相关问题。</p>
<p>最好从数据的角度来考虑并行性。对于大量数据(以及可用的额外处理器)，并行可能会有所帮助。但您也可能使事情变得更糟。</p>
<p>在本书的其余部分，我们将遇到不同的情况:</p>
<ul>
<li>1、所提供的惟一选项是并行的。这很简单，因为我们别无选择，只能使用它。这种情况是比较罕见的。</li>
<li>2、有多个选项，但是并行版本(通常是最新的版本)被设计成在任何地方都可以使用(甚至在那些不关心并行性的代码中)，如案例#1。我们将按预期使用并行版本。</li>
<li>3、案例1和案例2并不经常发生。相反，您将遇到某些算法的两个版本，一个用于并行使用，另一个用于正常使用。我将描述并行的一个，但不会在普通代码中使用它，因为它也许会产生所有可能的问题。</li>
</ul>
<p>我建议您在自己的代码中采用这种方法。</p>
<p>[<a href="http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html]" target="_blank" rel="noopener">http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html]</a>(要进一步了解为什么这是一个难题，请参阅Doug Lea的文章。)</p>
<p><strong>parallelSetAll()</strong></p>
<p>流式编程产生优雅的代码。例如，假设我们想要创建一个数值由从零开始填充的长数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arrays/CountUpward.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.stream.LongStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountUpward</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">long</span>[] fillCounted(<span class="keyword">int</span> size) &#123;</span><br><span class="line">        <span class="keyword">return</span> LongStream.iterate(<span class="number">0</span>, i -&gt; i + <span class="number">1</span>).limit(size).toArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span>[] l1 = fillCounted(<span class="number">20</span>); <span class="comment">// No problem</span></span><br><span class="line">        show(l1);</span><br><span class="line">        <span class="comment">// On my machine, this runs out of heap space:</span></span><br><span class="line">        <span class="comment">// - long[] l2 = fillCounted(10_000_000);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,</span></span><br><span class="line"><span class="comment">16, 17, 18, 19]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>流</strong> 实际上可以存储到将近1000万，但是之后就会耗尽堆空间。常规的 <strong>setAll()</strong> 是有效的，但是如果我们能更快地处理如此大量的数字，那就更好了。<br>我们可以使用 <strong>setAll()</strong> 初始化更大的数组。如果速度成为一个问题，<strong>Arrays.parallelSetAll()</strong> 将(可能)更快地执行初始化(请记住并行性中描述的问题)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arrays/ParallelSetAll.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParallelSetAll</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">10_000_000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">intArray</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ia = <span class="keyword">new</span> <span class="keyword">int</span>[SIZE];</span><br><span class="line">        Arrays.setAll(ia, <span class="keyword">new</span> Rand.Pint()::get);</span><br><span class="line">        Arrays.parallelSetAll(ia, <span class="keyword">new</span> Rand.Pint()::get);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">longArray</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span>[] la = <span class="keyword">new</span> <span class="keyword">long</span>[SIZE];</span><br><span class="line">        Arrays.setAll(la, <span class="keyword">new</span> Rand.Plong()::get);</span><br><span class="line">        Arrays.parallelSetAll(la, <span class="keyword">new</span> Rand.Plong()::get);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        intArray();</span><br><span class="line">        longArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组分配和初始化是在单独的方法中执行的，因为如果两个数组都在 <strong>main()</strong> 中分配，它会耗尽内存(至少在我的机器上是这样。还有一些方法可以告诉Java在启动时分配更多的内存)。</p>
<!-- Arrays Utilities -->

<h2 id="Arrays工具类"><a href="#Arrays工具类" class="headerlink" title="Arrays工具类"></a>Arrays工具类</h2><p>您已经看到了 <strong>java.util.Arrays</strong> 中的 <strong>fill()</strong> 和 <strong>setAll()/parallelSetAll()</strong> 。该类包含许多其他有用的 <strong>静态</strong> 程序方法，我们将对此进行研究。</p>
<p>概述:</p>
<ul>
<li><strong>asList()</strong>: 获取任何序列或数组，并将其转换为一个 <strong>列表集合</strong> （集合章节介绍了此方法）。</li>
<li><strong>copyOf()</strong>：以新的长度创建现有数组的新副本。</li>
<li><strong>copyOfRange()</strong>：创建现有数组的一部分的新副本。</li>
<li><strong>equals()</strong>：比较两个数组是否相等。</li>
<li><strong>deepEquals()</strong>：多维数组的相等性比较。</li>
<li><strong>stream()</strong>：生成数组元素的流。</li>
<li><strong>hashCode()</strong>：生成数组的哈希值(您将在附录中了解这意味着什么:理解equals()和hashCode())。</li>
<li><strong>deepHashCode()</strong>: 多维数组的哈希值。</li>
<li><strong>sort()</strong>：排序数组</li>
<li><strong>parallelSort()</strong>：对数组进行并行排序，以提高速度。</li>
<li><strong>binarySearch()</strong>：在已排序的数组中查找元素。</li>
<li><strong>parallelPrefix()</strong>：使用提供的函数并行累积(以获得速度)。基本上，就是数组的reduce()。</li>
<li><strong>spliterator()</strong>：从数组中产生一个Spliterator;这是本书没有涉及到的流的高级部分。</li>
<li><strong>toString()</strong>：为数组生成一个字符串表示。你在整个章节中经常看到这种用法。</li>
<li><strong>deepToString()</strong>：为多维数组生成一个字符串。你在整个章节中经常看到这种用法。对于所有基本类型和对象，所有这些方法都是重载的。</li>
</ul>
<!-- Copying an Array -->

<h2 id="数组拷贝"><a href="#数组拷贝" class="headerlink" title="数组拷贝"></a>数组拷贝</h2><p>与使用for循环手工执行复制相比，<strong>copyOf()</strong> 和 <strong>copyOfRange()</strong> 复制数组<strong>要快得多</strong>。这些方法被重载以处理所有类型。</p>
<p>我们开始复制数组的整数和整数:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arrays/ArrayCopying.java</span></span><br><span class="line"><span class="comment">// Demonstrate Arrays.copy() and Arrays.copyOf()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> onjava.ArrayShow.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sup</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Superclass</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    Sup(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        id = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getSimpleName() + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Sup</span> </span>&#123; <span class="comment">// Subclass</span></span><br><span class="line"></span><br><span class="line">    Sub(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">super</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayCopying</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SZ = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a1 = <span class="keyword">new</span> <span class="keyword">int</span>[SZ];</span><br><span class="line">        Arrays.setAll(a1, <span class="keyword">new</span> Count.Integer()::get);</span><br><span class="line">        show(<span class="string">"a1"</span>, a1);</span><br><span class="line">        <span class="keyword">int</span>[] a2 = Arrays.copyOf(a1, a1.length); <span class="comment">// [1]</span></span><br><span class="line">        <span class="comment">// Prove they are distinct arrays:</span></span><br><span class="line">        Arrays.fill(a1, <span class="number">1</span>);</span><br><span class="line">        show(<span class="string">"a1"</span>, a1);</span><br><span class="line">        show(<span class="string">"a2"</span>, a2);</span><br><span class="line">        <span class="comment">// Create a shorter result:</span></span><br><span class="line">        a2 = Arrays.copyOf(a2, a2.length / <span class="number">2</span>); <span class="comment">// [2]</span></span><br><span class="line">        show(<span class="string">"a2"</span>, a2);</span><br><span class="line">        <span class="comment">// Allocate more space:</span></span><br><span class="line">        a2 = Arrays.copyOf(a2, a2.length + <span class="number">5</span>);</span><br><span class="line">        show(<span class="string">"a2"</span>, a2);</span><br><span class="line">        <span class="comment">// Also copies wrapped arrays:</span></span><br><span class="line">        Integer[] a3 = <span class="keyword">new</span> Integer[SZ]; <span class="comment">// [3]</span></span><br><span class="line">        Arrays.setAll(a3, <span class="keyword">new</span> Count.Integer()::get);</span><br><span class="line">        Integer[] a4 = Arrays.copyOfRange(a3, <span class="number">4</span>, <span class="number">12</span>);</span><br><span class="line">        show(<span class="string">"a4"</span>, a4);</span><br><span class="line">        Sub[] d = <span class="keyword">new</span> Sub[SZ / <span class="number">2</span>];</span><br><span class="line">        Arrays.setAll(d, Sub::<span class="keyword">new</span>); <span class="comment">// Produce Sup[] from Sub[]:</span></span><br><span class="line">        Sup[] b = Arrays.copyOf(d, d.length, Sup[].class); <span class="comment">// [4]</span></span><br><span class="line">        show(b); <span class="comment">// This "downcast" works fine:</span></span><br><span class="line">        Sub[] d2 = Arrays.copyOf(b, b.length, Sub[].class); <span class="comment">// [5]</span></span><br><span class="line">        show(d2); <span class="comment">// Bad "downcast" compiles but throws exception:</span></span><br><span class="line">        Sup[] b2 = <span class="keyword">new</span> Sup[SZ / <span class="number">2</span>];</span><br><span class="line">        Arrays.setAll(b2, Sup::<span class="keyword">new</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Sub[] d3 = Arrays.copyOf(b2, b2.length, Sub[].class); <span class="comment">// [6]</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output: a1: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14] a1: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]</span></span><br><span class="line"><span class="comment">           a2:[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]a2:[0, 1, 2, 3, 4, 5, 6]a2:[</span></span><br><span class="line"><span class="comment">           0, 1, 2, 3, 4, 5, 6, 0, 0, 0, 0, 0]a4:[4, 5, 6, 7, 8, 9, 10, 11][Sub0, Sub1, Sub2, Sub3, Sub4, Sub5, Sub6][</span></span><br><span class="line"><span class="comment">           Sub0, Sub1, Sub2, Sub3, Sub4, Sub5, Sub6]java.lang.ArrayStoreException */</span></span><br></pre></td></tr></table></figure>

<p>[1] 这是复制的基本方法;只需给出返回的复制数组的大小。这对于编写需要调整存储大小的算法很有帮助。复制之后，我们把a1的所有元素都设为1，以证明a1的变化不会影响a2中的任何东西。</p>
<p>[2] 通过更改最后一个参数，我们可以缩短或延长返回的复制数组。</p>
<p>[3] <strong>copyOf()</strong> 和 <strong>copyOfRange()</strong> 也可以使用包装类型。<strong>copyOfRange()</strong> 需要一个开始和结束索引。</p>
<p>[4] <strong>copyOf()</strong> 和 <strong>copyOfRange()</strong> 都有一个版本，该版本通过在方法调用的末尾添加目标类型来创建不同类型的数组。我首先想到的是，这可能是一种从原生数组生成包装数组的方法，反之亦然。<br>但这没用。它的实际用途是“向上转换”和“向下转换”数组。也就是说，如果您有一个子类型(派生类型)的数组，而您想要一个基类型的数组，那么这些方法将生成所需的数组。</p>
<p>[5] 您甚至可以成功地“向下强制转换”，并从超类型的数组生成子类型的数组。这个版本运行良好，因为我们只是“upcast”。</p>
<p>[6] 这个“数组转换”将编译，但是如果类型不兼容，您将得到一个运行时异常。在这里，强制将基类型转换为派生类型是非法的，因为派生对象中可能有基对象中没有的属性和方法。</p>
<p>实例表明，原生数组和对象数组都可以被复制。但是，如果复制对象的数组，那么只复制引用—不复制对象本身。这称为浅拷贝(有关更多细节，请参阅附录:传递和返回对象)。</p>
<p>还有一个方法 <strong>System.arraycopy()</strong> ，它将一个数组复制到另一个已经分配的数组中。这<strong>将不会执行自动装箱或自动卸载—两个数组必须是完全相同的类型。</strong></p>
<!-- Comparing Arrays -->

<h2 id="数组比较"><a href="#数组比较" class="headerlink" title="数组比较"></a>数组比较</h2><p><strong>数组</strong> 提供了 <strong>equals()</strong> 来比较一维数组，以及 <strong>deepEquals()</strong> 来比较多维数组。对于所有原生类型和对象，这些方法都是重载的。</p>
<p>数组相等的含义：数组必须有相同数量的元素，并且每个元素必须与另一个数组中的对应元素相等，对每个元素使用 <strong>equals()</strong>(对于原生类型，使用原生类型的包装类的 <strong>equals()</strong> 方法;例如，int的Integer.equals()。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arrays/ComparingArrays.java</span></span><br><span class="line"><span class="comment">// Using Arrays.equals()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComparingArrays</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SZ = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> String[][] twoDArray() &#123;</span><br><span class="line">        String[][] md = <span class="keyword">new</span> String[<span class="number">5</span>][];</span><br><span class="line">        Arrays.setAll(md, n -&gt; <span class="keyword">new</span> String[n]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; md.length; i++) Arrays.setAll(md[i], <span class="keyword">new</span> Rand.String()::get);</span><br><span class="line">        <span class="keyword">return</span> md;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a1 = <span class="keyword">new</span> <span class="keyword">int</span>[SZ], a2 = <span class="keyword">new</span> <span class="keyword">int</span>[SZ];</span><br><span class="line">        Arrays.setAll(a1, <span class="keyword">new</span> Count.Integer()::get);</span><br><span class="line">        Arrays.setAll(a2, <span class="keyword">new</span> Count.Integer()::get);</span><br><span class="line">        System.out.println(<span class="string">"a1 == a2: "</span> + Arrays.equals(a1, a2));</span><br><span class="line">        a2[<span class="number">3</span>] = <span class="number">11</span>;</span><br><span class="line">        System.out.println(<span class="string">"a1 == a2: "</span> + Arrays.equals(a1, a2));</span><br><span class="line">        Integer[] a1w = <span class="keyword">new</span> Integer[SZ], a2w = <span class="keyword">new</span> Integer[SZ];</span><br><span class="line">        Arrays.setAll(a1w, <span class="keyword">new</span> Count.Integer()::get);</span><br><span class="line">        Arrays.setAll(a2w, <span class="keyword">new</span> Count.Integer()::get);</span><br><span class="line">        System.out.println(<span class="string">"a1w == a2w: "</span> + Arrays.equals(a1w, a2w));</span><br><span class="line">        a2w[<span class="number">3</span>] = <span class="number">11</span>;</span><br><span class="line">        System.out.println(<span class="string">"a1w == a2w: "</span> + Arrays.equals(a1w, a2w));</span><br><span class="line">        String[][] md1 = twoDArray(), md2 = twoDArray();</span><br><span class="line">        System.out.println(Arrays.deepToString(md1));</span><br><span class="line">        System.out.println(<span class="string">"deepEquals(md1, md2): "</span> + Arrays.deepEquals(md1, md2));</span><br><span class="line">        System.out.println(<span class="string">"md1 == md2: "</span> + Arrays.equals(md1, md2));</span><br><span class="line">        md1[<span class="number">4</span>][<span class="number">1</span>] = <span class="string">"#$#$#$#"</span>;</span><br><span class="line">        System.out.println(Arrays.deepToString(md1));</span><br><span class="line">        System.out.println(<span class="string">"deepEquals(md1, md2): "</span> + Arrays.deepEquals(md1, md2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">a1 == a2: true</span></span><br><span class="line"><span class="comment">a1 == a2: false</span></span><br><span class="line"><span class="comment">a1w == a2w: true</span></span><br><span class="line"><span class="comment">a1w == a2w: false</span></span><br><span class="line"><span class="comment">[[], [btpenpc], [btpenpc, cuxszgv], [btpenpc, cuxszgv,</span></span><br><span class="line"><span class="comment"> gmeinne], [btpenpc, cuxszgv, gmeinne, eloztdv]]</span></span><br><span class="line"><span class="comment"> deepEquals(md1, md2): true</span></span><br><span class="line"><span class="comment"> md1 == md2: false</span></span><br><span class="line"><span class="comment"> [[], [btpenpc], [btpenpc, cuxszgv], [btpenpc, cuxszgv,</span></span><br><span class="line"><span class="comment"> gmeinne], [btpenpc, #$#$#$#, gmeinne, eloztdv]]</span></span><br><span class="line"><span class="comment"> deepEquals(md1, md2): false</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>最初，a1和a2是完全相等的，所以输出是true，但是之后其中一个元素改变了，这使得结果为false。a1w和a2w是对一个封装类型数组重复该练习。</p>
<p><strong>md1</strong> 和 <strong>md2</strong> 是通过 <strong>twoDArray()</strong> 以相同方式初始化的多维字符串数组。注意，<strong>deepEquals()</strong> 返回 <strong>true</strong>，因为它执行了适当的比较，而普通的 <strong>equals()</strong> 错误地返回 <strong>false</strong>。如果我们更改数组中的一个元素，<strong>deepEquals()</strong> 将检测它。</p>
<!-- Streams and Arrays -->

<h2 id="流和数组"><a href="#流和数组" class="headerlink" title="流和数组"></a>流和数组</h2><p><strong>stream()</strong> 方法很容易从某些类型的数组中生成元素流。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arrays/StreamFromArray.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamFromArray</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] s = <span class="keyword">new</span> Rand.String().array(<span class="number">10</span>);</span><br><span class="line">        Arrays.stream(s).skip(<span class="number">3</span>).limit(<span class="number">5</span>).map(ss -&gt; ss + <span class="string">"!"</span>).forEach(System.out::println);</span><br><span class="line">        <span class="keyword">int</span>[] ia = <span class="keyword">new</span> Rand.Pint().array(<span class="number">10</span>);</span><br><span class="line">        Arrays.stream(ia).skip(<span class="number">3</span>).limit(<span class="number">5</span>)</span><br><span class="line">                .map(i -&gt; i * <span class="number">10</span>).forEach(System.out::println);</span><br><span class="line">        Arrays.stream(<span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">10</span>]);</span><br><span class="line">        Arrays.stream(<span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">10</span>]);</span><br><span class="line">        <span class="comment">// Only int, long and double work:</span></span><br><span class="line">        <span class="comment">// - Arrays.stream(new boolean[10]);</span></span><br><span class="line">        <span class="comment">// - Arrays.stream(new byte[10]);</span></span><br><span class="line">        <span class="comment">// - Arrays.stream(new char[10]);</span></span><br><span class="line">        <span class="comment">// - Arrays.stream(new short[10]);</span></span><br><span class="line">        <span class="comment">// - Arrays.stream(new float[10]);</span></span><br><span class="line">        <span class="comment">// For the other types you must use wrapped arrays:</span></span><br><span class="line">        <span class="keyword">float</span>[] fa = <span class="keyword">new</span> Rand.Pfloat().array(<span class="number">10</span>);</span><br><span class="line">        Arrays.stream(ConvertTo.boxed(fa));</span><br><span class="line">        Arrays.stream(<span class="keyword">new</span> Rand.Float().array(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">    eloztdv!</span></span><br><span class="line"><span class="comment">    ewcippc!</span></span><br><span class="line"><span class="comment">    ygpoalk!</span></span><br><span class="line"><span class="comment">    ljlbynx!</span></span><br><span class="line"><span class="comment">    taprwxz!</span></span><br><span class="line"><span class="comment">    47200</span></span><br><span class="line"><span class="comment">    61770</span></span><br><span class="line"><span class="comment">    84790</span></span><br><span class="line"><span class="comment">    66560</span></span><br><span class="line"><span class="comment">    37680</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>只有“原生类型” <strong>int</strong>、<strong>long</strong> 和 <strong>double</strong> 可以与 <strong>Arrays.stream()</strong> 一起使用;对于其他的，您必须以某种方式获得一个包装类型的数组。</p>
<p>通常，将数组转换为流来生成所需的结果要比直接操作数组容易得多。请注意，即使流已经“用完”(您不能重复使用它)，您仍然拥有该数组，因此您可以以其他方式使用它—-包括生成另一个流。</p>
<!-- Sorting Arrays -->

<h2 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h2><p>根据对象的实际类型执行比较排序。一种方法是为不同的类型编写对应的排序方法，但是这样的代码不能复用。</p>
<p>编程设计的一个主要目标是“将易变的元素与稳定的元素分开”，在这里，保持不变的代码是一般的排序算法，但是变化的是对象的比较方式。因此，使用策略设计模式而不是将比较代码放入许多不同的排序源码中。使用策略模式时，变化的代码部分被封装在一个单独的类(策略对象)中。</p>
<p>您将一个策略对象交给相同的代码，该代码使用策略模式来实现其算法。通过这种方式，您将使用相同的排序代码，使不同的对象表达不同的比较方式。</p>
<p>Java有两种方式提供比较功能。第一种方法是通过实现 <strong>java.lang.Comparable</strong> 接口的原生方法。这是一个简单的接口，只含有一个方法 <strong>compareTo()</strong>。该方法接受另一个与参数类型相同的对象作为参数，如果当前对象小于参数，则产生一个负值;如果参数相等，则产生零值;如果当前对象大于参数，则产生一个正值。</p>
<p>这里有一个类，它实现了 <strong>Comparable</strong> 接口并演示了可比性，而且使用Java标准库方法 <strong>Arrays.sort()</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arrays/CompType.java</span></span><br><span class="line"><span class="comment">// Implementing Comparable in a class</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.SplittableRandom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> onjava.ArrayShow.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompType</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">CompType</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SplittableRandom r = <span class="keyword">new</span> SplittableRandom(<span class="number">47</span>);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CompType</span><span class="params">(<span class="keyword">int</span> n1, <span class="keyword">int</span> n2)</span> </span>&#123;</span><br><span class="line">        i = n1;</span><br><span class="line">        j = n2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompType <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CompType(r.nextInt(<span class="number">100</span>), r.nextInt(<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CompType[] a = <span class="keyword">new</span> CompType[<span class="number">12</span>];</span><br><span class="line">        Arrays.setAll(a, n -&gt; get());</span><br><span class="line">        show(<span class="string">"Before sorting"</span>, a);</span><br><span class="line">        Arrays.sort(a);</span><br><span class="line">        show(<span class="string">"After sorting"</span>, a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String result = <span class="string">"[i = "</span> + i + <span class="string">", j = "</span> + j + <span class="string">"]"</span>;</span><br><span class="line">        <span class="keyword">if</span> (count++ % <span class="number">3</span> == <span class="number">0</span>) result += <span class="string">"\n"</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(CompType rv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (i &lt; rv.i ? -<span class="number">1</span> : (i == rv.i ? <span class="number">0</span> : <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Before sorting: [[i = 35, j = 37], [i = 41, j = 20], [i = 77, j = 79] ,</span></span><br><span class="line"><span class="comment">                [i = 56, j = 68], [i = 48, j = 93],</span></span><br><span class="line"><span class="comment">                [i = 70, j = 7] , [i = 0, j = 25],</span></span><br><span class="line"><span class="comment">                [i = 62, j = 34], [i = 50, j = 82] ,</span></span><br><span class="line"><span class="comment">                [i = 31, j = 67], [i = 66, j = 54],</span></span><br><span class="line"><span class="comment">                [i = 21, j = 6] ]</span></span><br><span class="line"><span class="comment">After sorting: [[i = 0, j = 25], [i = 21, j = 6], [i = 31, j = 67] ,</span></span><br><span class="line"><span class="comment">               [i = 35, j = 37], [i = 41, j = 20], [i = 48, j = 93] ,</span></span><br><span class="line"><span class="comment">               [i = 50, j = 82], [i = 56, j = 68], [i = 62, j = 34] ,</span></span><br><span class="line"><span class="comment">               [i = 66, j = 54], [i = 70, j = 7], [i = 77, j = 79] ]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>当您定义比较方法时，您有责任决定将一个对象与另一个对象进行比较意味着什么。这里，在比较中只使用i值和j值<br>将被忽略。</p>
<p><strong>get()</strong> 方法通过使用随机值初始化CompType对象来构建它们。在 <strong>main()</strong> 中，<strong>get()</strong> 与 <strong>Arrays.setAll()</strong> 一起使用，以填充一个 <strong>CompType类型</strong> 数组，然后对其排序。如果没有实现 <strong>Comparable接口</strong>，那么当您试图调用 <strong>sort()</strong> 时，您将在运行时获得一个 <strong>ClassCastException</strong> 。这是因为 <strong>sort()</strong> 将其参数转换为 <strong>Comparable类型</strong>。</p>
<p>现在假设有人给了你一个没有实现 <strong>Comparable接口</strong> 的类，或者给了你一个实现 <strong>Comparable接口</strong> 的类，但是你不喜欢它的工作方式而愿意有一个不同的对于此类型的比较方法。为了解决这个问题，创建一个实现 <strong>Comparator</strong> 接口的单独的类(在集合一章中简要介绍)。它有两个方法，<strong>compare()</strong> 和 <strong>equals()</strong>。但是，除了特殊的性能需求外，您不需要实现 <strong>equals()</strong>，因为无论何时创建一个类，它都是隐式地继承自 <strong>Object</strong>，<strong>Object</strong> 有一个equals()。您可以只使用默认的 <strong>Object equals()</strong> 来满足接口的规范。</p>
<p>集合类(注意复数;我们将在下一章节讨论它) 包含一个方法 <strong>reverseOrder()</strong>，它生成一个来 <strong>Comparator</strong>（比较器）反转自然排序顺序。这可以应用到比较对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arrays/Reverse.java</span></span><br><span class="line"><span class="comment">// The Collections.reverseOrder() Comparator</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> onjava.ArrayShow.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reverse</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CompType[] a = <span class="keyword">new</span> CompType[<span class="number">12</span>];</span><br><span class="line">        Arrays.setAll(a, n -&gt; CompType.get());</span><br><span class="line">        show(<span class="string">"Before sorting"</span>, a);</span><br><span class="line">        Arrays.sort(a, Collections.reverseOrder());</span><br><span class="line">        show(<span class="string">"After sorting"</span>, a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Before sorting: [[i = 35, j = 37], [i = 41, j = 20],</span></span><br><span class="line"><span class="comment">                [i = 77, j = 79] , [i = 56, j = 68],</span></span><br><span class="line"><span class="comment">                [i = 48, j = 93], [i = 70, j = 7],</span></span><br><span class="line"><span class="comment">                [i = 0, j = 25], [i = 62, j = 34],</span></span><br><span class="line"><span class="comment">                [i = 50, j = 82] , [i = 31, j = 67],</span></span><br><span class="line"><span class="comment">                [i = 66, j = 54], [i = 21, j = 6] ]</span></span><br><span class="line"><span class="comment">After sorting: [[i = 77, j = 79], [i = 70, j = 7],</span></span><br><span class="line"><span class="comment">                [i = 66, j = 54] , [i = 62, j = 34],</span></span><br><span class="line"><span class="comment">                [i = 56, j = 68], [i = 50, j = 82] ,</span></span><br><span class="line"><span class="comment">                [i = 48, j = 93], [i = 41, j = 20],</span></span><br><span class="line"><span class="comment">                [i = 35, j = 37] , [i = 31, j = 67],</span></span><br><span class="line"><span class="comment">                [i = 21, j = 6], [i = 0, j = 25] ]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>您还可以编写自己的比较器。这个比较CompType对象基于它们的j值而不是它们的i值:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arrays/ComparatorTest.java</span></span><br><span class="line"><span class="comment">// Implementing a Comparator for a class</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> onjava.ArrayShow.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompTypeComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">CompType</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(CompType o1, CompType o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (o1.j &lt; o2.j ? -<span class="number">1</span> : (o1.j == o2.j ? <span class="number">0</span> : <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComparatorTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CompType[] a = <span class="keyword">new</span> CompType[<span class="number">12</span>];</span><br><span class="line">        Arrays.setAll(a, n -&gt; CompType.get());</span><br><span class="line">        show(<span class="string">"Before sorting"</span>, a);</span><br><span class="line">        Arrays.sort(a, <span class="keyword">new</span> CompTypeComparator());</span><br><span class="line">        show(<span class="string">"After sorting"</span>, a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Before sorting:[[i = 35, j = 37], [i = 41, j = 20], [i = 77, j = 79] ,</span></span><br><span class="line"><span class="comment">                [i = 56, j = 68], [i = 48, j = 93], [i = 70, j = 7] ,</span></span><br><span class="line"><span class="comment">                [i = 0, j = 25], [i = 62, j = 34], [i = 50, j = 82],</span></span><br><span class="line"><span class="comment">                [i = 31, j = 67], [i = 66, j = 54], [i = 21, j = 6] ]</span></span><br><span class="line"><span class="comment">After sorting: [[i = 21, j = 6], [i = 70, j = 7], [i = 41, j = 20] ,</span></span><br><span class="line"><span class="comment">                [i = 0, j = 25], [i = 62, j = 34], [i = 35, j = 37] ,</span></span><br><span class="line"><span class="comment">                [i = 66, j = 54], [i = 31, j = 67], [i = 56, j = 68] ,</span></span><br><span class="line"><span class="comment">                [i = 77, j = 79], [i = 50, j = 82], [i = 48, j = 93] ]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<!-- Using Arrays.sort() -->

<h2 id="Arrays-sort-的使用"><a href="#Arrays-sort-的使用" class="headerlink" title="Arrays.sort()的使用"></a>Arrays.sort()的使用</h2><p>使用内置的排序方法，您可以对实现了 <strong>Comparable</strong> 接口或具有 <strong>Comparator</strong> 的任何对象数组 或 任何原生数组进行排序。这里我们生成一个随机字符串对象数组并对其排序:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arrays/StringSorting.java</span></span><br><span class="line"><span class="comment">// Sorting an array of Strings</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> onjava.ArrayShow.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringSorting</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] sa = <span class="keyword">new</span> Rand.String().array(<span class="number">20</span>);</span><br><span class="line">        show(<span class="string">"Before sort"</span>, sa);</span><br><span class="line">        Arrays.sort(sa);</span><br><span class="line">        show(<span class="string">"After sort"</span>, sa);</span><br><span class="line">        Arrays.sort(sa, Collections.reverseOrder());</span><br><span class="line">        show(<span class="string">"Reverse sort"</span>, sa);</span><br><span class="line">        Arrays.sort(sa, String.CASE_INSENSITIVE_ORDER);</span><br><span class="line">        show(<span class="string">"Case-insensitive sort"</span>, sa);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Before sort: [btpenpc, cuxszgv, gmeinne, eloztdv, ewcippc,</span></span><br><span class="line"><span class="comment">            ygpoalk, ljlbynx, taprwxz, bhmupju, cjwzmmr,</span></span><br><span class="line"><span class="comment">            anmkkyh, fcjpthl, skddcat, jbvlgwc, mvducuj,</span></span><br><span class="line"><span class="comment">            ydpulcq, zehpfmm, zrxmclh, qgekgly, hyoubzl]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">After sort: [anmkkyh, bhmupju, btpenpc, cjwzmmr, cuxszgv,</span></span><br><span class="line"><span class="comment">            eloztdv, ewcippc, fcjpthl, gmeinne, hyoubzl,</span></span><br><span class="line"><span class="comment">            jbvlgwc, ljlbynx, mvducuj, qgekgly, skddcat,</span></span><br><span class="line"><span class="comment">            taprwxz, ydpulcq, ygpoalk, zehpfmm, zrxmclh]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Reverse sort: [zrxmclh, zehpfmm, ygpoalk, ydpulcq,taprwxz,</span></span><br><span class="line"><span class="comment">            skddcat, qgekgly, mvducuj, ljlbynx, jbvlgwc,</span></span><br><span class="line"><span class="comment">            hyoubzl, gmeinne, fcjpthl, ewcippc, eloztdv,</span></span><br><span class="line"><span class="comment">            cuxszgv, cjwzmmr, btpenpc, bhmupju, anmkkyh]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Case-insensitive sort: [anmkkyh, bhmupju, btpenpc, cjwzmmr,</span></span><br><span class="line"><span class="comment">                cuxszgv, eloztdv, ewcippc, fcjpthl, gmeinne,</span></span><br><span class="line"><span class="comment">                hyoubzl, jbvlgwc, ljlbynx, mvducuj, qgekgly,</span></span><br><span class="line"><span class="comment">                skddcat, taprwxz, ydpulcq, ygpoalk, zehpfmm, zrxmclh]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>注意字符串排序算法中的输出。它是字典式的，所以它把所有以大写字母开头的单词放在前面，然后是所有以小写字母开头的单词。(电话簿通常是这样分类的。)<strong>无论大小写，要将单词组合在一起，</strong>请使用 <strong>String.CASE_INSENSITIVE_ORDER</strong> ，如对sort()的最后一次调用所示。</p>
<p>Java标准库中使用的<strong>排序算法被设计为最适合您正在排序的类型—-原生类型的快速排序和对象的归并排序。</strong></p>
<!-- Sorting in Parallel -->

<h2 id="并行排序"><a href="#并行排序" class="headerlink" title="并行排序"></a>并行排序</h2><p>如果排序性能是一个问题，那么可以使用 <strong>Java 8 parallelSort()</strong>，它为所有不可预见的情况(包括数组的排序区域或使用了比较器)提供了重载版本。为了查看相比于普通的sort(), <strong>parallelSort()</strong> 的优点，我们使用了用来验证代码时的 <strong>JMH</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arrays/jmh/ParallelSort.java</span></span><br><span class="line"><span class="keyword">package</span> arrays.jmh;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.annotations.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="meta">@State</span>(Scope.Thread)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParallelSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span>[] la;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Setup</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        la = <span class="keyword">new</span> Rand.Plong().array(<span class="number">100_000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Arrays.sort(la);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parallelSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Arrays.parallelSort(la);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>parallelSort()</strong> 算法将大数组拆分成更小的数组，直到数组大小达到极限，然后使用普通的 <strong>Arrays .sort()</strong> 方法。然后合并结果。该算法需要不大于原始数组的额外工作空间。</p>
<p>您可能会看到不同的结果，但是在我的机器上，并行排序将速度提高了大约3倍。由于并行版本使用起来很简单，所以很容易考虑在任何地方使用它，而不是<br><strong>Arrays.sort ()</strong>。当然，它可能不是那么简单—看看微基准测试。</p>
<!-- Searching with Arrays.binarySearch() -->

<h2 id="binarySearch二分查找"><a href="#binarySearch二分查找" class="headerlink" title="binarySearch二分查找"></a>binarySearch二分查找</h2><p>一旦数组被排序，您就可以通过使用 <strong>Arrays.binarySearch()</strong> 来执行对特定项的快速搜索。但是，如果尝试在未排序的数组上使用 <strong>binarySearch()</strong>，结果是不可预测的。下面的示例使用 <strong>Rand.Pint</strong> 类来创建一个填充随机整形值的数组，然后调用 <strong>getAsInt()</strong> (因为 <strong>Rand.Pint</strong> 是一个 <strong>IntSupplier</strong>)来产生搜索值:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arrays/ArraySearching.java</span></span><br><span class="line"><span class="comment">// Using Arrays.binarySearch()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> onjava.ArrayShow.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArraySearching</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Rand.Pint rand = <span class="keyword">new</span> Rand.Pint();</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> Rand.Pint().array(<span class="number">25</span>);</span><br><span class="line">        Arrays.sort(a);</span><br><span class="line">        show(<span class="string">"Sorted array"</span>, a);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> r = rand.getAsInt();</span><br><span class="line">            <span class="keyword">int</span> location = Arrays.binarySearch(a, r);</span><br><span class="line">            <span class="keyword">if</span> (location &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Location of "</span> + r + <span class="string">" is "</span> + location + <span class="string">", a["</span> + location + <span class="string">"] is "</span> + a[location]);</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// Out of while loop</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Sorted array: [125, 267, 635, 650, 1131, 1506, 1634, 2400, 2766,</span></span><br><span class="line"><span class="comment">               3063, 3768, 3941, 4720, 4762, 4948, 5070, 5682,</span></span><br><span class="line"><span class="comment">               5807, 6177, 6193, 6656, 7021, 8479, 8737, 9954]</span></span><br><span class="line"><span class="comment">Location of 635 is 2, a[2] is 635</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>在while循环中，随机值作为搜索项生成，直到在数组中找到其中一个为止。</p>
<p>如果找到了搜索项，<strong>Arrays.binarySearch()</strong> 将生成一个大于或等于零的值。否则，它将产生一个负值，表示如果手动维护已排序的数组，则应该插入元素的位置。产生的值是 -(插入点) - 1 。插入点是大于键的第一个元素的索引，如果数组中的所有元素都小于指定的键，则是 <strong>a.size()</strong> 。</p>
<p>如果数组包含重复的元素，则无法保证找到其中的那些重复项。搜索算法不是为了支持重复的元素，而是为了容忍它们。如果需要没有重复元素的排序列表，可以使用 <strong>TreeSet</strong> (用于维持排序顺序)或 <strong>LinkedHashSet</strong> (用于维持插入顺序)。这些类自动为您处理所有的细节。只有在出现性能瓶颈的情况下，才应该使用手工维护的数组替换这些类中的一个。</p>
<p>如果使用比较器(原语数组不允许使用比较器进行排序)对对象数组进行排序，那么在执行 <strong>binarySearch()</strong> (使用重载版本的binarySearch())时必须包含相同的比较器。例如，可以修改 <strong>StringSorting.java</strong> 来执行搜索:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arrays/AlphabeticSearch.java</span></span><br><span class="line"><span class="comment">// Searching with a Comparator</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> onjava.ArrayShow.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AlphabeticSearch</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] sa = <span class="keyword">new</span> Rand.String().array(<span class="number">30</span>);</span><br><span class="line">        Arrays.sort(sa, String.CASE_INSENSITIVE_ORDER);</span><br><span class="line">        show(sa);</span><br><span class="line">        <span class="keyword">int</span> index = Arrays.binarySearch(sa, sa[<span class="number">10</span>], String.CASE_INSENSITIVE_ORDER);</span><br><span class="line">        System.out.println(<span class="string">"Index: "</span> + index + <span class="string">"\n"</span> + sa[index]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[anmkkyh, bhmupju, btpenpc, cjwzmmr, cuxszgv, eloztdv, ewcippc,</span></span><br><span class="line"><span class="comment">ezdeklu, fcjpthl, fqmlgsh, gmeinne, hyoubzl, jbvlgwc, jlxpqds,</span></span><br><span class="line"><span class="comment">ljlbynx, mvducuj, qgekgly, skddcat, taprwxz, uybypgp, vjsszkn,</span></span><br><span class="line"><span class="comment">vniyapk, vqqakbm, vwodhcf, ydpulcq, ygpoalk, yskvett, zehpfmm,</span></span><br><span class="line"><span class="comment">zofmmvm, zrxmclh]</span></span><br><span class="line"><span class="comment">Index: 10 gmeinne</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>比较器必须作为第三个参数传递给重载的 <strong>binarySearch()</strong> 。在本例中，成功是有保证的，因为搜索项是从数组本身中选择的。</p>
<!-- Accumulating with parallelPrefix() -->

<h2 id="parallelPrefix并行前缀"><a href="#parallelPrefix并行前缀" class="headerlink" title="parallelPrefix并行前缀"></a>parallelPrefix并行前缀</h2><p>没有“prefix()”方法，只有 <strong>parallelPrefix()</strong>。这类似于 <strong>Stream</strong> 类中的 <strong>reduce()</strong> 方法:它对前一个元素和当前元素执行一个操作，并将结果放入当前元素位置:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arrays/ParallelPrefix1.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> onjava.ArrayShow.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParallelPrefix1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> Count.Pint().array(<span class="number">10</span>);</span><br><span class="line">        show(nums);</span><br><span class="line">        System.out.println(Arrays.stream(nums).reduce(Integer::sum).getAsInt());</span><br><span class="line">        Arrays.parallelPrefix(nums, Integer::sum);</span><br><span class="line">        show(nums);</span><br><span class="line">        System.out.println(Arrays.stream(<span class="keyword">new</span> Count.Pint().array(<span class="number">6</span>)).reduce(Integer::sum).getAsInt());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="comment">45</span></span><br><span class="line"><span class="comment">[0, 1, 3, 6, 10, 15, 21, 28, 36, 45]</span></span><br><span class="line"><span class="comment">15</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>这里我们对数组应用Integer::sum。在位置0中，它将先前计算的值(因为没有先前的值)与原始数组位置0中的值组合在一起。在位置1中，它获取之前计算的值(它只是存储在位置0中)，并将其与位置1中先前计算的值相结合。依次往复。</p>
<p>使用 <strong>Stream.reduce()</strong>，您只能得到最终结果，而<strong>使用 Arrays.parallelPrefix()，您还可以得到所有中间计算，以确保它们是有用的。</strong>注意，第二个 <strong>Stream.reduce()</strong> 计算的结果已经在 <strong>parallelPrefix()</strong> 计算的数组中。</p>
<p>使用字符串可能更清楚:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arrays/ParallelPrefix2.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> onjava.ArrayShow.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParallelPrefix2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] strings = <span class="keyword">new</span> Rand.String(<span class="number">1</span>).array(<span class="number">8</span>);</span><br><span class="line">        show(strings);</span><br><span class="line">        Arrays.parallelPrefix(strings, (a, b) -&gt; a + b);</span><br><span class="line">        show(strings);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[b, t, p, e, n, p, c, c]</span></span><br><span class="line"><span class="comment">[b, bt, btp, btpe, btpen, btpenp, btpenpc, btpenpcc]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>如前所述，使用<strong>流进行初始化非常优雅，但是对于大型数组，这种方法可能会耗尽堆空间。</strong>使用 <strong>setAll()</strong> 执行初始化更节省内存:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arrays/ParallelPrefix3.java</span></span><br><span class="line"><span class="comment">// &#123;ExcludeFromTravisCI&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParallelPrefix3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">10_000_000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span>[] nums = <span class="keyword">new</span> <span class="keyword">long</span>[SIZE];</span><br><span class="line">        Arrays.setAll(nums, n -&gt; n);</span><br><span class="line">        Arrays.parallelPrefix(nums, Long::sum);</span><br><span class="line">        System.out.println(<span class="string">"First 20: "</span> + nums[<span class="number">19</span>]);</span><br><span class="line">        System.out.println(<span class="string">"First 200: "</span> + nums[<span class="number">199</span>]);</span><br><span class="line">        System.out.println(<span class="string">"All: "</span> + nums[nums.length - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">First 20: 190</span></span><br><span class="line"><span class="comment">First 200: 19900</span></span><br><span class="line"><span class="comment">All: 49999995000000</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>因为正确使用 <strong>parallelPrefix()</strong> 可能相当复杂，所以通常应该只在存在内存或速度问题(或两者都有)时使用。否则，<strong>Stream.reduce()</strong> 应该是您的首选。</p>
<!-- Summary -->

<h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><p>Java为固定大小的低级数组提供了合理的支持。这种<strong>数组强调的是性能而不是灵活性，就像C和c++数组模型一样。</strong>在Java的最初版本中，固定大小的低级数组是绝对必要的，这不仅是因为Java设计人员选择包含原生类型(也考虑到性能)，还因为那个版本对集合的支持非常少。因此，在早期的Java版本中，选择数组总是合理的。</p>
<p>在Java的后续版本中，集合支持得到了显著的改进，现在集合在除性能外的所有方面都优于数组，即使这样，集合的性能也得到了显著的改进。正如本书其他部分所述，无论如何，性能问题通常不会出现在您设想的地方。</p>
<p>使用自动装箱和泛型，在集合中保存原生类型是毫不费力的，这进一步鼓励您用集合替换低级数组。由于泛型产生类型安全的集合，数组在这方面也不再有优势。</p>
<p>如本章所述，<strong>当您尝试使用泛型时，您将看到泛型对数组是相当不友好的。通常，即使可以让泛型和数组以某种形式一起工作(在下一章中您将看到)，在编译期间仍然会出现“unchecked”警告。</strong></p>
<p>有几次，当我们讨论特定的例子时，我直接从Java语言设计人员那里听到我应该使用集合而不是数组(我使用数组来演示特定的技术，所以我没有这个选项)。</p>
<p>所有这些问题都表明，在使用Java的最新版本进行编程时，应该“优先选择集合而不是数组”。<strong>只有当您证明性能是一个问题(并且切换到一个数组实际上会有很大的不同)时，才应该重构到数组。</strong>这是一个相当大胆的声明，但是有些语言根本没有固定大小的低级数组。它们只有可调整大小的集合，而且比C/C++/java风格的数组功能多得多。例如，Python有一个使用基本数组语法的列表类型，但是具有更大的功能—您甚至可以从它继承:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># arrays/PythonLists.py</span></span><br><span class="line"></span><br><span class="line">aList=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]print(type(aList)) <span class="comment">#&lt;type 'list'&gt;</span></span><br><span class="line">print(aList) <span class="comment"># [1,2,3,4,5]</span></span><br><span class="line">        print(aList[<span class="number">4</span>]) <span class="comment"># 5Basic list indexing</span></span><br><span class="line">        aList.append(<span class="number">6</span>) <span class="comment"># lists can be resized</span></span><br><span class="line">        aList+=[<span class="number">7</span>,<span class="number">8</span>] <span class="comment"># Add a list to a list</span></span><br><span class="line">        print(aList) <span class="comment"># [1,2,3,4,5,6,7,8]</span></span><br><span class="line">        aSlice=aList[<span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line">        print(aSlice) <span class="comment"># [3,4]</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span><span class="params">(list)</span>:</span> <span class="comment"># Inherit from list</span></span><br><span class="line">        <span class="comment"># Define a method;'this'pointer is explicit:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">getReversed</span><span class="params">(self)</span>:</span></span><br><span class="line">            reversed=self[:] <span class="comment"># Copy list using slices</span></span><br><span class="line">            reversed.reverse() <span class="comment"># Built-in list method</span></span><br><span class="line">            <span class="keyword">return</span> reversed</span><br><span class="line">        <span class="comment"># No'new'necessary for object creation:</span></span><br><span class="line">        list2=MyList(aList)</span><br><span class="line">        print(type(list2)) <span class="comment">#&lt;class '__main__.MyList'&gt;</span></span><br><span class="line">        print(list2.getReversed()) <span class="comment"># [8,7,6,5,4,3,2,1]</span></span><br><span class="line">        output=<span class="string">"""</span></span><br><span class="line"><span class="string">        &lt;class 'list'&gt;</span></span><br><span class="line"><span class="string">        [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="string">        5</span></span><br><span class="line"><span class="string">        [1, 2, 3, 4, 5, 6, 7, 8]</span></span><br><span class="line"><span class="string">        [3, 4]</span></span><br><span class="line"><span class="string">        &lt;class '__main__.MyList'&gt;</span></span><br><span class="line"><span class="string">        [8, 7, 6, 5, 4, 3, 2, 1]</span></span><br><span class="line"><span class="string">        """</span></span><br></pre></td></tr></table></figure>

<p>前一章介绍了基本的Python语法。在这里，通过用方括号包围以逗号分隔的对象序列来创建列表。结果是一个运行时类型为list的对象(print语句的输出显示为同一行中的注释)。打印列表的结果与在Java中使用Arrays.toString()的结果相同。<br>通过将 : 操作符放在索引操作中，通过切片来创建列表的子序列。list类型有更多的内置操作，通常只需要序列类型。<br>MyList是一个类定义;基类放在括号内。在类内部，def语句生成方法，该方法的第一个参数在Java中自动与之等价，除了在Python中它是显式的，而且标识符self是按约定使用的(它不是关键字)。注意构造函数是如何自动继承的。</p>
<p>虽然一切在Python中真的是一个对象(包括整数和浮点类型),你仍然有一个安全门,因为你可以优化性能关键型的部分代码编写扩展的C, c++或使用特殊的工具设计容易加速您的Python代码(有很多)。通过这种方式，可以在不影响性能改进的情况下保持对象的纯度。</p>
<p>PHP甚至更进一步，它只有一个数组类型，既充当int索引数组，又充当关联数组(Map)。</p>
<p>在经历了这么多年的Java发展之后，我们可以很有趣地推测，如果重新开始，设计人员是否会将原生类型和低级数组放在该语言中(同样在JVM上运行的Scala语言不包括这些)。如果不考虑这些，就有可能开发出一种真正纯粹的面向对象语言(尽管有这样的说法，Java并不是一种纯粹的面向对象语言，这正是因为它的底层缺陷)。关于效率的最初争论总是令人信服的，但是随着时间的推移，我们已经看到了从这个想法向更高层次的组件(如集合)的演进。此外，如果集合可以像在某些语言中一样构建到核心语言中，那么编译器就有更好的机会进行优化。</p>
<p>撇开““Green-fields”的推测不谈，我们肯定会被数组所困扰，当你阅读代码时就会看到它们。然而，集合几乎总是更好的选择。</p>

    </div>

    
    
    
    
    <div>
     
      <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>

     
    </div>
    
        
      
        <div id="reward-container">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button id="reward-button" disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">

  </div>
</div>

      
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>nicolas lee</li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://codeofli.github.io/2019/10/java-note/OnJava8/OnJava8-3/" title="OnJava8-3">https://codeofli.github.io/2019/10/java-note/OnJava8/OnJava8-3/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li>
</ul>
</div>

      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/学习笔记/" rel="tag"># 学习笔记</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2019/10/java-note/OnJava8/OnJava8-2/" rel="next" title="OnJava8-2">
                  <i class="fa fa-chevron-left"></i> OnJava8-2
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2019/10/java-note/OnJava8/OnJava8-4/" rel="prev" title="OnJava8-4">
                  OnJava8-4 <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#第二十章-泛型"><span class="nav-number">1.</span> <span class="nav-text">第二十章 泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#与-C-的比较"><span class="nav-number">1.0.1.</span> <span class="nav-text">与 C++ 的比较</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#简单泛型"><span class="nav-number">1.1.</span> <span class="nav-text">简单泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一个元组类库"><span class="nav-number">1.1.1.</span> <span class="nav-text">一个元组类库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一个堆栈类"><span class="nav-number">1.1.2.</span> <span class="nav-text">一个堆栈类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RandomList"><span class="nav-number">1.1.3.</span> <span class="nav-text">RandomList</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#泛型接口"><span class="nav-number">1.2.</span> <span class="nav-text">泛型接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#泛型方法"><span class="nav-number">1.3.</span> <span class="nav-text">泛型方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#变长参数和泛型方法"><span class="nav-number">1.3.1.</span> <span class="nav-text">变长参数和泛型方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一个泛型的-Supplier"><span class="nav-number">1.3.2.</span> <span class="nav-text">一个泛型的 Supplier</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#简化元组的使用"><span class="nav-number">1.3.3.</span> <span class="nav-text">简化元组的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一个-Set-工具"><span class="nav-number">1.3.4.</span> <span class="nav-text">一个 Set 工具</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构建复杂模型"><span class="nav-number">1.4.</span> <span class="nav-text">构建复杂模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#泛型擦除"><span class="nav-number">1.5.</span> <span class="nav-text">泛型擦除</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#C-的方式"><span class="nav-number">1.5.1.</span> <span class="nav-text">C++ 的方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#迁移兼容性"><span class="nav-number">1.5.2.</span> <span class="nav-text">迁移兼容性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#擦除的问题"><span class="nav-number">1.5.3.</span> <span class="nav-text">擦除的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#边界处的动作"><span class="nav-number">1.5.4.</span> <span class="nav-text">边界处的动作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#补偿擦除"><span class="nav-number">1.6.</span> <span class="nav-text">补偿擦除</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建类型的实例"><span class="nav-number">1.6.1.</span> <span class="nav-text">创建类型的实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#泛型数组"><span class="nav-number">1.6.2.</span> <span class="nav-text">泛型数组</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#边界"><span class="nav-number">1.7.</span> <span class="nav-text">边界</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#extends-T-and-super-T"><span class="nav-number">1.8.</span> <span class="nav-text">? extends T and ? super T</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#通配符"><span class="nav-number">1.9.</span> <span class="nav-text">通配符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编译器有多聪明"><span class="nav-number">1.9.1.</span> <span class="nav-text">编译器有多聪明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#逆变"><span class="nav-number">1.9.2.</span> <span class="nav-text">逆变</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#无界通配符"><span class="nav-number">1.9.3.</span> <span class="nav-text">无界通配符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#捕获转换"><span class="nav-number">1.9.4.</span> <span class="nav-text">捕获转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#问题"><span class="nav-number">1.10.</span> <span class="nav-text">问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#任何基本类型都不能作为类型参数"><span class="nav-number">1.10.1.</span> <span class="nav-text">任何基本类型都不能作为类型参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现参数化接口"><span class="nav-number">1.10.2.</span> <span class="nav-text">实现参数化接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#转型和警告"><span class="nav-number">1.10.3.</span> <span class="nav-text">转型和警告</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重载"><span class="nav-number">1.10.4.</span> <span class="nav-text">重载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基类劫持接口"><span class="nav-number">1.10.5.</span> <span class="nav-text">基类劫持接口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自限定的类型"><span class="nav-number">1.11.</span> <span class="nav-text">自限定的类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#古怪的循环泛型"><span class="nav-number">1.11.1.</span> <span class="nav-text">古怪的循环泛型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自限定"><span class="nav-number">1.11.2.</span> <span class="nav-text">自限定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参数协变"><span class="nav-number">1.11.3.</span> <span class="nav-text">参数协变</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态类型安全"><span class="nav-number">1.12.</span> <span class="nav-text">动态类型安全</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#混型"><span class="nav-number">1.13.</span> <span class="nav-text">混型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#C-中的混型"><span class="nav-number">1.13.1.</span> <span class="nav-text">C++ 中的混型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#与接口混合"><span class="nav-number">1.13.2.</span> <span class="nav-text">与接口混合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用装饰器模式"><span class="nav-number">1.13.3.</span> <span class="nav-text">使用装饰器模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#与动态代理混合"><span class="nav-number">1.13.4.</span> <span class="nav-text">与动态代理混合</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#潜在类型机制"><span class="nav-number">1.14.</span> <span class="nav-text">潜在类型机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pyhton-中的潜在类型"><span class="nav-number">1.14.1.</span> <span class="nav-text">pyhton 中的潜在类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-中的潜在类型"><span class="nav-number">1.14.2.</span> <span class="nav-text">C++ 中的潜在类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Go-中的潜在类型"><span class="nav-number">1.14.3.</span> <span class="nav-text">Go 中的潜在类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java中的直接潜在类型"><span class="nav-number">1.14.4.</span> <span class="nav-text">java中的直接潜在类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对缺乏潜在类型机制的补偿"><span class="nav-number">1.15.</span> <span class="nav-text">对缺乏潜在类型机制的补偿</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#反射"><span class="nav-number">1.15.1.</span> <span class="nav-text">反射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#将一个方法应用于序列"><span class="nav-number">1.15.2.</span> <span class="nav-text">将一个方法应用于序列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java8-中的辅助潜在类型"><span class="nav-number">1.16.</span> <span class="nav-text">Java8 中的辅助潜在类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用Suppliers类的通用方法"><span class="nav-number">1.16.1.</span> <span class="nav-text">使用Suppliers类的通用方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结：类型转换真的如此之糟吗？"><span class="nav-number">1.17.</span> <span class="nav-text">总结：类型转换真的如此之糟吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进阶阅读"><span class="nav-number">1.18.</span> <span class="nav-text">进阶阅读</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第二十一章-数组"><span class="nav-number">2.</span> <span class="nav-text">第二十一章 数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#数组特性"><span class="nav-number">2.1.</span> <span class="nav-text">数组特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#用于显示数组的实用程序"><span class="nav-number">2.1.1.</span> <span class="nav-text">用于显示数组的实用程序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一等对象"><span class="nav-number">2.2.</span> <span class="nav-text">一等对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一等对象-1"><span class="nav-number">2.3.</span> <span class="nav-text">一等对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#返回数组"><span class="nav-number">2.4.</span> <span class="nav-text">返回数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多维数组"><span class="nav-number">2.5.</span> <span class="nav-text">多维数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#泛型数组-1"><span class="nav-number">2.6.</span> <span class="nav-text">泛型数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Arrays的fill方法"><span class="nav-number">2.7.</span> <span class="nav-text">Arrays的fill方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Arrays的setAll方法"><span class="nav-number">2.8.</span> <span class="nav-text">Arrays的setAll方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#增量生成"><span class="nav-number">2.9.</span> <span class="nav-text">增量生成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#随机生成"><span class="nav-number">2.10.</span> <span class="nav-text">随机生成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#泛型和基本数组"><span class="nav-number">2.11.</span> <span class="nav-text">泛型和基本数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组元素修改"><span class="nav-number">2.12.</span> <span class="nav-text">数组元素修改</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组并行"><span class="nav-number">2.13.</span> <span class="nav-text">数组并行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Arrays工具类"><span class="nav-number">2.14.</span> <span class="nav-text">Arrays工具类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组拷贝"><span class="nav-number">2.15.</span> <span class="nav-text">数组拷贝</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组比较"><span class="nav-number">2.16.</span> <span class="nav-text">数组比较</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#流和数组"><span class="nav-number">2.17.</span> <span class="nav-text">流和数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组排序"><span class="nav-number">2.18.</span> <span class="nav-text">数组排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Arrays-sort-的使用"><span class="nav-number">2.19.</span> <span class="nav-text">Arrays.sort()的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#并行排序"><span class="nav-number">2.20.</span> <span class="nav-text">并行排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#binarySearch二分查找"><span class="nav-number">2.21.</span> <span class="nav-text">binarySearch二分查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#parallelPrefix并行前缀"><span class="nav-number">2.22.</span> <span class="nav-text">parallelPrefix并行前缀</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#本章小结"><span class="nav-number">2.23.</span> <span class="nav-text">本章小结</span></a></li></ol></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/assets/img/avatar.jpg"
      alt="nicolas lee">
  <p class="site-author-name" itemprop="name">nicolas lee</p>
  <div class="site-description" itemprop="description">Yesterday you said tomorow.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">48</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/codeOflI" title="GitHub &rarr; https://github.com/codeOflI" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://blog.csdn.net/qq_42835910" title="CSDN &rarr; https://blog.csdn.net/qq_42835910" rel="noopener" target="_blank"><i class="fa fa-fw fa-crosshairs"></i>CSDN</a>
      </span>
    
  </div>
  <div class="cc-license motion-element" itemprop="license">
    
  
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2019 – <span itemprop="copyrightYear">2021</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">nicolas lee</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数"></span>
</div>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
  
    <span class="post-meta-divider">|</span>
  
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
  
</div>












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.1"></script><script src="/js/motion.js?v=7.4.1"></script>
<script src="/js/schemes/pisces.js?v=7.4.1"></script>

<script src="/js/next-boot.js?v=7.4.1"></script>



  





















  

  

  

</body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>